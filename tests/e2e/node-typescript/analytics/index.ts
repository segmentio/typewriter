/**
 * This client was automatically generated by Segment Typewriter. ** Do Not Edit **
 */

/**
 * Ajv is a peer dependency for development builds. It's used to apply run-time validation
 * to message payloads before passing them on to the underlying analytics instance.
 *
 * Note that the production bundle does not depend on Ajv.
 *
 * You can install it with: `npm install --save-dev ajv`.
 */
import Ajv from 'ajv'
import * as Segment from './segment'

export interface CustomViolationHandler {
	'regex property': string
}
export interface DefaultViolationHandler {
	'regex property': string
}
export interface OptionalArrayWithPropertiesItem {
	/**
	 * Optional any property
	 */
	'optional any'?: any | null
	/**
	 * Optional array property
	 */
	'optional array'?: any[] | null
	/**
	 * Optional boolean property
	 */
	'optional boolean'?: boolean | null
	/**
	 * Optional integer property
	 */
	'optional int'?: number | null
	/**
	 * Optional number property
	 */
	'optional number'?: number | null
	/**
	 * Optional object property
	 */
	'optional object'?: Record<string, any> | null
	/**
	 * Optional string property
	 */
	'optional string'?: string | null
	/**
	 * Optional string property with a regex conditional
	 */
	'optional string with regex'?: string | null
}
export interface OptionalObjectWithProperties {
	/**
	 * Optional any property
	 */
	'optional any'?: any | null
	/**
	 * Optional array property
	 */
	'optional array'?: any[] | null
	/**
	 * Optional boolean property
	 */
	'optional boolean'?: boolean | null
	/**
	 * Optional integer property
	 */
	'optional int'?: number | null
	/**
	 * Optional number property
	 */
	'optional number'?: number | null
	/**
	 * Optional object property
	 */
	'optional object'?: Record<string, any> | null
	/**
	 * Optional string property
	 */
	'optional string'?: string | null
	/**
	 * Optional string property with a regex conditional
	 */
	'optional string with regex'?: string | null
}
export interface EveryNullableOptionalType {
	/**
	 * Optional any property
	 */
	'optional any'?: any | null
	/**
	 * Optional array property
	 */
	'optional array'?: any[] | null
	/**
	 * Optional array with properties
	 */
	'optional array with properties'?: OptionalArrayWithPropertiesItem[] | null
	/**
	 * Optional boolean property
	 */
	'optional boolean'?: boolean | null
	/**
	 * Optional integer property
	 */
	'optional int'?: number | null
	/**
	 * Optional number property
	 */
	'optional number'?: number | null
	/**
	 * Optional object property
	 */
	'optional object'?: Record<string, any> | null
	/**
	 * Optional object with properties
	 */
	'optional object with properties'?: OptionalObjectWithProperties | null
	/**
	 * Optional string property
	 */
	'optional string'?: string | null
	/**
	 * Optional string property with a regex conditional
	 */
	'optional string with regex'?: string | null
}
export interface RequiredArrayWithPropertiesItem {
	/**
	 * Required any property
	 */
	'required any': any | null
	/**
	 * Required array property
	 */
	'required array': any[] | null
	/**
	 * Required boolean property
	 */
	'required boolean': boolean | null
	/**
	 * Required integer property
	 */
	'required int': number | null
	/**
	 * Required number property
	 */
	'required number': number | null
	/**
	 * Required object property
	 */
	'required object': Record<string, any> | null
	/**
	 * Required string property
	 */
	'required string': string | null
	/**
	 * Required string property with a regex conditional
	 */
	'required string with regex': string | null
}
export interface RequiredObjectWithProperties {
	/**
	 * Required any property
	 */
	'required any': any | null
	/**
	 * Required array property
	 */
	'required array': any[] | null
	/**
	 * Required boolean property
	 */
	'required boolean': boolean | null
	/**
	 * Required integer property
	 */
	'required int': number | null
	/**
	 * Required number property
	 */
	'required number': number | null
	/**
	 * Required object property
	 */
	'required object': Record<string, any> | null
	/**
	 * Required string property
	 */
	'required string': string | null
	/**
	 * Required string property with a regex conditional
	 */
	'required string with regex': string | null
}
export interface EveryNullableRequiredType {
	/**
	 * Required any property
	 */
	'required any': any | null
	/**
	 * Required array property
	 */
	'required array': any[] | null
	/**
	 * Required array with properties
	 */
	'required array with properties': RequiredArrayWithPropertiesItem[] | null
	/**
	 * Required boolean property
	 */
	'required boolean': boolean | null
	/**
	 * Required integer property
	 */
	'required int': number | null
	/**
	 * Required number property
	 */
	'required number': number | null
	/**
	 * Required object property
	 */
	'required object': Record<string, any> | null
	/**
	 * Required object with properties
	 */
	'required object with properties': RequiredObjectWithProperties | null
	/**
	 * Required string property
	 */
	'required string': string | null
	/**
	 * Required string property with a regex conditional
	 */
	'required string with regex': string | null
}
export interface OptionalArrayWithPropertiesItem1 {
	/**
	 * Optional any property
	 */
	'optional any'?: any | null
	/**
	 * Optional array property
	 */
	'optional array'?: any[]
	/**
	 * Optional boolean property
	 */
	'optional boolean'?: boolean
	/**
	 * Optional integer property
	 */
	'optional int'?: number
	/**
	 * Optional number property
	 */
	'optional number'?: number
	/**
	 * Optional object property
	 */
	'optional object'?: Record<string, any>
	/**
	 * Optional string property
	 */
	'optional string'?: string
	/**
	 * Optional string property with a regex conditional
	 */
	'optional string with regex'?: string
}
export interface OptionalObjectWithProperties1 {
	/**
	 * Optional any property
	 */
	'optional any'?: any | null
	/**
	 * Optional array property
	 */
	'optional array'?: any[]
	/**
	 * Optional boolean property
	 */
	'optional boolean'?: boolean
	/**
	 * Optional integer property
	 */
	'optional int'?: number
	/**
	 * Optional number property
	 */
	'optional number'?: number
	/**
	 * Optional object property
	 */
	'optional object'?: Record<string, any>
	/**
	 * Optional string property
	 */
	'optional string'?: string
	/**
	 * Optional string property with a regex conditional
	 */
	'optional string with regex'?: string
}
export interface EveryOptionalType {
	/**
	 * Optional any property
	 */
	'optional any'?: any | null
	/**
	 * Optional array property
	 */
	'optional array'?: any[]
	/**
	 * Optional array with properties
	 */
	'optional array with properties'?: OptionalArrayWithPropertiesItem1[]
	/**
	 * Optional boolean property
	 */
	'optional boolean'?: boolean
	/**
	 * Optional integer property
	 */
	'optional int'?: number
	/**
	 * Optional number property
	 */
	'optional number'?: number
	/**
	 * Optional object property
	 */
	'optional object'?: Record<string, any>
	/**
	 * Optional object with properties
	 */
	'optional object with properties'?: OptionalObjectWithProperties1
	/**
	 * Optional string property
	 */
	'optional string'?: string
	/**
	 * Optional string property with a regex conditional
	 */
	'optional string with regex'?: string
}
export interface RequiredArrayWithPropertiesItem1 {
	/**
	 * Required any property
	 */
	'required any': any | null
	/**
	 * Required array property
	 */
	'required array': any[]
	/**
	 * Required boolean property
	 */
	'required boolean': boolean
	/**
	 * Required integer property
	 */
	'required int': number
	/**
	 * Required number property
	 */
	'required number': number
	/**
	 * Required object property
	 */
	'required object': Record<string, any>
	/**
	 * Required string property
	 */
	'required string': string
	/**
	 * Required string property with a regex conditional
	 */
	'required string with regex': string
}
export interface RequiredObjectWithProperties1 {
	/**
	 * Required any property
	 */
	'required any': any | null
	/**
	 * Required array property
	 */
	'required array': any[]
	/**
	 * Required boolean property
	 */
	'required boolean': boolean
	/**
	 * Required integer property
	 */
	'required int': number
	/**
	 * Required number property
	 */
	'required number': number
	/**
	 * Required object property
	 */
	'required object': Record<string, any>
	/**
	 * Required string property
	 */
	'required string': string
	/**
	 * Required string property with a regex conditional
	 */
	'required string with regex': string
}
export interface EveryRequiredType {
	/**
	 * Required any property
	 */
	'required any': any | null
	/**
	 * Required array property
	 */
	'required array': any[]
	/**
	 * Required array with properties
	 */
	'required array with properties': RequiredArrayWithPropertiesItem1[]
	/**
	 * Required boolean property
	 */
	'required boolean': boolean
	/**
	 * Required integer property
	 */
	'required int': number
	/**
	 * Required number property
	 */
	'required number': number
	/**
	 * Required object property
	 */
	'required object': Record<string, any>
	/**
	 * Required object with properties
	 */
	'required object with properties': RequiredObjectWithProperties1
	/**
	 * Required string property
	 */
	'required string': string
	/**
	 * Required string property with a regex conditional
	 */
	'required string with regex': string
}
export interface LargeNumbersEvent {
	'large nullable optional integer'?: number | null
	'large nullable optional number'?: number | null
	'large nullable required integer': number | null
	'large nullable required number': number | null
	'large optional integer'?: number
	'large optional number'?: number
	'large required integer': number
	'large required number': number
}
export interface UniverseCharactersItemItem {
	/**
	 * The character's name.
	 */
	name: string
}
export interface NestedArrays {
	/**
	 * All known characters from each universe.
	 */
	universeCharacters: UniverseCharactersItemItem[][]
}
export interface SubterraneanLab {
	"jerry's memories"?: any[]
	"morty's memories"?: any[]
	"summer's contingency plan"?: string
}
export interface Tunnel {
	'subterranean lab': SubterraneanLab
}
export interface Garage {
	tunnel: Tunnel
}
export interface NestedObjects {
	garage: Garage
}
export interface PropertiesCollided {
	'Property Collided': string
	property_collided: string
}
export interface OccupantsItem {
	/**
	 * The name of this occupant.
	 */
	name: string
}
export interface Universe {
	/**
	 * The common name of this universe.
	 */
	name: string
	/**
	 * The most important occupants in this universe.
	 */
	occupants: OccupantsItem[]
}
export interface PropertyObjectNameCollision1 {
	universe?: Universe
}
export interface OccupantsItem1 {
	/**
	 * The name of this occupant.
	 */
	name: string
}
export interface Universe1 {
	/**
	 * The common name of this universe.
	 */
	name: string
	/**
	 * The most important occupants in this universe.
	 */
	occupants: OccupantsItem1[]
}
export interface PropertyObjectNameCollision2 {
	universe?: Universe1
}
export interface PropertySanitized {
	'0000---terrible-property-name~!3': string
}
export interface ObjectItem {
	name?: string
}
export interface SimpleArrayTypes {
	any?: any[]
	boolean?: boolean[]
	integer?: number[]
	nullable?: string[]
	number?: number[]
	object?: ObjectItem[]
	string?: string[]
}
export interface UnionType {
	universe_name: string | number | null
}

export type ViolationHandler = (
	message: Segment.TrackMessage<Record<string, any>>,
	violations: Ajv.ErrorObject[]
) => void

/**
 * The default handler that is fired if none is supplied with setTypewriterOptions.
 * If NODE_ENV="test", this handler will throw an error. Otherwise, it will log
 * a warning message to the console.
 */
export const defaultValidationErrorHandler: ViolationHandler = (
	message,
	violations
) => {
	const msg = JSON.stringify(
		{
			type: 'Typewriter JSON Schema Validation Error',
			description:
				`You made an analytics call (${
					message.event
				}) using Typewriter that doesn't match the ` + 'Tracking Plan spec.',
			errors: violations,
		},
		undefined,
		2
	)

	if (process.env.NODE_ENV === 'test') {
		throw new Error(msg)
	}
	console.warn(msg)
}

let onViolation = defaultValidationErrorHandler

const missingAnalyticsNodeError = new Error(`You must set an analytics-node instance:

>	const SegmentAnalytics = require('analytics-node')
>	const { setTypewriterOptions } = require('./analytics')
>
>	const analytics = new SegmentAnalytics('SEGMENT_WRITE_KEY')
>	setTypewriterOptions({
>		analytics: analytics,
>	})

For more information on analytics-node, see: https://segment.com/docs/sources/server/node/quickstart/
`)

let analytics: () => Segment.AnalyticsNode | undefined = () => {
	throw missingAnalyticsNodeError
}

/** Options to customize the runtime behavior of a Typewriter client. */
export interface TypewriterOptions {
	/**
	 * Underlying analytics instance where analytics calls are forwarded on to.
	 */
	analytics: Segment.AnalyticsNode
	/**
	 * Handler fired when if an event does not match its spec. This handler
	 * does not fire in production mode, because it requires inlining the full
	 * JSON Schema spec for each event in your Tracking Plan.
	 *
	 * By default, it will throw errors if NODE_ENV = "test" so that tests will fail
	 * if a message does not match the spec. Otherwise, errors will be logged to stderr.
	 */
	onViolation?: ViolationHandler
}

/**
 * Updates the run-time configuration of this Typewriter client.
 * This function must be called with a configured analytics-node instance before firing
 * any analytics calls, or else a `missingAnalyticsNodeError` error will be thrown.
 *
 * @param {TypewriterOptions} options - the options to upsert
 *
 * @typedef {Object} TypewriterOptions
 * @property {Segment.AnalyticsNode} analytics - Underlying analytics instance where analytics
 * 		calls are forwarded on to.
 * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
 * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
 * 		it will throw errors if NODE_ENV="test" so that tests will fail if a message does not match the spec. Otherwise, errors
 * 		will be logged to stderr.
 */
export function setTypewriterOptions(options: TypewriterOptions) {
	analytics = options.analytics ? () => options.analytics : analytics
	onViolation = options.onViolation || onViolation
}

/**
 * Validates a message against a JSON Schema using Ajv. If the message
 * is invalid, the `onViolation` handler will be called.
 */
function validateAgainstSchema(
	message: Segment.TrackMessage<Record<string, any>>,
	schema: object
) {
	const ajv = new Ajv({ schemaId: 'auto', allErrors: true, verbose: true })
	ajv.addMetaSchema(require('ajv/lib/refs/json-schema-draft-06.json'))
	ajv.addMetaSchema(require('ajv/lib/refs/json-schema-draft-04.json'))

	if (!ajv.validate(schema, message) && ajv.errors) {
		onViolation(message, ajv.errors)
	}
}

/**
 * Helper to attach metadata on Typewriter to outbound requests.
 * This is used for attribution and debugging by the Segment team.
 */
function withTypewriterContext<P, T extends Segment.TrackMessage<P>>(
	message: T
): T {
	return {
		...message,
		context: {
			...(message.context || {}),
			typewriter: {
				language: 'typescript',
				version: '7.1.0',
			},
		},
	}
}

/**
 * A message payload for an analytics-node `.track()` call.
 * See: https://segment.com/docs/spec/track/
 *
 * @typedef TrackMessage<PropertiesType>
 * @property {string | number} [userId] - The ID for this user in your database.
 * @property {string | number} [anonymousId] - An ID to associated with the user when you don’t know who they are.
 * @property {PropertiesType} [properties] - A dictionary of properties for the event.
 * @property {Date} [timestamp] - A Javascript date object representing when the track took place. If the track
 * 		just happened, leave it out and we’ll use the server’s time. If you’re importing data from the past make
 * 		sure you to send a timestamp.
 * @template PropertiesType
 */

/**
 * @typedef CustomViolationHandler
 * @property {string} regex property -
 */
/**
 * @typedef DefaultViolationHandler
 * @property {string} regex property -
 */
/**
 * @typedef OptionalArrayWithPropertiesItem
 * @property {any | null} [optional any] - Optional any property
 * @property {any[] | null} [optional array] - Optional array property
 * @property {boolean | null} [optional boolean] - Optional boolean property
 * @property {number | null} [optional int] - Optional integer property
 * @property {number | null} [optional number] - Optional number property
 * @property {Record<string, any> | null} [optional object] - Optional object property
 * @property {string | null} [optional string] - Optional string property
 * @property {string | null} [optional string with regex] - Optional string property with a regex conditional
 */
/**
 * @typedef OptionalObjectWithProperties
 * @property {any | null} [optional any] - Optional any property
 * @property {any[] | null} [optional array] - Optional array property
 * @property {boolean | null} [optional boolean] - Optional boolean property
 * @property {number | null} [optional int] - Optional integer property
 * @property {number | null} [optional number] - Optional number property
 * @property {Record<string, any> | null} [optional object] - Optional object property
 * @property {string | null} [optional string] - Optional string property
 * @property {string | null} [optional string with regex] - Optional string property with a regex conditional
 */
/**
 * @typedef EveryNullableOptionalType
 * @property {any | null} [optional any] - Optional any property
 * @property {any[] | null} [optional array] - Optional array property
 * @property {OptionalArrayWithPropertiesItem[] | null} [optional array with properties] - Optional array with properties
 * @property {boolean | null} [optional boolean] - Optional boolean property
 * @property {number | null} [optional int] - Optional integer property
 * @property {number | null} [optional number] - Optional number property
 * @property {Record<string, any> | null} [optional object] - Optional object property
 * @property {OptionalObjectWithProperties | null} [optional object with properties] - Optional object with properties
 * @property {string | null} [optional string] - Optional string property
 * @property {string | null} [optional string with regex] - Optional string property with a regex conditional
 */
/**
 * @typedef RequiredArrayWithPropertiesItem
 * @property {any | null} required any - Required any property
 * @property {any[] | null} required array - Required array property
 * @property {boolean | null} required boolean - Required boolean property
 * @property {number | null} required int - Required integer property
 * @property {number | null} required number - Required number property
 * @property {Record<string, any> | null} required object - Required object property
 * @property {string | null} required string - Required string property
 * @property {string | null} required string with regex - Required string property with a regex conditional
 */
/**
 * @typedef RequiredObjectWithProperties
 * @property {any | null} required any - Required any property
 * @property {any[] | null} required array - Required array property
 * @property {boolean | null} required boolean - Required boolean property
 * @property {number | null} required int - Required integer property
 * @property {number | null} required number - Required number property
 * @property {Record<string, any> | null} required object - Required object property
 * @property {string | null} required string - Required string property
 * @property {string | null} required string with regex - Required string property with a regex conditional
 */
/**
 * @typedef EveryNullableRequiredType
 * @property {any | null} required any - Required any property
 * @property {any[] | null} required array - Required array property
 * @property {RequiredArrayWithPropertiesItem[] | null} required array with properties - Required array with properties
 * @property {boolean | null} required boolean - Required boolean property
 * @property {number | null} required int - Required integer property
 * @property {number | null} required number - Required number property
 * @property {Record<string, any> | null} required object - Required object property
 * @property {RequiredObjectWithProperties | null} required object with properties - Required object with properties
 * @property {string | null} required string - Required string property
 * @property {string | null} required string with regex - Required string property with a regex conditional
 */
/**
 * @typedef OptionalArrayWithPropertiesItem1
 * @property {any | null} [optional any] - Optional any property
 * @property {any[]} [optional array] - Optional array property
 * @property {boolean} [optional boolean] - Optional boolean property
 * @property {number} [optional int] - Optional integer property
 * @property {number} [optional number] - Optional number property
 * @property {Record<string, any>} [optional object] - Optional object property
 * @property {string} [optional string] - Optional string property
 * @property {string} [optional string with regex] - Optional string property with a regex conditional
 */
/**
 * @typedef OptionalObjectWithProperties1
 * @property {any | null} [optional any] - Optional any property
 * @property {any[]} [optional array] - Optional array property
 * @property {boolean} [optional boolean] - Optional boolean property
 * @property {number} [optional int] - Optional integer property
 * @property {number} [optional number] - Optional number property
 * @property {Record<string, any>} [optional object] - Optional object property
 * @property {string} [optional string] - Optional string property
 * @property {string} [optional string with regex] - Optional string property with a regex conditional
 */
/**
 * @typedef EveryOptionalType
 * @property {any | null} [optional any] - Optional any property
 * @property {any[]} [optional array] - Optional array property
 * @property {OptionalArrayWithPropertiesItem1[]} [optional array with properties] - Optional array with properties
 * @property {boolean} [optional boolean] - Optional boolean property
 * @property {number} [optional int] - Optional integer property
 * @property {number} [optional number] - Optional number property
 * @property {Record<string, any>} [optional object] - Optional object property
 * @property {OptionalObjectWithProperties1} [optional object with properties] - Optional object with properties
 * @property {string} [optional string] - Optional string property
 * @property {string} [optional string with regex] - Optional string property with a regex conditional
 */
/**
 * @typedef RequiredArrayWithPropertiesItem1
 * @property {any | null} required any - Required any property
 * @property {any[]} required array - Required array property
 * @property {boolean} required boolean - Required boolean property
 * @property {number} required int - Required integer property
 * @property {number} required number - Required number property
 * @property {Record<string, any>} required object - Required object property
 * @property {string} required string - Required string property
 * @property {string} required string with regex - Required string property with a regex conditional
 */
/**
 * @typedef RequiredObjectWithProperties1
 * @property {any | null} required any - Required any property
 * @property {any[]} required array - Required array property
 * @property {boolean} required boolean - Required boolean property
 * @property {number} required int - Required integer property
 * @property {number} required number - Required number property
 * @property {Record<string, any>} required object - Required object property
 * @property {string} required string - Required string property
 * @property {string} required string with regex - Required string property with a regex conditional
 */
/**
 * @typedef EveryRequiredType
 * @property {any | null} required any - Required any property
 * @property {any[]} required array - Required array property
 * @property {RequiredArrayWithPropertiesItem1[]} required array with properties - Required array with properties
 * @property {boolean} required boolean - Required boolean property
 * @property {number} required int - Required integer property
 * @property {number} required number - Required number property
 * @property {Record<string, any>} required object - Required object property
 * @property {RequiredObjectWithProperties1} required object with properties - Required object with properties
 * @property {string} required string - Required string property
 * @property {string} required string with regex - Required string property with a regex conditional
 */
/**
 * @typedef LargeNumbersEvent
 * @property {number | null} [large nullable optional integer] -
 * @property {number | null} [large nullable optional number] -
 * @property {number | null} large nullable required integer -
 * @property {number | null} large nullable required number -
 * @property {number} [large optional integer] -
 * @property {number} [large optional number] -
 * @property {number} large required integer -
 * @property {number} large required number -
 */
/**
 * @typedef UniverseCharactersItemItem
 * @property {string} name - The character's name.
 */
/**
 * @typedef NestedArrays
 * @property {UniverseCharactersItemItem[][]} universeCharacters - All known characters from each universe.
 */
/**
 * @typedef SubterraneanLab
 * @property {any[]} [jerry\'s memories] -
 * @property {any[]} [morty\'s memories] -
 * @property {string} [summer\'s contingency plan] -
 */
/**
 * @typedef Tunnel
 * @property {SubterraneanLab} subterranean lab -
 */
/**
 * @typedef Garage
 * @property {Tunnel} tunnel -
 */
/**
 * @typedef NestedObjects
 * @property {Garage} garage -
 */
/**
 * @typedef PropertiesCollided
 * @property {string} Property Collided -
 * @property {string} property_collided -
 */
/**
 * @typedef OccupantsItem
 * @property {string} name - The name of this occupant.
 */
/**
 * @typedef Universe
 * @property {string} name - The common name of this universe.
 * @property {OccupantsItem[]} occupants - The most important occupants in this universe.
 */
/**
 * @typedef PropertyObjectNameCollision1
 * @property {Universe} [universe] -
 */
/**
 * @typedef OccupantsItem1
 * @property {string} name - The name of this occupant.
 */
/**
 * @typedef Universe1
 * @property {string} name - The common name of this universe.
 * @property {OccupantsItem1[]} occupants - The most important occupants in this universe.
 */
/**
 * @typedef PropertyObjectNameCollision2
 * @property {Universe1} [universe] -
 */
/**
 * @typedef PropertySanitized
 * @property {string} 0000---terrible-property-name~!3 -
 */
/**
 * @typedef ObjectItem
 * @property {string} [name] -
 */
/**
 * @typedef SimpleArrayTypes
 * @property {any[]} [any] -
 * @property {boolean[]} [boolean] -
 * @property {number[]} [integer] -
 * @property {string[]} [nullable] -
 * @property {number[]} [number] -
 * @property {ObjectItem[]} [object] -
 * @property {string[]} [string] -
 */
/**
 * @typedef UnionType
 * @property {string | number | null} universe_name -
 */

/**
 * Validates that clients properly sanitize event names.
 *
 * @param {TrackMessage<Record<string, any>>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function I42TerribleEventName3(
	message: Segment.TrackMessage<Record<string, any>>,
	callback?: Segment.Callback
): void {
	const msg = withTypewriterContext({
		properties: {},
		...message,
		event: '42_--terrible==\\"event\'++name~!3',
	})

	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'Validates that clients properly sanitize event names.',
		labels: {},
		properties: {
			context: {},
			properties: {
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		title: '42_--terrible==\\"event\'++name~!3',
		type: 'object',
	}
	validateAgainstSchema(msg, schema)

	const a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
/**
 * Fired before an analytics instance has been set, which should throw an error.
 *
 * @param {TrackMessage<Record<string, any>>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function analyticsInstanceMissing(
	message: Segment.TrackMessage<Record<string, any>>,
	callback?: Segment.Callback
): void {
	const msg = withTypewriterContext({
		properties: {},
		...message,
		event: 'Analytics Instance Missing',
	})

	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Fired before an analytics instance has been set, which should throw an error.',
		labels: {},
		properties: {
			context: {},
			properties: {
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		title: 'Analytics Instance Missing',
		type: 'object',
	}
	validateAgainstSchema(msg, schema)

	const a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
/**
 * Fired after a client throws an "Analytics Instance Missing" error to mark the test as successful.
 *
 * @param {TrackMessage<Record<string, any>>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function analyticsInstanceMissingThrewError(
	message: Segment.TrackMessage<Record<string, any>>,
	callback?: Segment.Callback
): void {
	const msg = withTypewriterContext({
		properties: {},
		...message,
		event: 'Analytics Instance Missing Threw Error',
	})

	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Fired after a client throws an "Analytics Instance Missing" error to mark the test as successful.',
		labels: {},
		properties: {
			context: {},
			properties: {
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		title: 'Analytics Instance Missing Threw Error',
		type: 'object',
	}
	validateAgainstSchema(msg, schema)

	const a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
/**
 * This event is fired in order to trigger a custom violation handler. It should be called with a JSON Schema violation.
 *
 * @param {TrackMessage<CustomViolationHandler>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function customViolationHandler(
	message: Segment.TrackMessage<CustomViolationHandler>,
	callback?: Segment.Callback
): void {
	const msg = withTypewriterContext({
		properties: {},
		...message,
		event: 'Custom Violation Handler',
	})

	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'This event is fired in order to trigger a custom violation handler. It should be called with a JSON Schema violation.',
		labels: {},
		properties: {
			context: {},
			properties: {
				properties: {
					'regex property': {
						description: '',
						pattern: 'Lawyer Morty|Evil Morty',
						type: 'string',
					},
				},
				required: ['regex property'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Custom Violation Handler',
		type: 'object',
	}
	validateAgainstSchema(msg, schema)

	const a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
/**
 * This event should be fired if a custom violation handler is correctly called due to a call to `Custom Violation Handler` with a violation.
 *
 * @param {TrackMessage<Record<string, any>>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function customViolationHandlerCalled(
	message: Segment.TrackMessage<Record<string, any>>,
	callback?: Segment.Callback
): void {
	const msg = withTypewriterContext({
		properties: {},
		...message,
		event: 'Custom Violation Handler Called',
	})

	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'This event should be fired if a custom violation handler is correctly called due to a call to `Custom Violation Handler` with a violation.',
		labels: {},
		properties: {
			context: {},
			properties: {
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		title: 'Custom Violation Handler Called',
		type: 'object',
	}
	validateAgainstSchema(msg, schema)

	const a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
/**
 * This event is fired in order to trigger the default violation handler. It should be called with a JSON Schema violation.
 *
 * @param {TrackMessage<DefaultViolationHandler>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function defaultViolationHandler(
	message: Segment.TrackMessage<DefaultViolationHandler>,
	callback?: Segment.Callback
): void {
	const msg = withTypewriterContext({
		properties: {},
		...message,
		event: 'Default Violation Handler',
	})

	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'This event is fired in order to trigger the default violation handler. It should be called with a JSON Schema violation.',
		labels: {},
		properties: {
			context: {},
			properties: {
				properties: {
					'regex property': {
						description: '',
						pattern: 'Lawyer Morty|Evil Morty',
						type: 'string',
					},
				},
				required: ['regex property'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Default Violation Handler',
		type: 'object',
	}
	validateAgainstSchema(msg, schema)

	const a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
/**
 * This event should be fired if the default violation handler is correctly called due to a call to `Default Violation Handler` with a violation.
 *
 * @param {TrackMessage<Record<string, any>>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function defaultViolationHandlerCalled(
	message: Segment.TrackMessage<Record<string, any>>,
	callback?: Segment.Callback
): void {
	const msg = withTypewriterContext({
		properties: {},
		...message,
		event: 'Default Violation Handler Called',
	})

	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'This event should be fired if the default violation handler is correctly called due to a call to `Default Violation Handler` with a violation.',
		labels: {},
		properties: {
			context: {},
			properties: {
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		title: 'Default Violation Handler Called',
		type: 'object',
	}
	validateAgainstSchema(msg, schema)

	const a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
/**
 * Validates that a generated client supports events with no explicit properties. It is expected that this event accepts ANY properties.
 *
 * @param {TrackMessage<Record<string, any>>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function emptyEvent(
	message: Segment.TrackMessage<Record<string, any>>,
	callback?: Segment.Callback
): void {
	const msg = withTypewriterContext({
		properties: {},
		...message,
		event: 'Empty Event',
	})

	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Validates that a generated client supports events with no explicit properties. It is expected that this event accepts ANY properties.',
		labels: {},
		properties: {
			context: {},
			properties: {
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		title: 'Empty Event',
		type: 'object',
	}
	validateAgainstSchema(msg, schema)

	const a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
/**
 * Validates that a generated client handles even naming collisions.
 *
 * @param {TrackMessage<Record<string, any>>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function eventCollided(
	message: Segment.TrackMessage<Record<string, any>>,
	callback?: Segment.Callback
): void {
	const msg = withTypewriterContext({
		properties: {},
		...message,
		event: 'Event Collided',
	})

	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Validates that a generated client handles even naming collisions.',
		labels: {},
		properties: {
			context: {},
			properties: {
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		title: 'Event Collided',
		type: 'object',
	}
	validateAgainstSchema(msg, schema)

	const a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
/**
 * Validates that clients handle all of the supported field types, as nullable optional fields. If a field is null, it is expected to be NOT sent through.
 *
 * @param {TrackMessage<EveryNullableOptionalType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function everyNullableOptionalType(
	message: Segment.TrackMessage<EveryNullableOptionalType>,
	callback?: Segment.Callback
): void {
	const msg = withTypewriterContext({
		properties: {},
		...message,
		event: 'Every Nullable Optional Type',
	})

	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Validates that clients handle all of the supported field types, as nullable optional fields. If a field is null, it is expected to be NOT sent through.',
		properties: {
			context: {},
			properties: {
				properties: {
					'optional any': {
						description: 'Optional any property',
					},
					'optional array': {
						description: 'Optional array property',
						type: ['array', 'null'],
					},
					'optional array with properties': {
						description: 'Optional array with properties',
						items: {
							properties: {
								'optional any': {
									description: 'Optional any property',
								},
								'optional array': {
									description: 'Optional array property',
									type: ['array', 'null'],
								},
								'optional boolean': {
									description: 'Optional boolean property',
									type: ['boolean', 'null'],
								},
								'optional int': {
									description: 'Optional integer property',
									type: ['integer', 'null'],
								},
								'optional number': {
									description: 'Optional number property',
									type: ['number', 'null'],
								},
								'optional object': {
									description: 'Optional object property',
									properties: {},
									required: [],
									type: ['object', 'null'],
								},
								'optional string': {
									description: 'Optional string property',
									type: ['string', 'null'],
								},
								'optional string with regex': {
									description:
										'Optional string property with a regex conditional',
									pattern: 'Evil Morty|Lawyer Morty',
									type: ['string', 'null'],
								},
							},
							type: ['object', 'null'],
						},
						type: ['array', 'null'],
					},
					'optional boolean': {
						description: 'Optional boolean property',
						type: ['boolean', 'null'],
					},
					'optional int': {
						description: 'Optional integer property',
						type: ['integer', 'null'],
					},
					'optional number': {
						description: 'Optional number property',
						type: ['number', 'null'],
					},
					'optional object': {
						description: 'Optional object property',
						properties: {},
						required: [],
						type: ['object', 'null'],
					},
					'optional object with properties': {
						description: 'Optional object with properties',
						properties: {
							'optional any': {
								description: 'Optional any property',
							},
							'optional array': {
								description: 'Optional array property',
								type: ['array', 'null'],
							},
							'optional boolean': {
								description: 'Optional boolean property',
								type: ['boolean', 'null'],
							},
							'optional int': {
								description: 'Optional integer property',
								type: ['integer', 'null'],
							},
							'optional number': {
								description: 'Optional number property',
								type: ['number', 'null'],
							},
							'optional object': {
								description: 'Optional object property',
								properties: {},
								required: [],
								type: ['object', 'null'],
							},
							'optional string': {
								description: 'Optional string property',
								type: ['string', 'null'],
							},
							'optional string with regex': {
								description:
									'Optional string property with a regex conditional',
								pattern: 'Evil Morty|Lawyer Morty',
								type: ['string', 'null'],
							},
						},
						required: [],
						type: ['object', 'null'],
					},
					'optional string': {
						description: 'Optional string property',
						type: ['string', 'null'],
					},
					'optional string with regex': {
						description: 'Optional string property with a regex conditional',
						pattern: 'Evil Morty|Lawyer Morty',
						type: ['string', 'null'],
					},
				},
				type: 'object',
			},
			traits: {},
		},
		title: 'Every Nullable Optional Type',
		type: 'object',
	}
	validateAgainstSchema(msg, schema)

	const a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
/**
 * Validates that clients handle all of the supported field types, as nullable required fields. If a field is null, it is expected to be sent through.
 *
 * @param {TrackMessage<EveryNullableRequiredType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function everyNullableRequiredType(
	message: Segment.TrackMessage<EveryNullableRequiredType>,
	callback?: Segment.Callback
): void {
	const msg = withTypewriterContext({
		properties: {},
		...message,
		event: 'Every Nullable Required Type',
	})

	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Validates that clients handle all of the supported field types, as nullable required fields. If a field is null, it is expected to be sent through.',
		properties: {
			context: {},
			properties: {
				properties: {
					'required any': {
						description: 'Required any property',
					},
					'required array': {
						description: 'Required array property',
						type: ['array', 'null'],
					},
					'required array with properties': {
						description: 'Required array with properties',
						items: {
							properties: {
								'required any': {
									description: 'Required any property',
								},
								'required array': {
									description: 'Required array property',
									type: ['array', 'null'],
								},
								'required boolean': {
									description: 'Required boolean property',
									type: ['boolean', 'null'],
								},
								'required int': {
									description: 'Required integer property',
									type: ['integer', 'null'],
								},
								'required number': {
									description: 'Required number property',
									type: ['number', 'null'],
								},
								'required object': {
									description: 'Required object property',
									properties: {},
									required: [],
									type: ['object', 'null'],
								},
								'required string': {
									description: 'Required string property',
									type: ['string', 'null'],
								},
								'required string with regex': {
									description:
										'Required string property with a regex conditional',
									pattern: 'Evil Morty|Lawyer Morty',
									type: ['string', 'null'],
								},
							},
							required: [
								'required any',
								'required array',
								'required boolean',
								'required int',
								'required number',
								'required object',
								'required string',
								'required string with regex',
							],
							type: ['object', 'null'],
						},
						type: ['array', 'null'],
					},
					'required boolean': {
						description: 'Required boolean property',
						type: ['boolean', 'null'],
					},
					'required int': {
						description: 'Required integer property',
						type: ['integer', 'null'],
					},
					'required number': {
						description: 'Required number property',
						type: ['number', 'null'],
					},
					'required object': {
						description: 'Required object property',
						properties: {},
						required: [],
						type: ['object', 'null'],
					},
					'required object with properties': {
						description: 'Required object with properties',
						properties: {
							'required any': {
								description: 'Required any property',
							},
							'required array': {
								description: 'Required array property',
								type: ['array', 'null'],
							},
							'required boolean': {
								description: 'Required boolean property',
								type: ['boolean', 'null'],
							},
							'required int': {
								description: 'Required integer property',
								type: ['integer', 'null'],
							},
							'required number': {
								description: 'Required number property',
								type: ['number', 'null'],
							},
							'required object': {
								description: 'Required object property',
								properties: {},
								required: [],
								type: ['object', 'null'],
							},
							'required string': {
								description: 'Required string property',
								type: ['string', 'null'],
							},
							'required string with regex': {
								description:
									'Required string property with a regex conditional',
								pattern: 'Evil Morty|Lawyer Morty',
								type: ['string', 'null'],
							},
						},
						required: [
							'required any',
							'required array',
							'required boolean',
							'required int',
							'required number',
							'required object',
							'required string',
							'required string with regex',
						],
						type: ['object', 'null'],
					},
					'required string': {
						description: 'Required string property',
						type: ['string', 'null'],
					},
					'required string with regex': {
						description: 'Required string property with a regex conditional',
						pattern: 'Evil Morty|Lawyer Morty',
						type: ['string', 'null'],
					},
				},
				required: [
					'required any',
					'required array',
					'required boolean',
					'required int',
					'required number',
					'required object',
					'required string',
					'required string with regex',
					'required object with properties',
					'required array with properties',
				],
				type: 'object',
			},
			traits: {},
		},
		required: ['properties'],
		title: 'Every Nullable Required Type',
		type: 'object',
	}
	validateAgainstSchema(msg, schema)

	const a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
/**
 * Validates that clients handle all of the supported field types, as optional fields.
 *
 * @param {TrackMessage<EveryOptionalType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function everyOptionalType(
	message: Segment.TrackMessage<EveryOptionalType>,
	callback?: Segment.Callback
): void {
	const msg = withTypewriterContext({
		properties: {},
		...message,
		event: 'Every Optional Type',
	})

	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Validates that clients handle all of the supported field types, as optional fields.',
		properties: {
			context: {},
			properties: {
				properties: {
					'optional any': {
						description: 'Optional any property',
					},
					'optional array': {
						description: 'Optional array property',
						type: 'array',
					},
					'optional array with properties': {
						description: 'Optional array with properties',
						items: {
							properties: {
								'optional any': {
									description: 'Optional any property',
								},
								'optional array': {
									description: 'Optional array property',
									type: 'array',
								},
								'optional boolean': {
									description: 'Optional boolean property',
									type: 'boolean',
								},
								'optional int': {
									description: 'Optional integer property',
									type: 'integer',
								},
								'optional number': {
									description: 'Optional number property',
									type: 'number',
								},
								'optional object': {
									description: 'Optional object property',
									key: 'optional object',
									properties: {},
									type: 'object',
								},
								'optional string': {
									description: 'Optional string property',
									type: 'string',
								},
								'optional string with regex': {
									description:
										'Optional string property with a regex conditional',
									pattern: 'Evil Morty|Lawyer Morty',
									type: 'string',
								},
							},
							type: 'object',
						},
						type: 'array',
					},
					'optional boolean': {
						description: 'Optional boolean property',
						type: 'boolean',
					},
					'optional int': {
						description: 'Optional integer property',
						type: 'integer',
					},
					'optional number': {
						description: 'Optional number property',
						type: 'number',
					},
					'optional object': {
						description: 'Optional object property',
						key: 'optional object',
						properties: {},
						type: 'object',
					},
					'optional object with properties': {
						description: 'Optional object with properties',
						properties: {
							'optional any': {
								description: 'Optional any property',
							},
							'optional array': {
								description: 'Optional array property',
								type: 'array',
							},
							'optional boolean': {
								description: 'Optional boolean property',
								type: 'boolean',
							},
							'optional int': {
								description: 'Optional integer property',
								type: 'integer',
							},
							'optional number': {
								description: 'Optional number property',
								type: 'number',
							},
							'optional object': {
								description: 'Optional object property',
								key: 'optional object',
								properties: {},
								type: 'object',
							},
							'optional string': {
								description: 'Optional string property',
								type: 'string',
							},
							'optional string with regex': {
								description:
									'Optional string property with a regex conditional',
								pattern: 'Evil Morty|Lawyer Morty',
								type: 'string',
							},
						},
						type: 'object',
					},
					'optional string': {
						description: 'Optional string property',
						type: 'string',
					},
					'optional string with regex': {
						description: 'Optional string property with a regex conditional',
						pattern: 'Evil Morty|Lawyer Morty',
						type: 'string',
					},
				},
				type: 'object',
			},
			traits: {},
		},
		title: 'Every Optional Type',
		type: 'object',
	}
	validateAgainstSchema(msg, schema)

	const a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
/**
 * Validates that clients handle all of the supported field types, as required fields.
 *
 * @param {TrackMessage<EveryRequiredType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function everyRequiredType(
	message: Segment.TrackMessage<EveryRequiredType>,
	callback?: Segment.Callback
): void {
	const msg = withTypewriterContext({
		properties: {},
		...message,
		event: 'Every Required Type',
	})

	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Validates that clients handle all of the supported field types, as required fields. ',
		properties: {
			context: {},
			properties: {
				properties: {
					'required any': {
						description: 'Required any property',
					},
					'required array': {
						description: 'Required array property',
						type: 'array',
					},
					'required array with properties': {
						description: 'Required array with properties',
						items: {
							properties: {
								'required any': {
									description: 'Required any property',
								},
								'required array': {
									description: 'Required array property',
									type: 'array',
								},
								'required boolean': {
									description: 'Required boolean property',
									type: 'boolean',
								},
								'required int': {
									description: 'Required integer property',
									type: 'integer',
								},
								'required number': {
									description: 'Required number property',
									type: 'number',
								},
								'required object': {
									description: 'Required object property',
									key: 'required object',
									properties: {},
									required: [],
									type: 'object',
								},
								'required string': {
									description: 'Required string property',
									type: 'string',
								},
								'required string with regex': {
									description:
										'Required string property with a regex conditional',
									pattern: 'Evil Morty|Lawyer Morty',
									type: 'string',
								},
							},
							required: [
								'required any',
								'required array',
								'required boolean',
								'required int',
								'required number',
								'required object',
								'required string',
								'required string with regex',
							],
							type: 'object',
						},
						type: 'array',
					},
					'required boolean': {
						description: 'Required boolean property',
						type: 'boolean',
					},
					'required int': {
						description: 'Required integer property',
						type: 'integer',
					},
					'required number': {
						description: 'Required number property',
						type: 'number',
					},
					'required object': {
						description: 'Required object property',
						key: 'required object',
						properties: {},
						required: [],
						type: 'object',
					},
					'required object with properties': {
						description: 'Required object with properties',
						properties: {
							'required any': {
								description: 'Required any property',
							},
							'required array': {
								description: 'Required array property',
								type: 'array',
							},
							'required boolean': {
								description: 'Required boolean property',
								type: 'boolean',
							},
							'required int': {
								description: 'Required integer property',
								type: 'integer',
							},
							'required number': {
								description: 'Required number property',
								type: 'number',
							},
							'required object': {
								description: 'Required object property',
								key: 'required object',
								properties: {},
								required: [],
								type: 'object',
							},
							'required string': {
								description: 'Required string property',
								type: 'string',
							},
							'required string with regex': {
								description:
									'Required string property with a regex conditional',
								pattern: 'Evil Morty|Lawyer Morty',
								type: 'string',
							},
						},
						required: [
							'required any',
							'required array',
							'required boolean',
							'required int',
							'required number',
							'required object',
							'required string',
							'required string with regex',
						],
						type: 'object',
					},
					'required string': {
						description: 'Required string property',
						type: 'string',
					},
					'required string with regex': {
						description: 'Required string property with a regex conditional',
						pattern: 'Evil Morty|Lawyer Morty',
						type: 'string',
					},
				},
				required: [
					'required any',
					'required array',
					'required boolean',
					'required int',
					'required number',
					'required object',
					'required string',
					'required string with regex',
					'required object with properties',
					'required array with properties',
				],
				type: 'object',
			},
			traits: {},
		},
		required: ['properties'],
		title: 'Every Required Type',
		type: 'object',
	}
	validateAgainstSchema(msg, schema)

	const a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
/**
 * Validates that clients correctly serialize large numbers (integers and floats).
 *
 * @param {TrackMessage<LargeNumbersEvent>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function largeNumbersEvent(
	message: Segment.TrackMessage<LargeNumbersEvent>,
	callback?: Segment.Callback
): void {
	const msg = withTypewriterContext({
		properties: {},
		...message,
		event: 'Large Numbers Event',
	})

	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Validates that clients correctly serialize large numbers (integers and floats).',
		labels: {},
		properties: {
			context: {},
			properties: {
				properties: {
					'large nullable optional integer': {
						description: '',
						type: ['integer', 'null'],
					},
					'large nullable optional number': {
						description: '',
						type: ['number', 'null'],
					},
					'large nullable required integer': {
						description: '',
						type: ['integer', 'null'],
					},
					'large nullable required number': {
						description: '',
						type: ['number', 'null'],
					},
					'large optional integer': {
						description: '',
						type: 'integer',
					},
					'large optional number': {
						description: '',
						type: 'number',
					},
					'large required integer': {
						description: '',
						type: 'integer',
					},
					'large required number': {
						description: '',
						type: 'number',
					},
				},
				required: [
					'large required integer',
					'large required number',
					'large nullable required integer',
					'large nullable required number',
				],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Large Numbers Event',
		type: 'object',
	}
	validateAgainstSchema(msg, schema)

	const a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
/**
 * Validates that clients handle arrays-within-arrays.
 *
 * @param {TrackMessage<NestedArrays>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function nestedArrays(
	message: Segment.TrackMessage<NestedArrays>,
	callback?: Segment.Callback
): void {
	const msg = withTypewriterContext({
		properties: {},
		...message,
		event: 'Nested Arrays',
	})

	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'Validates that clients handle arrays-within-arrays.',
		labels: {},
		properties: {
			context: {},
			properties: {
				properties: {
					universeCharacters: {
						description: 'All known characters from each universe.',
						items: {
							description: '',
							items: {
								description: '',
								properties: {
									name: {
										description: "The character's name.",
										type: 'string',
									},
								},
								required: ['name'],
								type: 'object',
							},
							type: 'array',
						},
						type: 'array',
					},
				},
				required: ['universeCharacters'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Nested Arrays',
		type: 'object',
	}
	validateAgainstSchema(msg, schema)

	const a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
/**
 * Validates that clients handle objects-within-objects.
 *
 * @param {TrackMessage<NestedObjects>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function nestedObjects(
	message: Segment.TrackMessage<NestedObjects>,
	callback?: Segment.Callback
): void {
	const msg = withTypewriterContext({
		properties: {},
		...message,
		event: 'Nested Objects',
	})

	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description: 'Validates that clients handle objects-within-objects.',
		labels: {},
		properties: {
			context: {},
			properties: {
				properties: {
					garage: {
						description: '',
						properties: {
							tunnel: {
								description: '',
								properties: {
									'subterranean lab': {
										description: '',
										properties: {
											"jerry's memories": {
												description: '',
												type: 'array',
											},
											"morty's memories": {
												description: '',
												type: 'array',
											},
											"summer's contingency plan": {
												description: '',
												type: 'string',
											},
										},
										required: [],
										type: 'object',
									},
								},
								required: ['subterranean lab'],
								type: 'object',
							},
						},
						required: ['tunnel'],
						type: 'object',
					},
				},
				required: ['garage'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Nested Objects',
		type: 'object',
	}
	validateAgainstSchema(msg, schema)

	const a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
/**
 * Validates that clients handle collisions in property names within a single event.
 *
 * @param {TrackMessage<PropertiesCollided>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function propertiesCollided(
	message: Segment.TrackMessage<PropertiesCollided>,
	callback?: Segment.Callback
): void {
	const msg = withTypewriterContext({
		properties: {},
		...message,
		event: 'Properties Collided',
	})

	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Validates that clients handle collisions in property names within a single event.',
		labels: {},
		properties: {
			context: {},
			properties: {
				properties: {
					'Property Collided': {
						description: '',
						type: 'string',
					},
					property_collided: {
						description: '',
						type: 'string',
					},
				},
				required: ['property_collided', 'Property Collided'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Properties Collided',
		type: 'object',
	}
	validateAgainstSchema(msg, schema)

	const a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
/**
 * Validates that clients handle collisions in object names across multiple events.
 *
 * @param {TrackMessage<PropertyObjectNameCollision1>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function propertyObjectNameCollision1(
	message: Segment.TrackMessage<PropertyObjectNameCollision1>,
	callback?: Segment.Callback
): void {
	const msg = withTypewriterContext({
		properties: {},
		...message,
		event: 'Property Object Name Collision #1',
	})

	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Validates that clients handle collisions in object names across multiple events.',
		labels: {},
		properties: {
			context: {},
			properties: {
				properties: {
					universe: {
						description: '',
						properties: {
							name: {
								description: 'The common name of this universe.',
								type: 'string',
							},
							occupants: {
								description: 'The most important occupants in this universe.',
								items: {
									description: '',
									properties: {
										name: {
											description: 'The name of this occupant.',
											type: 'string',
										},
									},
									required: ['name'],
									type: 'object',
								},
								type: 'array',
							},
						},
						required: ['name', 'occupants'],
						type: 'object',
					},
				},
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		title: 'Property Object Name Collision #1',
		type: 'object',
	}
	validateAgainstSchema(msg, schema)

	const a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
/**
 * Validates that clients handle collisions in object names across multiple events.
 *
 * @param {TrackMessage<PropertyObjectNameCollision2>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function propertyObjectNameCollision2(
	message: Segment.TrackMessage<PropertyObjectNameCollision2>,
	callback?: Segment.Callback
): void {
	const msg = withTypewriterContext({
		properties: {},
		...message,
		event: 'Property Object Name Collision #2',
	})

	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Validates that clients handle collisions in object names across multiple events.',
		labels: {},
		properties: {
			context: {},
			properties: {
				properties: {
					universe: {
						description: '',
						properties: {
							name: {
								description: 'The common name of this universe.',
								type: 'string',
							},
							occupants: {
								description: 'The most important occupants in this universe.',
								items: {
									description: '',
									properties: {
										name: {
											description: 'The name of this occupant.',
											type: 'string',
										},
									},
									required: ['name'],
									type: 'object',
								},
								type: 'array',
							},
						},
						required: ['name', 'occupants'],
						type: 'object',
					},
				},
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		title: 'Property Object Name Collision #2',
		type: 'object',
	}
	validateAgainstSchema(msg, schema)

	const a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
/**
 * Validates that clients sanitize property names that contain invalid identifier characters.
 *
 * @param {TrackMessage<PropertySanitized>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function propertySanitized(
	message: Segment.TrackMessage<PropertySanitized>,
	callback?: Segment.Callback
): void {
	const msg = withTypewriterContext({
		properties: {},
		...message,
		event: 'Property Sanitized',
	})

	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Validates that clients sanitize property names that contain invalid identifier characters.',
		labels: {},
		properties: {
			context: {},
			properties: {
				properties: {
					'0000---terrible-property-name~!3': {
						description: '',
						type: 'string',
					},
				},
				required: ['0000---terrible-property-name~!3'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Property Sanitized',
		type: 'object',
	}
	validateAgainstSchema(msg, schema)

	const a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
/**
 * Validates that clients support fields with various types of arrays.
 *
 * @param {TrackMessage<SimpleArrayTypes>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function simpleArrayTypes(
	message: Segment.TrackMessage<SimpleArrayTypes>,
	callback?: Segment.Callback
): void {
	const msg = withTypewriterContext({
		properties: {},
		...message,
		event: 'Simple Array Types',
	})

	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Validates that clients support fields with various types of arrays.',
		labels: {},
		properties: {
			context: {},
			properties: {
				properties: {
					any: {
						description: '',
						items: {
							description: '',
						},
						type: 'array',
					},
					boolean: {
						description: '',
						items: {
							description: '',
							type: 'boolean',
						},
						type: 'array',
					},
					integer: {
						description: '',
						items: {
							description: '',
							type: 'integer',
						},
						type: 'array',
					},
					nullable: {
						description: '',
						items: {
							description: '',
							type: ['string', 'null'],
						},
						type: 'array',
					},
					number: {
						description: '',
						items: {
							description: '',
							type: 'number',
						},
						type: 'array',
					},
					object: {
						description: '',
						items: {
							description: '',
							properties: {
								name: {
									description: '',
									type: 'string',
								},
							},
							required: [],
							type: 'object',
						},
						type: 'array',
					},
					string: {
						description: '',
						items: {
							description: '',
							type: 'string',
						},
						type: 'array',
					},
				},
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		title: 'Simple Array Types',
		type: 'object',
	}
	validateAgainstSchema(msg, schema)

	const a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
/**
 * Validates that clients support fields with multiple (union) types.
 *
 * @param {TrackMessage<UnionType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function unionType(
	message: Segment.TrackMessage<UnionType>,
	callback?: Segment.Callback
): void {
	const msg = withTypewriterContext({
		properties: {},
		...message,
		event: 'Union Type',
	})

	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Validates that clients support fields with multiple (union) types.',
		labels: {},
		properties: {
			context: {},
			properties: {
				properties: {
					universe_name: {
						description: '',
						type: ['string', 'null', 'integer'],
					},
				},
				required: ['universe_name'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		title: 'Union Type',
		type: 'object',
	}
	validateAgainstSchema(msg, schema)

	const a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
/**
 * Validates that a generated client handles even naming collisions.
 *
 * @param {TrackMessage<Record<string, any>>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function eventCollided1(
	message: Segment.TrackMessage<Record<string, any>>,
	callback?: Segment.Callback
): void {
	const msg = withTypewriterContext({
		properties: {},
		...message,
		event: 'event_collided',
	})

	const schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		description:
			'Validates that a generated client handles even naming collisions.',
		labels: {},
		properties: {
			context: {},
			properties: {
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		title: 'event_collided',
		type: 'object',
	}
	validateAgainstSchema(msg, schema)

	const a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}

const clientAPI = {
	/**
	 * Updates the run-time configuration of this Typewriter client.
	 * This function must be called with a configured analytics-node instance before firing
	 * any analytics calls, or else a `missingAnalyticsNodeError` error will be thrown.
	 *
	 * @param {TypewriterOptions} options - the options to upsert
	 *
	 * @typedef {Object} TypewriterOptions
	 * @property {Segment.AnalyticsNode} analytics - Underlying analytics instance where analytics
	 * 		calls are forwarded on to.
	 * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
	 * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
	 * 		it will throw errors if NODE_ENV="test" so that tests will fail if a message does not match the spec. Otherwise, errors
	 * 		will be logged to stderr.
	 */
	setTypewriterOptions,
	/**
	 * Validates that clients properly sanitize event names.
	 *
	 * @param {TrackMessage<Record<string, any>>} message - The analytics properties that will be sent to Segment.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	I42TerribleEventName3,
	/**
	 * Fired before an analytics instance has been set, which should throw an error.
	 *
	 * @param {TrackMessage<Record<string, any>>} message - The analytics properties that will be sent to Segment.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	analyticsInstanceMissing,
	/**
	 * Fired after a client throws an "Analytics Instance Missing" error to mark the test as successful.
	 *
	 * @param {TrackMessage<Record<string, any>>} message - The analytics properties that will be sent to Segment.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	analyticsInstanceMissingThrewError,
	/**
	 * This event is fired in order to trigger a custom violation handler. It should be called with a JSON Schema violation.
	 *
	 * @param {TrackMessage<CustomViolationHandler>} message - The analytics properties that will be sent to Segment.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	customViolationHandler,
	/**
	 * This event should be fired if a custom violation handler is correctly called due to a call to `Custom Violation Handler` with a violation.
	 *
	 * @param {TrackMessage<Record<string, any>>} message - The analytics properties that will be sent to Segment.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	customViolationHandlerCalled,
	/**
	 * This event is fired in order to trigger the default violation handler. It should be called with a JSON Schema violation.
	 *
	 * @param {TrackMessage<DefaultViolationHandler>} message - The analytics properties that will be sent to Segment.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	defaultViolationHandler,
	/**
	 * This event should be fired if the default violation handler is correctly called due to a call to `Default Violation Handler` with a violation.
	 *
	 * @param {TrackMessage<Record<string, any>>} message - The analytics properties that will be sent to Segment.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	defaultViolationHandlerCalled,
	/**
	 * Validates that a generated client supports events with no explicit properties. It is expected that this event accepts ANY properties.
	 *
	 * @param {TrackMessage<Record<string, any>>} message - The analytics properties that will be sent to Segment.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	emptyEvent,
	/**
	 * Validates that a generated client handles even naming collisions.
	 *
	 * @param {TrackMessage<Record<string, any>>} message - The analytics properties that will be sent to Segment.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	eventCollided,
	/**
	 * Validates that clients handle all of the supported field types, as nullable optional fields. If a field is null, it is expected to be NOT sent through.
	 *
	 * @param {TrackMessage<EveryNullableOptionalType>} message - The analytics properties that will be sent to Segment.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	everyNullableOptionalType,
	/**
	 * Validates that clients handle all of the supported field types, as nullable required fields. If a field is null, it is expected to be sent through.
	 *
	 * @param {TrackMessage<EveryNullableRequiredType>} message - The analytics properties that will be sent to Segment.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	everyNullableRequiredType,
	/**
	 * Validates that clients handle all of the supported field types, as optional fields.
	 *
	 * @param {TrackMessage<EveryOptionalType>} message - The analytics properties that will be sent to Segment.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	everyOptionalType,
	/**
	 * Validates that clients handle all of the supported field types, as required fields.
	 *
	 * @param {TrackMessage<EveryRequiredType>} message - The analytics properties that will be sent to Segment.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	everyRequiredType,
	/**
	 * Validates that clients correctly serialize large numbers (integers and floats).
	 *
	 * @param {TrackMessage<LargeNumbersEvent>} message - The analytics properties that will be sent to Segment.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	largeNumbersEvent,
	/**
	 * Validates that clients handle arrays-within-arrays.
	 *
	 * @param {TrackMessage<NestedArrays>} message - The analytics properties that will be sent to Segment.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	nestedArrays,
	/**
	 * Validates that clients handle objects-within-objects.
	 *
	 * @param {TrackMessage<NestedObjects>} message - The analytics properties that will be sent to Segment.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	nestedObjects,
	/**
	 * Validates that clients handle collisions in property names within a single event.
	 *
	 * @param {TrackMessage<PropertiesCollided>} message - The analytics properties that will be sent to Segment.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	propertiesCollided,
	/**
	 * Validates that clients handle collisions in object names across multiple events.
	 *
	 * @param {TrackMessage<PropertyObjectNameCollision1>} message - The analytics properties that will be sent to Segment.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	propertyObjectNameCollision1,
	/**
	 * Validates that clients handle collisions in object names across multiple events.
	 *
	 * @param {TrackMessage<PropertyObjectNameCollision2>} message - The analytics properties that will be sent to Segment.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	propertyObjectNameCollision2,
	/**
	 * Validates that clients sanitize property names that contain invalid identifier characters.
	 *
	 * @param {TrackMessage<PropertySanitized>} message - The analytics properties that will be sent to Segment.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	propertySanitized,
	/**
	 * Validates that clients support fields with various types of arrays.
	 *
	 * @param {TrackMessage<SimpleArrayTypes>} message - The analytics properties that will be sent to Segment.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	simpleArrayTypes,
	/**
	 * Validates that clients support fields with multiple (union) types.
	 *
	 * @param {TrackMessage<UnionType>} message - The analytics properties that will be sent to Segment.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	unionType,
	/**
	 * Validates that a generated client handles even naming collisions.
	 *
	 * @param {TrackMessage<Record<string, any>>} message - The analytics properties that will be sent to Segment.
	 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
	 * 		call is fired.
	 */
	eventCollided1,
}

export default new Proxy<typeof clientAPI>(clientAPI, {
	get(target, method) {
		if (typeof method === 'string' && target.hasOwnProperty(method)) {
			return target[method as keyof typeof clientAPI]
		}

		return () => {
			console.warn(`⚠️  You made an analytics call (${String(
				method
			)}) that can't be found. Either:
    a) Re-generate your typewriter client: \`npx typewriter\`
    b) Add it to your Tracking Plan: https://app.segment.com/segment_prod/protocols/tracking-plans/rs_1N9oTnc5O8cv1peY65iXsSPnzGP`)
			const a = analytics()
			if (a) {
				a.track(
					withTypewriterContext({
						event: 'Unknown Analytics Call Fired',
						properties: {
							method,
						},
						userId: 'typewriter',
					})
				)
			}
		}
	},
})
