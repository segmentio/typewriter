// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`build builds client Language: javascript, SDK:analytics-node 1`] = `
"\\"use strict\\";
// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { \\"default\\": mod };
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.noIDType = exports.unionType = exports.simpleArrayTypes = exports.propertySanitized = exports.propertyObjectNameCollision2 = exports.propertyObjectNameCollision1 = exports.propertiesCollided = exports.nestedObjects = exports.nestedArrays = exports.largeNumbersEvent = exports.everyRequiredType = exports.everyOptionalType = exports.everyNullableRequiredType = exports.everyNullableOptionalType = exports.enumTypes = exports.defaultViolationHandler = exports.customViolationHandler = exports.setTypewriterOptions = exports.defaultValidationErrorHandler = exports.StringEnum = exports.StringConst = void 0;
/**
 * A string property that only accepts a single enum value.
 */
var StringConst;
(function (StringConst) {
    StringConst[\\"RickSanchez\\"] = \\"Rick Sanchez\\";
})(StringConst = exports.StringConst || (exports.StringConst = {}));
/**
 * A string property that accepts multiple enum values.
 */
var StringEnum;
(function (StringEnum) {
    StringEnum[\\"EvilMorty\\"] = \\"Evil Morty\\";
    StringEnum[\\"LawyerMorty\\"] = \\"Lawyer Morty\\";
})(StringEnum = exports.StringEnum || (exports.StringEnum = {}));
/**
 * Ajv is a peer dependency for development builds. It's used to apply run-time validation
 * to message payloads before passing them on to the underlying analytics instance.
 *
 * Note that the production bundle does not depend on Ajv.
 *
 * You can install it with: \`npm install --save-dev ajv\`.
 */
var ajv_1 = __importDefault(require(\\"ajv\\"));
/**
 * The default handler that is fired if none is supplied with setTypewriterOptions.
 * If NODE_ENV=\\"test\\", this handler will throw an error. Otherwise, it will log
 * a warning message to the console.
 */
var defaultValidationErrorHandler = function (message, violations) {
    var msg = JSON.stringify({
        type: 'Typewriter JSON Schema Validation Error',
        description: \\"You made an analytics call (\\".concat(message.event, \\") using Typewriter that doesn't match the \\") +
            'Tracking Plan spec.',
        errors: violations,
    }, undefined, 2);
    if (process.env.NODE_ENV === 'test') {
        throw new Error(msg);
    }
    console.warn(msg);
};
exports.defaultValidationErrorHandler = defaultValidationErrorHandler;
var onViolation = exports.defaultValidationErrorHandler;
var missingAnalyticsNodeError = new Error(\\"You must set an analytics-node instance:\\\\n\\\\n>\\\\timport { Analytics } from '@segment/analytics-node'\\\\n>\\\\timport { setTypewriterOptions } from './analytics'\\\\n>\\\\n> const analytics = new Analytics({ writeKey: 'SEGMENT_WRITE_KEY' })\\\\n>\\\\tsetTypewriterOptions({ analytics: analytics\\\\t})\\\\n\\\\nFor more information on @segment/analytics-node, see: https://segment.com/docs/sources/server/node/quickstart/\\\\n\\");
var analytics = function () {
    throw missingAnalyticsNodeError;
};
/**
 * Updates the run-time configuration of this Typewriter client.
 * This function must be called with a configured analytics-node instance before firing
 * any analytics calls, or else a \`missingAnalyticsNodeError\` error will be thrown.
 *
 * @param {TypewriterOptions} options - the options to upsert
 *
 * @typedef {Object} TypewriterOptions
 * @property {Analytics} analytics - Underlying analytics instance where analytics
 * 		calls are forwarded on to.
 * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
 * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
 * 		it will throw errors if NODE_ENV=\\"test\\" so that tests will fail if a message does not match the spec. Otherwise, errors
 * 		will be logged to stderr.
 */
function setTypewriterOptions(options) {
    analytics = options.analytics ? function () { return options.analytics; } : analytics;
    onViolation = options.onViolation || onViolation;
}
exports.setTypewriterOptions = setTypewriterOptions;
/**
    * Validates a message against a JSON Schema using Ajv. If the message
    * is invalid, the \`onViolation\` handler will be called.
    */
function validateAgainstSchema(message, schema) {
    var ajv = new ajv_1.default({ allErrors: true, verbose: true });
    if (!ajv.validate(schema, message.properties) && ajv.errors) {
        onViolation(message, ajv.errors);
    }
}
/**
 * Helper to attach metadata on Typewriter to outbound requests.
 * This is used for attribution and debugging by the Segment team.
 */
function withTypewriterContext(message) {
    return __assign(__assign({}, message), { context: __assign(__assign({}, (message.context || {})), { typewriter: {
                language: 'typescript',
                
            } }) });
}
/**
 * Fires a 'Custom Violation Handler' track call.
 * This event is fired in order to trigger a custom violation handler. It should be called with a JSON Schema violation.
 *
 * @param {TrackMessage<CustomViolationHandler>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function customViolationHandler(message, callback) {
    var event = withTypewriterContext(__assign(__assign({}, message), { event: 'Custom Violation Handler', properties: __assign({}, message.properties) }));
    var schema = { \\"$id\\": \\"Custom_Violation_Handler\\", \\"$schema\\": \\"http://json-schema.org/draft-07/schema#\\", \\"description\\": \\"This event is fired in order to trigger a custom violation handler. It should be called with a JSON Schema violation.\\", \\"properties\\": { \\"regex property\\": { \\"$id\\": \\"/properties/regex%20property\\", \\"description\\": \\"\\", \\"pattern\\": \\"Lawyer Morty|Evil Morty\\", \\"type\\": \\"string\\" } }, \\"required\\": [\\"regex property\\"], \\"type\\": \\"object\\" };
    validateAgainstSchema(event, schema);
    var a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.customViolationHandler = customViolationHandler;
/**
 * Fires a 'Default Violation Handler' track call.
 * This event is fired in order to trigger the default violation handler. It should be called with a JSON Schema violation.
 *
 * @param {TrackMessage<DefaultViolationHandler>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function defaultViolationHandler(message, callback) {
    var event = withTypewriterContext(__assign(__assign({}, message), { event: 'Default Violation Handler', properties: __assign({}, message.properties) }));
    var schema = { \\"$id\\": \\"Default_Violation_Handler\\", \\"$schema\\": \\"http://json-schema.org/draft-07/schema#\\", \\"description\\": \\"This event is fired in order to trigger the default violation handler. It should be called with a JSON Schema violation.\\", \\"properties\\": { \\"regex property\\": { \\"$id\\": \\"/properties/regex%20property\\", \\"description\\": \\"\\", \\"pattern\\": \\"Lawyer Morty|Evil Morty\\", \\"type\\": \\"string\\" } }, \\"required\\": [\\"regex property\\"], \\"type\\": \\"object\\" };
    validateAgainstSchema(event, schema);
    var a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.defaultViolationHandler = defaultViolationHandler;
/**
 * Fires a 'Enum Types' track call.
 * Validates that client property sanitize enums.
 *
 * @param {TrackMessage<EnumTypes>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function enumTypes(message, callback) {
    var event = withTypewriterContext(__assign(__assign({}, message), { event: 'Enum Types', properties: __assign({}, message.properties) }));
    var schema = { \\"$id\\": \\"Enum_Types\\", \\"$schema\\": \\"http://json-schema.org/draft-07/schema#\\", \\"description\\": \\"Validates that client property sanitize enums.\\", \\"properties\\": { \\"string const\\": { \\"$id\\": \\"/properties/string%20const\\", \\"description\\": \\"A string property that only accepts a single enum value.\\", \\"enum\\": [\\"Rick Sanchez\\"], \\"type\\": \\"string\\" }, \\"string enum\\": { \\"$id\\": \\"/properties/string%20enum\\", \\"description\\": \\"A string property that accepts multiple enum values.\\", \\"enum\\": [\\"Evil Morty\\", \\"Lawyer Morty\\"], \\"type\\": \\"string\\" } }, \\"type\\": \\"object\\" };
    validateAgainstSchema(event, schema);
    var a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.enumTypes = enumTypes;
/**
 * Fires a 'Every Nullable Optional Type' track call.
 * Validates that clients handle all of the supported field types, as nullable optional fields. If a field is null, it is expected to be NOT sent through.
 *
 * @param {TrackMessage<EveryNullableOptionalType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function everyNullableOptionalType(message, callback) {
    var event = withTypewriterContext(__assign(__assign({}, message), { event: 'Every Nullable Optional Type', properties: __assign({}, message.properties) }));
    var schema = { \\"$id\\": \\"Every_Nullable_Optional_Type\\", \\"$schema\\": \\"http://json-schema.org/draft-07/schema#\\", \\"description\\": \\"Validates that clients handle all of the supported field types, as nullable optional fields. If a field is null, it is expected to be NOT sent through.\\", \\"properties\\": { \\"optional any\\": { \\"$id\\": \\"/properties/optional%20any\\", \\"description\\": \\"Optional any property\\" }, \\"optional array\\": { \\"$id\\": \\"/properties/optional%20array\\", \\"description\\": \\"Optional array property\\", \\"type\\": [\\"array\\", \\"null\\"] }, \\"optional array with properties\\": { \\"$id\\": \\"/properties/optional%20array%20with%20properties\\", \\"description\\": \\"Optional array with properties\\", \\"items\\": { \\"$id\\": \\"/properties/properties/properties/optional%20array%20with%20properties/items\\", \\"properties\\": { \\"optional any\\": { \\"$id\\": \\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20any\\", \\"description\\": \\"Optional any property\\" }, \\"optional array\\": { \\"$id\\": \\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20array\\", \\"description\\": \\"Optional array property\\", \\"type\\": [\\"array\\", \\"null\\"] }, \\"optional boolean\\": { \\"$id\\": \\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20boolean\\", \\"description\\": \\"Optional boolean property\\", \\"type\\": [\\"boolean\\", \\"null\\"] }, \\"optional int\\": { \\"$id\\": \\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20int\\", \\"description\\": \\"Optional integer property\\", \\"type\\": [\\"integer\\", \\"null\\"] }, \\"optional number\\": { \\"$id\\": \\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20number\\", \\"description\\": \\"Optional number property\\", \\"type\\": [\\"number\\", \\"null\\"] }, \\"optional object\\": { \\"$id\\": \\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20object\\", \\"description\\": \\"Optional object property\\", \\"properties\\": {}, \\"required\\": [], \\"type\\": [\\"object\\", \\"null\\"] }, \\"optional string\\": { \\"$id\\": \\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20string\\", \\"description\\": \\"Optional string property\\", \\"type\\": [\\"string\\", \\"null\\"] }, \\"optional string with regex\\": { \\"$id\\": \\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20string%20with%20regex\\", \\"description\\": \\"Optional string property with a regex conditional\\", \\"pattern\\": \\"Evil Morty|Lawyer Morty\\", \\"type\\": [\\"string\\", \\"null\\"] } }, \\"type\\": [\\"object\\", \\"null\\"] }, \\"type\\": [\\"array\\", \\"null\\"] }, \\"optional boolean\\": { \\"$id\\": \\"/properties/optional%20boolean\\", \\"description\\": \\"Optional boolean property\\", \\"type\\": [\\"boolean\\", \\"null\\"] }, \\"optional int\\": { \\"$id\\": \\"/properties/optional%20int\\", \\"description\\": \\"Optional integer property\\", \\"type\\": [\\"integer\\", \\"null\\"] }, \\"optional number\\": { \\"$id\\": \\"/properties/optional%20number\\", \\"description\\": \\"Optional number property\\", \\"type\\": [\\"number\\", \\"null\\"] }, \\"optional object\\": { \\"$id\\": \\"/properties/optional%20object\\", \\"description\\": \\"Optional object property\\", \\"properties\\": {}, \\"required\\": [], \\"type\\": [\\"object\\", \\"null\\"] }, \\"optional object with properties\\": { \\"$id\\": \\"/properties/optional%20object%20with%20properties\\", \\"description\\": \\"Optional object with properties\\", \\"properties\\": { \\"optional any\\": { \\"$id\\": \\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20any\\", \\"description\\": \\"Optional any property\\" }, \\"optional array\\": { \\"$id\\": \\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20array\\", \\"description\\": \\"Optional array property\\", \\"type\\": [\\"array\\", \\"null\\"] }, \\"optional boolean\\": { \\"$id\\": \\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20boolean\\", \\"description\\": \\"Optional boolean property\\", \\"type\\": [\\"boolean\\", \\"null\\"] }, \\"optional int\\": { \\"$id\\": \\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20int\\", \\"description\\": \\"Optional integer property\\", \\"type\\": [\\"integer\\", \\"null\\"] }, \\"optional number\\": { \\"$id\\": \\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20number\\", \\"description\\": \\"Optional number property\\", \\"type\\": [\\"number\\", \\"null\\"] }, \\"optional object\\": { \\"$id\\": \\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20object\\", \\"description\\": \\"Optional object property\\", \\"properties\\": {}, \\"required\\": [], \\"type\\": [\\"object\\", \\"null\\"] }, \\"optional string\\": { \\"$id\\": \\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20string\\", \\"description\\": \\"Optional string property\\", \\"type\\": [\\"string\\", \\"null\\"] }, \\"optional string with regex\\": { \\"$id\\": \\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20string%20with%20regex\\", \\"description\\": \\"Optional string property with a regex conditional\\", \\"pattern\\": \\"Evil Morty|Lawyer Morty\\", \\"type\\": [\\"string\\", \\"null\\"] } }, \\"required\\": [], \\"type\\": [\\"object\\", \\"null\\"] }, \\"optional string\\": { \\"$id\\": \\"/properties/optional%20string\\", \\"description\\": \\"Optional string property\\", \\"type\\": [\\"string\\", \\"null\\"] }, \\"optional string with regex\\": { \\"$id\\": \\"/properties/optional%20string%20with%20regex\\", \\"description\\": \\"Optional string property with a regex conditional\\", \\"pattern\\": \\"Evil Morty|Lawyer Morty\\", \\"type\\": [\\"string\\", \\"null\\"] } }, \\"type\\": \\"object\\" };
    validateAgainstSchema(event, schema);
    var a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.everyNullableOptionalType = everyNullableOptionalType;
/**
 * Fires a 'Every Nullable Required Type' track call.
 * Validates that clients handle all of the supported field types, as nullable required fields. If a field is null, it is expected to be sent through.
 *
 * @param {TrackMessage<EveryNullableRequiredType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function everyNullableRequiredType(message, callback) {
    var event = withTypewriterContext(__assign(__assign({}, message), { event: 'Every Nullable Required Type', properties: __assign({}, message.properties) }));
    var schema = { \\"$id\\": \\"Every_Nullable_Required_Type\\", \\"$schema\\": \\"http://json-schema.org/draft-07/schema#\\", \\"description\\": \\"Validates that clients handle all of the supported field types, as nullable required fields. If a field is null, it is expected to be sent through.\\", \\"properties\\": { \\"required any\\": { \\"$id\\": \\"/properties/required%20any\\", \\"description\\": \\"Required any property\\" }, \\"required array\\": { \\"$id\\": \\"/properties/required%20array\\", \\"description\\": \\"Required array property\\", \\"type\\": [\\"array\\", \\"null\\"] }, \\"required array with properties\\": { \\"$id\\": \\"/properties/required%20array%20with%20properties\\", \\"description\\": \\"Required array with properties\\", \\"items\\": { \\"$id\\": \\"/properties/properties/properties/required%20array%20with%20properties/items\\", \\"properties\\": { \\"required any\\": { \\"$id\\": \\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20any\\", \\"description\\": \\"Required any property\\" }, \\"required array\\": { \\"$id\\": \\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20array\\", \\"description\\": \\"Required array property\\", \\"type\\": [\\"array\\", \\"null\\"] }, \\"required boolean\\": { \\"$id\\": \\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20boolean\\", \\"description\\": \\"Required boolean property\\", \\"type\\": [\\"boolean\\", \\"null\\"] }, \\"required int\\": { \\"$id\\": \\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20int\\", \\"description\\": \\"Required integer property\\", \\"type\\": [\\"integer\\", \\"null\\"] }, \\"required number\\": { \\"$id\\": \\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20number\\", \\"description\\": \\"Required number property\\", \\"type\\": [\\"number\\", \\"null\\"] }, \\"required object\\": { \\"$id\\": \\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20object\\", \\"description\\": \\"Required object property\\", \\"properties\\": {}, \\"required\\": [], \\"type\\": [\\"object\\", \\"null\\"] }, \\"required string\\": { \\"$id\\": \\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20string\\", \\"description\\": \\"Required string property\\", \\"type\\": [\\"string\\", \\"null\\"] }, \\"required string with regex\\": { \\"$id\\": \\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20string%20with%20regex\\", \\"description\\": \\"Required string property with a regex conditional\\", \\"pattern\\": \\"Evil Morty|Lawyer Morty\\", \\"type\\": [\\"string\\", \\"null\\"] } }, \\"required\\": [\\"required any\\", \\"required array\\", \\"required boolean\\", \\"required int\\", \\"required number\\", \\"required object\\", \\"required string\\", \\"required string with regex\\"], \\"type\\": [\\"object\\", \\"null\\"] }, \\"type\\": [\\"array\\", \\"null\\"] }, \\"required boolean\\": { \\"$id\\": \\"/properties/required%20boolean\\", \\"description\\": \\"Required boolean property\\", \\"type\\": [\\"boolean\\", \\"null\\"] }, \\"required int\\": { \\"$id\\": \\"/properties/required%20int\\", \\"description\\": \\"Required integer property\\", \\"type\\": [\\"integer\\", \\"null\\"] }, \\"required number\\": { \\"$id\\": \\"/properties/required%20number\\", \\"description\\": \\"Required number property\\", \\"type\\": [\\"number\\", \\"null\\"] }, \\"required object\\": { \\"$id\\": \\"/properties/required%20object\\", \\"description\\": \\"Required object property\\", \\"properties\\": {}, \\"required\\": [], \\"type\\": [\\"object\\", \\"null\\"] }, \\"required object with properties\\": { \\"$id\\": \\"/properties/required%20object%20with%20properties\\", \\"description\\": \\"Required object with properties\\", \\"properties\\": { \\"required any\\": { \\"$id\\": \\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20any\\", \\"description\\": \\"Required any property\\" }, \\"required array\\": { \\"$id\\": \\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20array\\", \\"description\\": \\"Required array property\\", \\"type\\": [\\"array\\", \\"null\\"] }, \\"required boolean\\": { \\"$id\\": \\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20boolean\\", \\"description\\": \\"Required boolean property\\", \\"type\\": [\\"boolean\\", \\"null\\"] }, \\"required int\\": { \\"$id\\": \\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20int\\", \\"description\\": \\"Required integer property\\", \\"type\\": [\\"integer\\", \\"null\\"] }, \\"required number\\": { \\"$id\\": \\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20number\\", \\"description\\": \\"Required number property\\", \\"type\\": [\\"number\\", \\"null\\"] }, \\"required object\\": { \\"$id\\": \\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20object\\", \\"description\\": \\"Required object property\\", \\"properties\\": {}, \\"required\\": [], \\"type\\": [\\"object\\", \\"null\\"] }, \\"required string\\": { \\"$id\\": \\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20string\\", \\"description\\": \\"Required string property\\", \\"type\\": [\\"string\\", \\"null\\"] }, \\"required string with regex\\": { \\"$id\\": \\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20string%20with%20regex\\", \\"description\\": \\"Required string property with a regex conditional\\", \\"pattern\\": \\"Evil Morty|Lawyer Morty\\", \\"type\\": [\\"string\\", \\"null\\"] } }, \\"required\\": [\\"required any\\", \\"required array\\", \\"required boolean\\", \\"required int\\", \\"required number\\", \\"required object\\", \\"required string\\", \\"required string with regex\\"], \\"type\\": [\\"object\\", \\"null\\"] }, \\"required string\\": { \\"$id\\": \\"/properties/required%20string\\", \\"description\\": \\"Required string property\\", \\"type\\": [\\"string\\", \\"null\\"] }, \\"required string with regex\\": { \\"$id\\": \\"/properties/required%20string%20with%20regex\\", \\"description\\": \\"Required string property with a regex conditional\\", \\"pattern\\": \\"Evil Morty|Lawyer Morty\\", \\"type\\": [\\"string\\", \\"null\\"] } }, \\"required\\": [\\"required any\\", \\"required array\\", \\"required boolean\\", \\"required int\\", \\"required number\\", \\"required object\\", \\"required string\\", \\"required string with regex\\", \\"required object with properties\\", \\"required array with properties\\"], \\"type\\": \\"object\\" };
    validateAgainstSchema(event, schema);
    var a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.everyNullableRequiredType = everyNullableRequiredType;
/**
 * Fires a 'Every Optional Type' track call.
 * Validates that clients handle all of the supported field types, as optional fields.
 *
 * @param {TrackMessage<EveryOptionalType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function everyOptionalType(message, callback) {
    var event = withTypewriterContext(__assign(__assign({}, message), { event: 'Every Optional Type', properties: __assign({}, message.properties) }));
    var schema = { \\"$id\\": \\"Every_Optional_Type\\", \\"$schema\\": \\"http://json-schema.org/draft-07/schema#\\", \\"description\\": \\"Validates that clients handle all of the supported field types, as optional fields.\\", \\"properties\\": { \\"optional any\\": { \\"$id\\": \\"/properties/optional%20any\\", \\"description\\": \\"Optional any property\\" }, \\"optional array\\": { \\"$id\\": \\"/properties/optional%20array\\", \\"description\\": \\"Optional array property\\", \\"type\\": \\"array\\" }, \\"optional array with properties\\": { \\"$id\\": \\"/properties/optional%20array%20with%20properties\\", \\"description\\": \\"Optional array with properties\\", \\"items\\": { \\"$id\\": \\"/properties/properties/properties/optional%20array%20with%20properties/items\\", \\"properties\\": { \\"optional any\\": { \\"$id\\": \\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20any\\", \\"description\\": \\"Optional any property\\" }, \\"optional array\\": { \\"$id\\": \\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20array\\", \\"description\\": \\"Optional array property\\", \\"type\\": \\"array\\" }, \\"optional boolean\\": { \\"$id\\": \\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20boolean\\", \\"description\\": \\"Optional boolean property\\", \\"type\\": \\"boolean\\" }, \\"optional int\\": { \\"$id\\": \\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20int\\", \\"description\\": \\"Optional integer property\\", \\"type\\": \\"integer\\" }, \\"optional number\\": { \\"$id\\": \\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20number\\", \\"description\\": \\"Optional number property\\", \\"type\\": \\"number\\" }, \\"optional object\\": { \\"$id\\": \\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20object\\", \\"description\\": \\"Optional object property\\", \\"key\\": \\"optional object\\", \\"properties\\": {}, \\"type\\": \\"object\\" }, \\"optional string\\": { \\"$id\\": \\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20string\\", \\"description\\": \\"Optional string property\\", \\"type\\": \\"string\\" }, \\"optional string with regex\\": { \\"$id\\": \\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20string%20with%20regex\\", \\"description\\": \\"Optional string property with a regex conditional\\", \\"pattern\\": \\"Evil Morty|Lawyer Morty\\", \\"type\\": \\"string\\" } }, \\"type\\": \\"object\\" }, \\"type\\": \\"array\\" }, \\"optional boolean\\": { \\"$id\\": \\"/properties/optional%20boolean\\", \\"description\\": \\"Optional boolean property\\", \\"type\\": \\"boolean\\" }, \\"optional int\\": { \\"$id\\": \\"/properties/optional%20int\\", \\"description\\": \\"Optional integer property\\", \\"type\\": \\"integer\\" }, \\"optional number\\": { \\"$id\\": \\"/properties/optional%20number\\", \\"description\\": \\"Optional number property\\", \\"type\\": \\"number\\" }, \\"optional object\\": { \\"$id\\": \\"/properties/optional%20object\\", \\"description\\": \\"Optional object property\\", \\"key\\": \\"optional object\\", \\"properties\\": {}, \\"type\\": \\"object\\" }, \\"optional object with properties\\": { \\"$id\\": \\"/properties/optional%20object%20with%20properties\\", \\"description\\": \\"Optional object with properties\\", \\"properties\\": { \\"optional any\\": { \\"$id\\": \\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20any\\", \\"description\\": \\"Optional any property\\" }, \\"optional array\\": { \\"$id\\": \\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20array\\", \\"description\\": \\"Optional array property\\", \\"type\\": \\"array\\" }, \\"optional boolean\\": { \\"$id\\": \\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20boolean\\", \\"description\\": \\"Optional boolean property\\", \\"type\\": \\"boolean\\" }, \\"optional int\\": { \\"$id\\": \\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20int\\", \\"description\\": \\"Optional integer property\\", \\"type\\": \\"integer\\" }, \\"optional number\\": { \\"$id\\": \\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20number\\", \\"description\\": \\"Optional number property\\", \\"type\\": \\"number\\" }, \\"optional object\\": { \\"$id\\": \\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20object\\", \\"description\\": \\"Optional object property\\", \\"key\\": \\"optional object\\", \\"properties\\": {}, \\"type\\": \\"object\\" }, \\"optional string\\": { \\"$id\\": \\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20string\\", \\"description\\": \\"Optional string property\\", \\"type\\": \\"string\\" }, \\"optional string with regex\\": { \\"$id\\": \\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20string%20with%20regex\\", \\"description\\": \\"Optional string property with a regex conditional\\", \\"pattern\\": \\"Evil Morty|Lawyer Morty\\", \\"type\\": \\"string\\" } }, \\"type\\": \\"object\\" }, \\"optional string\\": { \\"$id\\": \\"/properties/optional%20string\\", \\"description\\": \\"Optional string property\\", \\"type\\": \\"string\\" }, \\"optional string with regex\\": { \\"$id\\": \\"/properties/optional%20string%20with%20regex\\", \\"description\\": \\"Optional string property with a regex conditional\\", \\"pattern\\": \\"Evil Morty|Lawyer Morty\\", \\"type\\": \\"string\\" } }, \\"type\\": \\"object\\" };
    validateAgainstSchema(event, schema);
    var a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.everyOptionalType = everyOptionalType;
/**
 * Fires a 'Every Required Type' track call.
 * Validates that clients handle all of the supported field types, as required fields.
 *
 * @param {TrackMessage<EveryRequiredType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function everyRequiredType(message, callback) {
    var event = withTypewriterContext(__assign(__assign({}, message), { event: 'Every Required Type', properties: __assign({}, message.properties) }));
    var schema = { \\"$id\\": \\"Every_Required_Type\\", \\"$schema\\": \\"http://json-schema.org/draft-07/schema#\\", \\"description\\": \\"Validates that clients handle all of the supported field types, as required fields. \\", \\"properties\\": { \\"required any\\": { \\"$id\\": \\"/properties/required%20any\\", \\"description\\": \\"Required any property\\" }, \\"required array\\": { \\"$id\\": \\"/properties/required%20array\\", \\"description\\": \\"Required array property\\", \\"type\\": \\"array\\" }, \\"required array with properties\\": { \\"$id\\": \\"/properties/required%20array%20with%20properties\\", \\"description\\": \\"Required array with properties\\", \\"items\\": { \\"$id\\": \\"/properties/properties/properties/required%20array%20with%20properties/items\\", \\"properties\\": { \\"required any\\": { \\"$id\\": \\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20any\\", \\"description\\": \\"Required any property\\" }, \\"required array\\": { \\"$id\\": \\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20array\\", \\"description\\": \\"Required array property\\", \\"type\\": \\"array\\" }, \\"required boolean\\": { \\"$id\\": \\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20boolean\\", \\"description\\": \\"Required boolean property\\", \\"type\\": \\"boolean\\" }, \\"required int\\": { \\"$id\\": \\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20int\\", \\"description\\": \\"Required integer property\\", \\"type\\": \\"integer\\" }, \\"required number\\": { \\"$id\\": \\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20number\\", \\"description\\": \\"Required number property\\", \\"type\\": \\"number\\" }, \\"required object\\": { \\"$id\\": \\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20object\\", \\"description\\": \\"Required object property\\", \\"key\\": \\"required object\\", \\"properties\\": {}, \\"required\\": [], \\"type\\": \\"object\\" }, \\"required string\\": { \\"$id\\": \\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20string\\", \\"description\\": \\"Required string property\\", \\"type\\": \\"string\\" }, \\"required string with regex\\": { \\"$id\\": \\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20string%20with%20regex\\", \\"description\\": \\"Required string property with a regex conditional\\", \\"pattern\\": \\"Evil Morty|Lawyer Morty\\", \\"type\\": \\"string\\" } }, \\"required\\": [\\"required any\\", \\"required array\\", \\"required boolean\\", \\"required int\\", \\"required number\\", \\"required object\\", \\"required string\\", \\"required string with regex\\"], \\"type\\": \\"object\\" }, \\"type\\": \\"array\\" }, \\"required boolean\\": { \\"$id\\": \\"/properties/required%20boolean\\", \\"description\\": \\"Required boolean property\\", \\"type\\": \\"boolean\\" }, \\"required int\\": { \\"$id\\": \\"/properties/required%20int\\", \\"description\\": \\"Required integer property\\", \\"type\\": \\"integer\\" }, \\"required number\\": { \\"$id\\": \\"/properties/required%20number\\", \\"description\\": \\"Required number property\\", \\"type\\": \\"number\\" }, \\"required object\\": { \\"$id\\": \\"/properties/required%20object\\", \\"description\\": \\"Required object property\\", \\"key\\": \\"required object\\", \\"properties\\": {}, \\"required\\": [], \\"type\\": \\"object\\" }, \\"required object with properties\\": { \\"$id\\": \\"/properties/required%20object%20with%20properties\\", \\"description\\": \\"Required object with properties\\", \\"properties\\": { \\"required any\\": { \\"$id\\": \\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20any\\", \\"description\\": \\"Required any property\\" }, \\"required array\\": { \\"$id\\": \\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20array\\", \\"description\\": \\"Required array property\\", \\"type\\": \\"array\\" }, \\"required boolean\\": { \\"$id\\": \\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20boolean\\", \\"description\\": \\"Required boolean property\\", \\"type\\": \\"boolean\\" }, \\"required int\\": { \\"$id\\": \\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20int\\", \\"description\\": \\"Required integer property\\", \\"type\\": \\"integer\\" }, \\"required number\\": { \\"$id\\": \\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20number\\", \\"description\\": \\"Required number property\\", \\"type\\": \\"number\\" }, \\"required object\\": { \\"$id\\": \\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20object\\", \\"description\\": \\"Required object property\\", \\"key\\": \\"required object\\", \\"properties\\": {}, \\"required\\": [], \\"type\\": \\"object\\" }, \\"required string\\": { \\"$id\\": \\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20string\\", \\"description\\": \\"Required string property\\", \\"type\\": \\"string\\" }, \\"required string with regex\\": { \\"$id\\": \\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20string%20with%20regex\\", \\"description\\": \\"Required string property with a regex conditional\\", \\"pattern\\": \\"Evil Morty|Lawyer Morty\\", \\"type\\": \\"string\\" } }, \\"required\\": [\\"required any\\", \\"required array\\", \\"required boolean\\", \\"required int\\", \\"required number\\", \\"required object\\", \\"required string\\", \\"required string with regex\\"], \\"type\\": \\"object\\" }, \\"required string\\": { \\"$id\\": \\"/properties/required%20string\\", \\"description\\": \\"Required string property\\", \\"type\\": \\"string\\" }, \\"required string with regex\\": { \\"$id\\": \\"/properties/required%20string%20with%20regex\\", \\"description\\": \\"Required string property with a regex conditional\\", \\"pattern\\": \\"Evil Morty|Lawyer Morty\\", \\"type\\": \\"string\\" } }, \\"required\\": [\\"required any\\", \\"required array\\", \\"required boolean\\", \\"required int\\", \\"required number\\", \\"required object\\", \\"required string\\", \\"required string with regex\\", \\"required object with properties\\", \\"required array with properties\\"], \\"type\\": \\"object\\" };
    validateAgainstSchema(event, schema);
    var a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.everyRequiredType = everyRequiredType;
/**
 * Fires a 'Large Numbers Event' track call.
 * Validates that clients correctly serialize large numbers (integers and floats).
 *
 * @param {TrackMessage<LargeNumbersEvent>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function largeNumbersEvent(message, callback) {
    var event = withTypewriterContext(__assign(__assign({}, message), { event: 'Large Numbers Event', properties: __assign({}, message.properties) }));
    var schema = { \\"$id\\": \\"Large_Numbers_Event\\", \\"$schema\\": \\"http://json-schema.org/draft-07/schema#\\", \\"description\\": \\"Validates that clients correctly serialize large numbers (integers and floats).\\", \\"properties\\": { \\"large nullable optional integer\\": { \\"$id\\": \\"/properties/large%20nullable%20optional%20integer\\", \\"description\\": \\"\\", \\"type\\": [\\"integer\\", \\"null\\"] }, \\"large nullable optional number\\": { \\"$id\\": \\"/properties/large%20nullable%20optional%20number\\", \\"description\\": \\"\\", \\"type\\": [\\"number\\", \\"null\\"] }, \\"large nullable required integer\\": { \\"$id\\": \\"/properties/large%20nullable%20required%20integer\\", \\"description\\": \\"\\", \\"type\\": [\\"integer\\", \\"null\\"] }, \\"large nullable required number\\": { \\"$id\\": \\"/properties/large%20nullable%20required%20number\\", \\"description\\": \\"\\", \\"type\\": [\\"number\\", \\"null\\"] }, \\"large optional integer\\": { \\"$id\\": \\"/properties/large%20optional%20integer\\", \\"description\\": \\"\\", \\"type\\": \\"integer\\" }, \\"large optional number\\": { \\"$id\\": \\"/properties/large%20optional%20number\\", \\"description\\": \\"\\", \\"type\\": \\"number\\" }, \\"large required integer\\": { \\"$id\\": \\"/properties/large%20required%20integer\\", \\"description\\": \\"\\", \\"type\\": \\"integer\\" }, \\"large required number\\": { \\"$id\\": \\"/properties/large%20required%20number\\", \\"description\\": \\"\\", \\"type\\": \\"number\\" } }, \\"required\\": [\\"large required integer\\", \\"large required number\\", \\"large nullable required integer\\", \\"large nullable required number\\"], \\"type\\": \\"object\\" };
    validateAgainstSchema(event, schema);
    var a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.largeNumbersEvent = largeNumbersEvent;
/**
 * Fires a 'Nested Arrays' track call.
 * Validates that clients handle arrays-within-arrays.
 *
 * @param {TrackMessage<NestedArrays>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function nestedArrays(message, callback) {
    var event = withTypewriterContext(__assign(__assign({}, message), { event: 'Nested Arrays', properties: __assign({}, message.properties) }));
    var schema = { \\"$id\\": \\"Nested_Arrays\\", \\"$schema\\": \\"http://json-schema.org/draft-07/schema#\\", \\"description\\": \\"Validates that clients handle arrays-within-arrays.\\", \\"properties\\": { \\"universeCharacters\\": { \\"$id\\": \\"/properties/universeCharacters\\", \\"description\\": \\"All known characters from each universe.\\", \\"items\\": { \\"$id\\": \\"/properties/properties/properties/universeCharacters/items\\", \\"description\\": \\"\\", \\"items\\": { \\"description\\": \\"\\", \\"id\\": \\"/properties/properties/properties/universeCharacters/items/items\\", \\"properties\\": { \\"name\\": { \\"description\\": \\"The character's name.\\", \\"id\\": \\"/properties/properties/properties/universeCharacters/items/items/properties/name\\", \\"type\\": \\"string\\" } }, \\"required\\": [\\"name\\"], \\"type\\": \\"object\\" }, \\"type\\": \\"array\\" }, \\"type\\": \\"array\\" } }, \\"required\\": [\\"universeCharacters\\"], \\"type\\": \\"object\\" };
    validateAgainstSchema(event, schema);
    var a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.nestedArrays = nestedArrays;
/**
 * Fires a 'Nested Objects' track call.
 * Validates that clients handle objects-within-objects.
 *
 * @param {TrackMessage<NestedObjects>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function nestedObjects(message, callback) {
    var event = withTypewriterContext(__assign(__assign({}, message), { event: 'Nested Objects', properties: __assign({}, message.properties) }));
    var schema = { \\"$id\\": \\"Nested_Objects\\", \\"$schema\\": \\"http://json-schema.org/draft-07/schema#\\", \\"description\\": \\"Validates that clients handle objects-within-objects.\\", \\"properties\\": { \\"garage\\": { \\"$id\\": \\"/properties/garage\\", \\"description\\": \\"\\", \\"properties\\": { \\"tunnel\\": { \\"$id\\": \\"/properties/properties/properties/garage/properties/tunnel\\", \\"description\\": \\"\\", \\"properties\\": { \\"subterranean lab\\": { \\"$id\\": \\"/properties/properties/properties/garage/properties/tunnel/properties/subterranean%20lab\\", \\"description\\": \\"\\", \\"properties\\": { \\"jerry's memories\\": { \\"$id\\": \\"/properties/properties/properties/garage/properties/tunnel/properties/subterranean%20lab/properties/jerry's%20memories\\", \\"description\\": \\"\\", \\"type\\": \\"array\\" }, \\"morty's memories\\": { \\"$id\\": \\"/properties/properties/properties/garage/properties/tunnel/properties/subterranean%20lab/properties/morty's%20memories\\", \\"description\\": \\"\\", \\"type\\": \\"array\\" }, \\"summer's contingency plan\\": { \\"$id\\": \\"/properties/properties/properties/garage/properties/tunnel/properties/subterranean%20lab/properties/summer's%20contingency%20plan\\", \\"description\\": \\"\\", \\"type\\": \\"string\\" } }, \\"required\\": [], \\"type\\": \\"object\\" } }, \\"required\\": [\\"subterranean lab\\"], \\"type\\": \\"object\\" } }, \\"required\\": [\\"tunnel\\"], \\"type\\": \\"object\\" } }, \\"required\\": [\\"garage\\"], \\"type\\": \\"object\\" };
    validateAgainstSchema(event, schema);
    var a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.nestedObjects = nestedObjects;
/**
 * Fires a 'Properties Collided' track call.
 * Validates that clients handle collisions in property names within a single event.
 *
 * @param {TrackMessage<PropertiesCollided>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function propertiesCollided(message, callback) {
    var event = withTypewriterContext(__assign(__assign({}, message), { event: 'Properties Collided', properties: __assign({}, message.properties) }));
    var schema = { \\"$id\\": \\"Properties_Collided\\", \\"$schema\\": \\"http://json-schema.org/draft-07/schema#\\", \\"description\\": \\"Validates that clients handle collisions in property names within a single event.\\", \\"properties\\": { \\"Property Collided\\": { \\"$id\\": \\"/properties/Property%20Collided\\", \\"description\\": \\"\\", \\"type\\": \\"string\\" }, \\"property_collided\\": { \\"$id\\": \\"/properties/property_collided\\", \\"description\\": \\"\\", \\"type\\": \\"string\\" } }, \\"required\\": [\\"property_collided\\", \\"Property Collided\\"], \\"type\\": \\"object\\" };
    validateAgainstSchema(event, schema);
    var a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.propertiesCollided = propertiesCollided;
/**
 * Fires a 'Property Object Name Collision #1' track call.
 * Validates that clients handle collisions in object names across multiple events.
 *
 * @param {TrackMessage<PropertyObjectNameCollision1>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function propertyObjectNameCollision1(message, callback) {
    var event = withTypewriterContext(__assign(__assign({}, message), { event: 'Property Object Name Collision #1', properties: __assign({}, message.properties) }));
    var schema = { \\"$id\\": \\"Property_Object_Name_Collision_1\\", \\"$schema\\": \\"http://json-schema.org/draft-07/schema#\\", \\"description\\": \\"Validates that clients handle collisions in object names across multiple events.\\", \\"properties\\": { \\"universe\\": { \\"$id\\": \\"/properties/universe\\", \\"description\\": \\"\\", \\"properties\\": { \\"name\\": { \\"$id\\": \\"/properties/properties/properties/universe/properties/name\\", \\"description\\": \\"The common name of this universe.\\", \\"type\\": \\"string\\" }, \\"occupants\\": { \\"$id\\": \\"/properties/properties/properties/universe/properties/occupants\\", \\"description\\": \\"The most important occupants in this universe.\\", \\"items\\": { \\"$id\\": \\"/properties/properties/properties/universe/properties/occupants/items\\", \\"description\\": \\"\\", \\"properties\\": { \\"name\\": { \\"$id\\": \\"/properties/properties/properties/universe/properties/occupants/items/properties/name\\", \\"description\\": \\"The name of this occupant.\\", \\"type\\": \\"string\\" } }, \\"required\\": [\\"name\\"], \\"type\\": \\"object\\" }, \\"type\\": \\"array\\" } }, \\"required\\": [\\"name\\", \\"occupants\\"], \\"type\\": \\"object\\" } }, \\"type\\": \\"object\\" };
    validateAgainstSchema(event, schema);
    var a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.propertyObjectNameCollision1 = propertyObjectNameCollision1;
/**
 * Fires a 'Property Object Name Collision #2' track call.
 * Validates that clients handle collisions in object names across multiple events.
 *
 * @param {TrackMessage<PropertyObjectNameCollision2>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function propertyObjectNameCollision2(message, callback) {
    var event = withTypewriterContext(__assign(__assign({}, message), { event: 'Property Object Name Collision #2', properties: __assign({}, message.properties) }));
    var schema = { \\"$id\\": \\"Property_Object_Name_Collision_2\\", \\"$schema\\": \\"http://json-schema.org/draft-07/schema#\\", \\"description\\": \\"Validates that clients handle collisions in object names across multiple events.\\", \\"properties\\": { \\"universe\\": { \\"$id\\": \\"/properties/universe\\", \\"description\\": \\"\\", \\"properties\\": { \\"name\\": { \\"$id\\": \\"/properties/properties/properties/universe/properties/name\\", \\"description\\": \\"The common name of this universe.\\", \\"type\\": \\"string\\" }, \\"occupants\\": { \\"$id\\": \\"/properties/properties/properties/universe/properties/occupants\\", \\"description\\": \\"The most important occupants in this universe.\\", \\"items\\": { \\"$id\\": \\"/properties/properties/properties/universe/properties/occupants/items\\", \\"description\\": \\"\\", \\"properties\\": { \\"name\\": { \\"$id\\": \\"/properties/properties/properties/universe/properties/occupants/items/properties/name\\", \\"description\\": \\"The name of this occupant.\\", \\"type\\": \\"string\\" } }, \\"required\\": [\\"name\\"], \\"type\\": \\"object\\" }, \\"type\\": \\"array\\" } }, \\"required\\": [\\"name\\", \\"occupants\\"], \\"type\\": \\"object\\" } }, \\"type\\": \\"object\\" };
    validateAgainstSchema(event, schema);
    var a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.propertyObjectNameCollision2 = propertyObjectNameCollision2;
/**
 * Fires a 'Property Sanitized' track call.
 * Validates that clients sanitize property names that contain invalid identifier characters.
 *
 * @param {TrackMessage<PropertySanitized>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function propertySanitized(message, callback) {
    var event = withTypewriterContext(__assign(__assign({}, message), { event: 'Property Sanitized', properties: __assign({}, message.properties) }));
    var schema = { \\"$id\\": \\"Property_Sanitized\\", \\"$schema\\": \\"http://json-schema.org/draft-07/schema#\\", \\"description\\": \\"Validates that clients sanitize property names that contain invalid identifier characters.\\", \\"properties\\": { \\"0000---terrible-property-name~!3\\": { \\"$id\\": \\"/properties/0000---terrible-property-name~!3\\", \\"description\\": \\"\\", \\"type\\": \\"string\\" } }, \\"required\\": [\\"0000---terrible-property-name~!3\\"], \\"type\\": \\"object\\" };
    validateAgainstSchema(event, schema);
    var a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.propertySanitized = propertySanitized;
/**
 * Fires a 'Simple Array Types' track call.
 * Validates that clients support fields with various types of arrays.
 *
 * @param {TrackMessage<SimpleArrayTypes>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function simpleArrayTypes(message, callback) {
    var event = withTypewriterContext(__assign(__assign({}, message), { event: 'Simple Array Types', properties: __assign({}, message.properties) }));
    var schema = { \\"$id\\": \\"Simple_Array_Types\\", \\"$schema\\": \\"http://json-schema.org/draft-07/schema#\\", \\"description\\": \\"Validates that clients support fields with various types of arrays.\\", \\"properties\\": { \\"any\\": { \\"$id\\": \\"/properties/any\\", \\"description\\": \\"\\", \\"items\\": { \\"description\\": \\"\\" }, \\"type\\": \\"array\\" }, \\"boolean\\": { \\"$id\\": \\"/properties/boolean\\", \\"description\\": \\"\\", \\"items\\": { \\"$id\\": \\"/properties/properties/properties/boolean/items\\", \\"description\\": \\"\\", \\"type\\": \\"boolean\\" }, \\"type\\": \\"array\\" }, \\"integer\\": { \\"$id\\": \\"/properties/integer\\", \\"description\\": \\"\\", \\"items\\": { \\"$id\\": \\"/properties/properties/properties/integer/items\\", \\"description\\": \\"\\", \\"type\\": \\"integer\\" }, \\"type\\": \\"array\\" }, \\"nullable\\": { \\"$id\\": \\"/properties/nullable\\", \\"description\\": \\"\\", \\"items\\": { \\"$id\\": \\"/properties/properties/properties/nullable/items\\", \\"description\\": \\"\\", \\"type\\": [\\"string\\", \\"null\\"] }, \\"type\\": \\"array\\" }, \\"number\\": { \\"$id\\": \\"/properties/number\\", \\"description\\": \\"\\", \\"items\\": { \\"$id\\": \\"/properties/properties/properties/number/items\\", \\"description\\": \\"\\", \\"type\\": \\"number\\" }, \\"type\\": \\"array\\" }, \\"object\\": { \\"$id\\": \\"/properties/object\\", \\"description\\": \\"\\", \\"items\\": { \\"$id\\": \\"/properties/properties/properties/object/items\\", \\"description\\": \\"\\", \\"properties\\": { \\"name\\": { \\"$id\\": \\"/properties/properties/properties/object/items/properties/name\\", \\"description\\": \\"\\", \\"type\\": \\"string\\" } }, \\"required\\": [], \\"type\\": \\"object\\" }, \\"type\\": \\"array\\" }, \\"string\\": { \\"$id\\": \\"/properties/string\\", \\"description\\": \\"\\", \\"items\\": { \\"$id\\": \\"/properties/properties/properties/string/items\\", \\"description\\": \\"\\", \\"type\\": \\"string\\" }, \\"type\\": \\"array\\" } }, \\"type\\": \\"object\\" };
    validateAgainstSchema(event, schema);
    var a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.simpleArrayTypes = simpleArrayTypes;
/**
 * Fires a 'Union Type' track call.
 * Validates that clients support fields with multiple (union) types.
 *
 * @param {TrackMessage<UnionType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function unionType(message, callback) {
    var event = withTypewriterContext(__assign(__assign({}, message), { event: 'Union Type', properties: __assign({}, message.properties) }));
    var schema = { \\"$id\\": \\"Union_Type\\", \\"$schema\\": \\"http://json-schema.org/draft-07/schema#\\", \\"description\\": \\"Validates that clients support fields with multiple (union) types.\\", \\"properties\\": { \\"universe_name\\": { \\"$id\\": \\"/properties/universe_name\\", \\"description\\": \\"\\", \\"type\\": [\\"string\\", \\"null\\", \\"integer\\"] } }, \\"required\\": [\\"universe_name\\"], \\"type\\": \\"object\\" };
    validateAgainstSchema(event, schema);
    var a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.unionType = unionType;
/**
 * Fires a 'NoID type' track call.
 * Properties without IDs
 *
 * @param {TrackMessage<NoIDType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
function noIDType(message, callback) {
    var event = withTypewriterContext(__assign(__assign({}, message), { event: 'NoID type', properties: __assign({}, message.properties) }));
    var schema = { \\"$id\\": \\"NoID_Type\\", \\"$schema\\": \\"http://json-schema.org/draft-07/schema#\\", \\"description\\": \\"Properties without IDs\\", \\"properties\\": { \\"no_id_prop\\": { \\"description\\": \\"a property without an ID\\", \\"type\\": \\"string\\" } }, \\"required\\": [\\"no_id_prop\\"], \\"type\\": \\"object\\" };
    validateAgainstSchema(event, schema);
    var a = analytics();
    if (a) {
        a.track(event, callback);
    }
    else {
        throw missingAnalyticsNodeError;
    }
}
exports.noIDType = noIDType;
var clientAPI = {
    /**
     * Updates the run-time configuration of this Typewriter client.
     * This function must be called with a configured analytics-node instance before firing
     * any analytics calls, or else a \`missingAnalyticsNodeError\` error will be thrown.
     *
     * @param {TypewriterOptions} options - the options to upsert
     *
     * @typedef {Object} TypewriterOptions
     * @property {Analytics} analytics - Underlying analytics instance where analytics
     * 		calls are forwarded on to.
     * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
     * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
     * 		it will throw errors if NODE_ENV=\\"test\\" so that tests will fail if a message does not match the spec. Otherwise, errors
     * 		will be logged to stderr.
     */
    setTypewriterOptions: setTypewriterOptions,
    /**
     * Fires a 'Custom Violation Handler' track call.
     * This event is fired in order to trigger a custom violation handler. It should be called with a JSON Schema violation.
     *
     * @param CustomViolationHandler props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    customViolationHandler: customViolationHandler,
    /**
     * Fires a 'Default Violation Handler' track call.
     * This event is fired in order to trigger the default violation handler. It should be called with a JSON Schema violation.
     *
     * @param DefaultViolationHandler props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    defaultViolationHandler: defaultViolationHandler,
    /**
     * Fires a 'Enum Types' track call.
     * Validates that client property sanitize enums.
     *
     * @param EnumTypes props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    enumTypes: enumTypes,
    /**
     * Fires a 'Every Nullable Optional Type' track call.
     * Validates that clients handle all of the supported field types, as nullable optional fields. If a field is null, it is expected to be NOT sent through.
     *
     * @param EveryNullableOptionalType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    everyNullableOptionalType: everyNullableOptionalType,
    /**
     * Fires a 'Every Nullable Required Type' track call.
     * Validates that clients handle all of the supported field types, as nullable required fields. If a field is null, it is expected to be sent through.
     *
     * @param EveryNullableRequiredType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    everyNullableRequiredType: everyNullableRequiredType,
    /**
     * Fires a 'Every Optional Type' track call.
     * Validates that clients handle all of the supported field types, as optional fields.
     *
     * @param EveryOptionalType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    everyOptionalType: everyOptionalType,
    /**
     * Fires a 'Every Required Type' track call.
     * Validates that clients handle all of the supported field types, as required fields.
     *
     * @param EveryRequiredType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    everyRequiredType: everyRequiredType,
    /**
     * Fires a 'Large Numbers Event' track call.
     * Validates that clients correctly serialize large numbers (integers and floats).
     *
     * @param LargeNumbersEvent props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    largeNumbersEvent: largeNumbersEvent,
    /**
     * Fires a 'Nested Arrays' track call.
     * Validates that clients handle arrays-within-arrays.
     *
     * @param NestedArrays props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    nestedArrays: nestedArrays,
    /**
     * Fires a 'Nested Objects' track call.
     * Validates that clients handle objects-within-objects.
     *
     * @param NestedObjects props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    nestedObjects: nestedObjects,
    /**
     * Fires a 'Properties Collided' track call.
     * Validates that clients handle collisions in property names within a single event.
     *
     * @param PropertiesCollided props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    propertiesCollided: propertiesCollided,
    /**
     * Fires a 'Property Object Name Collision #1' track call.
     * Validates that clients handle collisions in object names across multiple events.
     *
     * @param PropertyObjectNameCollision1 props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    propertyObjectNameCollision1: propertyObjectNameCollision1,
    /**
     * Fires a 'Property Object Name Collision #2' track call.
     * Validates that clients handle collisions in object names across multiple events.
     *
     * @param PropertyObjectNameCollision2 props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    propertyObjectNameCollision2: propertyObjectNameCollision2,
    /**
     * Fires a 'Property Sanitized' track call.
     * Validates that clients sanitize property names that contain invalid identifier characters.
     *
     * @param PropertySanitized props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    propertySanitized: propertySanitized,
    /**
     * Fires a 'Simple Array Types' track call.
     * Validates that clients support fields with various types of arrays.
     *
     * @param SimpleArrayTypes props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    simpleArrayTypes: simpleArrayTypes,
    /**
     * Fires a 'Union Type' track call.
     * Validates that clients support fields with multiple (union) types.
     *
     * @param UnionType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    unionType: unionType,
    /**
     * Fires a 'NoID type' track call.
     * Properties without IDs
     *
     * @param NoIDType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    noIDType: noIDType,
};
exports.default = new Proxy(clientAPI, {
    get: function (target, method) {
        if (typeof method === 'string' && target.hasOwnProperty(method)) {
            return target[method];
        }
        return function () {
            console.warn(\\"\\\\u26A0\\\\uFE0F  You made an analytics call (\\".concat(String(method), \\") that can't be found. Either:\\\\n         a) Re-generate your typewriter client: \`npx typewriter\`\\\\n         b) Add it to your Tracking Plan: https://app.segment.com/segment-oscb/protocols/tracking-plans/rs_1zTHJU9fd5mt7cndWnd4PgJbMCE\\"));
            var a = analytics();
            if (a) {
                a.track(withTypewriterContext({
                    event: 'Unknown Analytics Call Fired',
                    properties: {
                        method: method,
                    },
                    userId: 'typewriter',
                }));
            }
        };
    },
});
"
`;

exports[`build builds client Language: kotlin, SDK:kotlin 1`] = `
"com.segment.analytics.kotlin.core.Analytics
// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

package typewriter

import kotlinx.serialization.*
import kotlinx.serialization.json.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*

typealias The42_TerribleEventName3 = HashMap<String, JsonObject?>
typealias AnalyticsInstanceMissing = HashMap<String, JsonObject?>
typealias AnalyticsInstanceMissingThrewError = HashMap<String, JsonObject?>
typealias CustomViolationHandlerCalled = HashMap<String, JsonObject?>
typealias DefaultViolationHandlerCalled = HashMap<String, JsonObject?>
typealias EmptyEvent = HashMap<String, JsonObject?>
typealias EventCollided = HashMap<String, JsonObject?>
typealias PurpleEventCollided = HashMap<String, JsonObject?>

/**
 * This event is fired in order to trigger a custom violation handler. It should be called
 * with a JSON Schema violation.
 */
@Serializable
data class CustomViolationHandler (
    @SerialName(\\"regex property\\")
    val regexProperty: String
)

/**
 * This event is fired in order to trigger the default violation handler. It should be
 * called with a JSON Schema violation.
 */
@Serializable
data class DefaultViolationHandler (
    @SerialName(\\"regex property\\")
    val regexProperty: String
)

/**
 * Validates that client property sanitize enums.
 */
@Serializable
data class EnumTypes (
    /**
     * A string property that only accepts a single enum value.
     */
    @SerialName(\\"string const\\")
    val stringConst: StringConst? = null,

    /**
     * A string property that accepts multiple enum values.
     */
    @SerialName(\\"string enum\\")
    val stringEnum: StringEnum? = null
)

/**
 * A string property that only accepts a single enum value.
 */
@Serializable(with = StringConst.Companion::class)
enum class StringConst(val value: String) {
    RickSanchez(\\"Rick Sanchez\\");

    companion object : KSerializer<StringConst> {
        override val descriptor: SerialDescriptor get() {
            return PrimitiveSerialDescriptor(\\"typewriter.StringConst\\", PrimitiveKind.STRING)
        }
        override fun deserialize(decoder: Decoder): StringConst = when (val value = decoder.decodeString()) {
            \\"Rick Sanchez\\" -> RickSanchez
            else           -> throw IllegalArgumentException(\\"StringConst could not parse: $value\\")
        }
        override fun serialize(encoder: Encoder, value: StringConst) {
            return encoder.encodeString(value.value)
        }
    }
}

/**
 * A string property that accepts multiple enum values.
 */
@Serializable(with = StringEnum.Companion::class)
enum class StringEnum(val value: String) {
    EvilMorty(\\"Evil Morty\\"),
    LawyerMorty(\\"Lawyer Morty\\");

    companion object : KSerializer<StringEnum> {
        override val descriptor: SerialDescriptor get() {
            return PrimitiveSerialDescriptor(\\"typewriter.StringEnum\\", PrimitiveKind.STRING)
        }
        override fun deserialize(decoder: Decoder): StringEnum = when (val value = decoder.decodeString()) {
            \\"Evil Morty\\"   -> EvilMorty
            \\"Lawyer Morty\\" -> LawyerMorty
            else           -> throw IllegalArgumentException(\\"StringEnum could not parse: $value\\")
        }
        override fun serialize(encoder: Encoder, value: StringEnum) {
            return encoder.encodeString(value.value)
        }
    }
}

/**
 * Validates that clients handle all of the supported field types, as nullable optional
 * fields. If a field is null, it is expected to be NOT sent through.
 */
@Serializable
data class EveryNullableOptionalType (
    /**
     * Optional any property
     */
    @SerialName(\\"optional any\\")
    val optionalAny: JsonObject? = null,

    /**
     * Optional array property
     */
    @SerialName(\\"optional array\\")
    val optionalArray: JsonArray? = null,

    /**
     * Optional array with properties
     */
    @SerialName(\\"optional array with properties\\")
    val optionalArrayWithProperties: List<EveryNullableOptionalTypeOptionalArrayWithProperty?>? = null,

    /**
     * Optional boolean property
     */
    @SerialName(\\"optional boolean\\")
    val optionalBoolean: Boolean? = null,

    /**
     * Optional integer property
     */
    @SerialName(\\"optional int\\")
    val optionalInt: Long? = null,

    /**
     * Optional number property
     */
    @SerialName(\\"optional number\\")
    val optionalNumber: Double? = null,

    /**
     * Optional object property
     */
    @SerialName(\\"optional object\\")
    val optionalObject: JsonObject? = null,

    /**
     * Optional object with properties
     */
    @SerialName(\\"optional object with properties\\")
    val optionalObjectWithProperties: EveryNullableOptionalTypeOptionalObjectWithProperties? = null,

    /**
     * Optional string property
     */
    @SerialName(\\"optional string\\")
    val optionalString: String? = null,

    /**
     * Optional string property with a regex conditional
     */
    @SerialName(\\"optional string with regex\\")
    val optionalStringWithRegex: String? = null
)

@Serializable
data class EveryNullableOptionalTypeOptionalArrayWithProperty (
    /**
     * Optional any property
     */
    @SerialName(\\"optional any\\")
    val optionalAny: JsonObject? = null,

    /**
     * Optional array property
     */
    @SerialName(\\"optional array\\")
    val optionalArray: JsonArray? = null,

    /**
     * Optional boolean property
     */
    @SerialName(\\"optional boolean\\")
    val optionalBoolean: Boolean? = null,

    /**
     * Optional integer property
     */
    @SerialName(\\"optional int\\")
    val optionalInt: Long? = null,

    /**
     * Optional number property
     */
    @SerialName(\\"optional number\\")
    val optionalNumber: Double? = null,

    /**
     * Optional object property
     */
    @SerialName(\\"optional object\\")
    val optionalObject: JsonObject? = null,

    /**
     * Optional string property
     */
    @SerialName(\\"optional string\\")
    val optionalString: String? = null,

    /**
     * Optional string property with a regex conditional
     */
    @SerialName(\\"optional string with regex\\")
    val optionalStringWithRegex: String? = null
)

@Serializable
data class EveryNullableOptionalTypeOptionalObjectWithProperties (
    /**
     * Optional any property
     */
    @SerialName(\\"optional any\\")
    val optionalAny: JsonObject? = null,

    /**
     * Optional array property
     */
    @SerialName(\\"optional array\\")
    val optionalArray: JsonArray? = null,

    /**
     * Optional boolean property
     */
    @SerialName(\\"optional boolean\\")
    val optionalBoolean: Boolean? = null,

    /**
     * Optional integer property
     */
    @SerialName(\\"optional int\\")
    val optionalInt: Long? = null,

    /**
     * Optional number property
     */
    @SerialName(\\"optional number\\")
    val optionalNumber: Double? = null,

    /**
     * Optional object property
     */
    @SerialName(\\"optional object\\")
    val optionalObject: JsonObject? = null,

    /**
     * Optional string property
     */
    @SerialName(\\"optional string\\")
    val optionalString: String? = null,

    /**
     * Optional string property with a regex conditional
     */
    @SerialName(\\"optional string with regex\\")
    val optionalStringWithRegex: String? = null
)

/**
 * Validates that clients handle all of the supported field types, as nullable required
 * fields. If a field is null, it is expected to be sent through.
 */
@Serializable
data class EveryNullableRequiredType (
    /**
     * Required any property
     */
    @SerialName(\\"required any\\")
    val requiredAny: JsonObject?,

    /**
     * Required array property
     */
    @SerialName(\\"required array\\")
    val requiredArray: JsonArray? = null,

    /**
     * Required array with properties
     */
    @SerialName(\\"required array with properties\\")
    val requiredArrayWithProperties: List<EveryNullableRequiredTypeRequiredArrayWithProperty?>? = null,

    /**
     * Required boolean property
     */
    @SerialName(\\"required boolean\\")
    val requiredBoolean: Boolean? = null,

    /**
     * Required integer property
     */
    @SerialName(\\"required int\\")
    val requiredInt: Long? = null,

    /**
     * Required number property
     */
    @SerialName(\\"required number\\")
    val requiredNumber: Double? = null,

    /**
     * Required object property
     */
    @SerialName(\\"required object\\")
    val requiredObject: JsonObject? = null,

    /**
     * Required object with properties
     */
    @SerialName(\\"required object with properties\\")
    val requiredObjectWithProperties: EveryNullableRequiredTypeRequiredObjectWithProperties? = null,

    /**
     * Required string property
     */
    @SerialName(\\"required string\\")
    val requiredString: String? = null,

    /**
     * Required string property with a regex conditional
     */
    @SerialName(\\"required string with regex\\")
    val requiredStringWithRegex: String? = null
)

@Serializable
data class EveryNullableRequiredTypeRequiredArrayWithProperty (
    /**
     * Required any property
     */
    @SerialName(\\"required any\\")
    val requiredAny: JsonObject?,

    /**
     * Required array property
     */
    @SerialName(\\"required array\\")
    val requiredArray: JsonArray? = null,

    /**
     * Required boolean property
     */
    @SerialName(\\"required boolean\\")
    val requiredBoolean: Boolean? = null,

    /**
     * Required integer property
     */
    @SerialName(\\"required int\\")
    val requiredInt: Long? = null,

    /**
     * Required number property
     */
    @SerialName(\\"required number\\")
    val requiredNumber: Double? = null,

    /**
     * Required object property
     */
    @SerialName(\\"required object\\")
    val requiredObject: JsonObject? = null,

    /**
     * Required string property
     */
    @SerialName(\\"required string\\")
    val requiredString: String? = null,

    /**
     * Required string property with a regex conditional
     */
    @SerialName(\\"required string with regex\\")
    val requiredStringWithRegex: String? = null
)

@Serializable
data class EveryNullableRequiredTypeRequiredObjectWithProperties (
    /**
     * Required any property
     */
    @SerialName(\\"required any\\")
    val requiredAny: JsonObject?,

    /**
     * Required array property
     */
    @SerialName(\\"required array\\")
    val requiredArray: JsonArray? = null,

    /**
     * Required boolean property
     */
    @SerialName(\\"required boolean\\")
    val requiredBoolean: Boolean? = null,

    /**
     * Required integer property
     */
    @SerialName(\\"required int\\")
    val requiredInt: Long? = null,

    /**
     * Required number property
     */
    @SerialName(\\"required number\\")
    val requiredNumber: Double? = null,

    /**
     * Required object property
     */
    @SerialName(\\"required object\\")
    val requiredObject: JsonObject? = null,

    /**
     * Required string property
     */
    @SerialName(\\"required string\\")
    val requiredString: String? = null,

    /**
     * Required string property with a regex conditional
     */
    @SerialName(\\"required string with regex\\")
    val requiredStringWithRegex: String? = null
)

/**
 * Validates that clients handle all of the supported field types, as optional fields.
 */
@Serializable
data class EveryOptionalType (
    /**
     * Optional any property
     */
    @SerialName(\\"optional any\\")
    val optionalAny: JsonObject? = null,

    /**
     * Optional array property
     */
    @SerialName(\\"optional array\\")
    val optionalArray: JsonArray? = null,

    /**
     * Optional array with properties
     */
    @SerialName(\\"optional array with properties\\")
    val optionalArrayWithProperties: List<OptionalArrayWithPropertyElement>? = null,

    /**
     * Optional boolean property
     */
    @SerialName(\\"optional boolean\\")
    val optionalBoolean: Boolean? = null,

    /**
     * Optional integer property
     */
    @SerialName(\\"optional int\\")
    val optionalInt: Long? = null,

    /**
     * Optional number property
     */
    @SerialName(\\"optional number\\")
    val optionalNumber: Double? = null,

    /**
     * Optional object property
     */
    @SerialName(\\"optional object\\")
    val optionalObject: JsonObject? = null,

    /**
     * Optional object with properties
     */
    @SerialName(\\"optional object with properties\\")
    val optionalObjectWithProperties: EveryOptionalTypeOptionalObjectWithProperties? = null,

    /**
     * Optional string property
     */
    @SerialName(\\"optional string\\")
    val optionalString: String? = null,

    /**
     * Optional string property with a regex conditional
     */
    @SerialName(\\"optional string with regex\\")
    val optionalStringWithRegex: String? = null
)

@Serializable
data class OptionalArrayWithPropertyElement (
    /**
     * Optional any property
     */
    @SerialName(\\"optional any\\")
    val optionalAny: JsonObject? = null,

    /**
     * Optional array property
     */
    @SerialName(\\"optional array\\")
    val optionalArray: JsonArray? = null,

    /**
     * Optional boolean property
     */
    @SerialName(\\"optional boolean\\")
    val optionalBoolean: Boolean? = null,

    /**
     * Optional integer property
     */
    @SerialName(\\"optional int\\")
    val optionalInt: Long? = null,

    /**
     * Optional number property
     */
    @SerialName(\\"optional number\\")
    val optionalNumber: Double? = null,

    /**
     * Optional object property
     */
    @SerialName(\\"optional object\\")
    val optionalObject: JsonObject? = null,

    /**
     * Optional string property
     */
    @SerialName(\\"optional string\\")
    val optionalString: String? = null,

    /**
     * Optional string property with a regex conditional
     */
    @SerialName(\\"optional string with regex\\")
    val optionalStringWithRegex: String? = null
)

/**
 * Optional object with properties
 */
@Serializable
data class EveryOptionalTypeOptionalObjectWithProperties (
    /**
     * Optional any property
     */
    @SerialName(\\"optional any\\")
    val optionalAny: JsonObject? = null,

    /**
     * Optional array property
     */
    @SerialName(\\"optional array\\")
    val optionalArray: JsonArray? = null,

    /**
     * Optional boolean property
     */
    @SerialName(\\"optional boolean\\")
    val optionalBoolean: Boolean? = null,

    /**
     * Optional integer property
     */
    @SerialName(\\"optional int\\")
    val optionalInt: Long? = null,

    /**
     * Optional number property
     */
    @SerialName(\\"optional number\\")
    val optionalNumber: Double? = null,

    /**
     * Optional object property
     */
    @SerialName(\\"optional object\\")
    val optionalObject: JsonObject? = null,

    /**
     * Optional string property
     */
    @SerialName(\\"optional string\\")
    val optionalString: String? = null,

    /**
     * Optional string property with a regex conditional
     */
    @SerialName(\\"optional string with regex\\")
    val optionalStringWithRegex: String? = null
)

/**
 * Validates that clients handle all of the supported field types, as required fields.
 */
@Serializable
data class EveryRequiredType (
    /**
     * Required any property
     */
    @SerialName(\\"required any\\")
    val requiredAny: JsonObject?,

    /**
     * Required array property
     */
    @SerialName(\\"required array\\")
    val requiredArray: JsonArray,

    /**
     * Required array with properties
     */
    @SerialName(\\"required array with properties\\")
    val requiredArrayWithProperties: List<RequiredArrayWithPropertyElement>,

    /**
     * Required boolean property
     */
    @SerialName(\\"required boolean\\")
    val requiredBoolean: Boolean,

    /**
     * Required integer property
     */
    @SerialName(\\"required int\\")
    val requiredInt: Long,

    /**
     * Required number property
     */
    @SerialName(\\"required number\\")
    val requiredNumber: Double,

    /**
     * Required object property
     */
    @SerialName(\\"required object\\")
    val requiredObject: JsonObject,

    /**
     * Required object with properties
     */
    @SerialName(\\"required object with properties\\")
    val requiredObjectWithProperties: EveryRequiredTypeRequiredObjectWithProperties,

    /**
     * Required string property
     */
    @SerialName(\\"required string\\")
    val requiredString: String,

    /**
     * Required string property with a regex conditional
     */
    @SerialName(\\"required string with regex\\")
    val requiredStringWithRegex: String
)

@Serializable
data class RequiredArrayWithPropertyElement (
    /**
     * Required any property
     */
    @SerialName(\\"required any\\")
    val requiredAny: JsonObject?,

    /**
     * Required array property
     */
    @SerialName(\\"required array\\")
    val requiredArray: JsonArray,

    /**
     * Required boolean property
     */
    @SerialName(\\"required boolean\\")
    val requiredBoolean: Boolean,

    /**
     * Required integer property
     */
    @SerialName(\\"required int\\")
    val requiredInt: Long,

    /**
     * Required number property
     */
    @SerialName(\\"required number\\")
    val requiredNumber: Double,

    /**
     * Required object property
     */
    @SerialName(\\"required object\\")
    val requiredObject: JsonObject,

    /**
     * Required string property
     */
    @SerialName(\\"required string\\")
    val requiredString: String,

    /**
     * Required string property with a regex conditional
     */
    @SerialName(\\"required string with regex\\")
    val requiredStringWithRegex: String
)

/**
 * Required object with properties
 */
@Serializable
data class EveryRequiredTypeRequiredObjectWithProperties (
    /**
     * Required any property
     */
    @SerialName(\\"required any\\")
    val requiredAny: JsonObject?,

    /**
     * Required array property
     */
    @SerialName(\\"required array\\")
    val requiredArray: JsonArray,

    /**
     * Required boolean property
     */
    @SerialName(\\"required boolean\\")
    val requiredBoolean: Boolean,

    /**
     * Required integer property
     */
    @SerialName(\\"required int\\")
    val requiredInt: Long,

    /**
     * Required number property
     */
    @SerialName(\\"required number\\")
    val requiredNumber: Double,

    /**
     * Required object property
     */
    @SerialName(\\"required object\\")
    val requiredObject: JsonObject,

    /**
     * Required string property
     */
    @SerialName(\\"required string\\")
    val requiredString: String,

    /**
     * Required string property with a regex conditional
     */
    @SerialName(\\"required string with regex\\")
    val requiredStringWithRegex: String
)

/**
 * Validates that clients correctly serialize large numbers (integers and floats).
 */
@Serializable
data class LargeNumbersEvent (
    @SerialName(\\"large nullable optional integer\\")
    val largeNullableOptionalInteger: Long? = null,

    @SerialName(\\"large nullable optional number\\")
    val largeNullableOptionalNumber: Double? = null,

    @SerialName(\\"large nullable required integer\\")
    val largeNullableRequiredInteger: Long? = null,

    @SerialName(\\"large nullable required number\\")
    val largeNullableRequiredNumber: Double? = null,

    @SerialName(\\"large optional integer\\")
    val largeOptionalInteger: Long? = null,

    @SerialName(\\"large optional number\\")
    val largeOptionalNumber: Double? = null,

    @SerialName(\\"large required integer\\")
    val largeRequiredInteger: Long,

    @SerialName(\\"large required number\\")
    val largeRequiredNumber: Double
)

/**
 * Validates that clients handle arrays-within-arrays.
 */
@Serializable
data class NestedArrays (
    /**
     * All known characters from each universe.
     */
    val universeCharacters: List<List<UniverseCharacter>>
)

@Serializable
data class UniverseCharacter (
    /**
     * The character's name.
     */
    val name: String
)

/**
 * Validates that clients handle objects-within-objects.
 */
@Serializable
data class NestedObjects (
    val garage: Garage
)

@Serializable
data class Garage (
    val tunnel: Tunnel
)

@Serializable
data class Tunnel (
    @SerialName(\\"subterranean lab\\")
    val subterraneanLab: SubterraneanLab
)

@Serializable
data class SubterraneanLab (
    @SerialName(\\"jerry's memories\\")
    val jerrySMemories: JsonArray? = null,

    @SerialName(\\"morty's memories\\")
    val mortySMemories: JsonArray? = null,

    @SerialName(\\"summer's contingency plan\\")
    val summerSContingencyPlan: String? = null
)

/**
 * Validates that clients handle collisions in property names within a single event.
 */
@Serializable
data class PropertiesCollided (
    @SerialName(\\"Property Collided\\")
    val propertyCollided: String,

    @SerialName(\\"property_collided\\")
    val propertiesCollidedPropertyCollided: String
)

/**
 * Validates that clients handle collisions in object names across multiple events.
 */
@Serializable
data class PropertyObjectNameCollision1 (
    val universe: PropertyObjectNameCollision1_Universe? = null
)

@Serializable
data class PropertyObjectNameCollision1_Universe (
    /**
     * The common name of this universe.
     */
    val name: String,

    /**
     * The most important occupants in this universe.
     */
    val occupants: List<PurpleOccupant>
)

@Serializable
data class PurpleOccupant (
    /**
     * The name of this occupant.
     */
    val name: String
)

/**
 * Validates that clients handle collisions in object names across multiple events.
 */
@Serializable
data class PropertyObjectNameCollision2 (
    val universe: PropertyObjectNameCollision2_Universe? = null
)

@Serializable
data class PropertyObjectNameCollision2_Universe (
    /**
     * The common name of this universe.
     */
    val name: String,

    /**
     * The most important occupants in this universe.
     */
    val occupants: List<FluffyOccupant>
)

@Serializable
data class FluffyOccupant (
    /**
     * The name of this occupant.
     */
    val name: String
)

/**
 * Validates that clients sanitize property names that contain invalid identifier characters.
 */
@Serializable
data class PropertySanitized (
    @SerialName(\\"0000---terrible-property-name~!3\\")
    val the0000TerriblePropertyName3: String
)

/**
 * Validates that clients support fields with various types of arrays.
 */
@Serializable
data class SimpleArrayTypes (
    val any: JsonArray? = null,
    val boolean: List<Boolean>? = null,
    val integer: List<Long>? = null,
    val nullable: List<String?>? = null,
    val number: List<Double>? = null,

    @SerialName(\\"object\\")
    val simpleArrayTypesObject: List<Object>? = null,

    val string: List<String>? = null
)

@Serializable
data class Object (
    val name: String? = null
)

/**
 * Validates that clients support fields with multiple (union) types.
 */
@Serializable
data class UnionType (
    @SerialName(\\"universe_name\\")
    val universeName: UniverseName
)

@Serializable
sealed class UniverseName {
    class IntegerValue(val value: Long)  : UniverseName()
    class StringValue(val value: String) : UniverseName()
    class NullValue()                    : UniverseName()
}

/**
 * Properties without IDs
 */
@Serializable
data class NoIDType (
    /**
     * a property without an ID
     */
    @SerialName(\\"no_id_prop\\")
    val noIDProp: String
)

fun Analytics.customViolationHandler(properties: CustomViolationHandler) {
    this.track(\\"Custom Violation Handler\\", properties)
}
fun Analytics.defaultViolationHandler(properties: DefaultViolationHandler) {
    this.track(\\"Default Violation Handler\\", properties)
}
fun Analytics.enumTypes(properties: EnumTypes) {
    this.track(\\"Enum Types\\", properties)
}
fun Analytics.everyNullableOptionalType(properties: EveryNullableOptionalType) {
    this.track(\\"Every Nullable Optional Type\\", properties)
}
fun Analytics.everyNullableRequiredType(properties: EveryNullableRequiredType) {
    this.track(\\"Every Nullable Required Type\\", properties)
}
fun Analytics.everyOptionalType(properties: EveryOptionalType) {
    this.track(\\"Every Optional Type\\", properties)
}
fun Analytics.everyRequiredType(properties: EveryRequiredType) {
    this.track(\\"Every Required Type\\", properties)
}
fun Analytics.largeNumbersEvent(properties: LargeNumbersEvent) {
    this.track(\\"Large Numbers Event\\", properties)
}
fun Analytics.nestedArrays(properties: NestedArrays) {
    this.track(\\"Nested Arrays\\", properties)
}
fun Analytics.nestedObjects(properties: NestedObjects) {
    this.track(\\"Nested Objects\\", properties)
}
fun Analytics.propertiesCollided(properties: PropertiesCollided) {
    this.track(\\"Properties Collided\\", properties)
}
fun Analytics.propertyObjectNameCollision1(properties: PropertyObjectNameCollision1) {
    this.track(\\"Property Object Name Collision #1\\", properties)
}
fun Analytics.propertyObjectNameCollision2(properties: PropertyObjectNameCollision2) {
    this.track(\\"Property Object Name Collision #2\\", properties)
}
fun Analytics.propertySanitized(properties: PropertySanitized) {
    this.track(\\"Property Sanitized\\", properties)
}
fun Analytics.simpleArrayTypes(properties: SimpleArrayTypes) {
    this.track(\\"Simple Array Types\\", properties)
}
fun Analytics.unionType(properties: UnionType) {
    this.track(\\"Union Type\\", properties)
}
fun Analytics.noIDType(properties: NoIDType) {
    this.track(\\"NoID type\\", properties)
}

"
`;

exports[`build builds client Language: swift, SDK:swift 1`] = `
"// This file was generated from JSON Schema using quicktype, do not modify it directly.
// To parse the JSON, add this file to your project and do:
//
//   let the42TerribleEventName3 = try The42_TerribleEventName3(json)
//   let analyticsInstanceMissing = try AnalyticsInstanceMissing(json)
//   let analyticsInstanceMissingThrewError = try AnalyticsInstanceMissingThrewError(json)
//   let customViolationHandler = try CustomViolationHandler(json)
//   let customViolationHandlerCalled = try CustomViolationHandlerCalled(json)
//   let defaultViolationHandler = try DefaultViolationHandler(json)
//   let defaultViolationHandlerCalled = try DefaultViolationHandlerCalled(json)
//   let emptyEvent = try EmptyEvent(json)
//   let enumTypes = try EnumTypes(json)
//   let eventCollided = try EventCollided(json)
//   let everyNullableOptionalType = try EveryNullableOptionalType(json)
//   let everyNullableRequiredType = try EveryNullableRequiredType(json)
//   let everyOptionalType = try EveryOptionalType(json)
//   let everyRequiredType = try EveryRequiredType(json)
//   let largeNumbersEvent = try LargeNumbersEvent(json)
//   let nestedArrays = try NestedArrays(json)
//   let nestedObjects = try NestedObjects(json)
//   let propertiesCollided = try PropertiesCollided(json)
//   let propertyObjectNameCollision1 = try PropertyObjectNameCollision1(json)
//   let propertyObjectNameCollision2 = try PropertyObjectNameCollision2(json)
//   let propertySanitized = try PropertySanitized(json)
//   let simpleArrayTypes = try SimpleArrayTypes(json)
//   let unionType = try UnionType(json)
//   let purpleEventCollided = try PurpleEventCollided(json)
//   let noIDType = try NoIDType(json)

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

import Foundation

/// This event is fired in order to trigger a custom violation handler. It should be called
/// with a JSON Schema violation.
// MARK: - CustomViolationHandler
struct CustomViolationHandler: Codable {
    let regexProperty: String

    enum CodingKeys: String, CodingKey {
        case regexProperty = \\"regex property\\"
    }
}

// MARK: CustomViolationHandler convenience initializers and mutators

extension CustomViolationHandler {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(CustomViolationHandler.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        regexProperty: String? = nil
    ) -> CustomViolationHandler {
        return CustomViolationHandler(
            regexProperty: regexProperty ?? self.regexProperty
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

/// This event is fired in order to trigger the default violation handler. It should be
/// called with a JSON Schema violation.
// MARK: - DefaultViolationHandler
struct DefaultViolationHandler: Codable {
    let regexProperty: String

    enum CodingKeys: String, CodingKey {
        case regexProperty = \\"regex property\\"
    }
}

// MARK: DefaultViolationHandler convenience initializers and mutators

extension DefaultViolationHandler {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(DefaultViolationHandler.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        regexProperty: String? = nil
    ) -> DefaultViolationHandler {
        return DefaultViolationHandler(
            regexProperty: regexProperty ?? self.regexProperty
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

/// Validates that client property sanitize enums.
// MARK: - EnumTypes
struct EnumTypes: Codable {
    /// A string property that only accepts a single enum value.
    let stringConst: StringConst?
    /// A string property that accepts multiple enum values.
    let stringEnum: StringEnum?

    enum CodingKeys: String, CodingKey {
        case stringConst = \\"string const\\"
        case stringEnum = \\"string enum\\"
    }
}

// MARK: EnumTypes convenience initializers and mutators

extension EnumTypes {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(EnumTypes.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        stringConst: StringConst?? = nil,
        stringEnum: StringEnum?? = nil
    ) -> EnumTypes {
        return EnumTypes(
            stringConst: stringConst ?? self.stringConst,
            stringEnum: stringEnum ?? self.stringEnum
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

/// A string property that only accepts a single enum value.
enum StringConst: String, Codable {
    case rickSanchez = \\"Rick Sanchez\\"
}

/// A string property that accepts multiple enum values.
enum StringEnum: String, Codable {
    case evilMorty = \\"Evil Morty\\"
    case lawyerMorty = \\"Lawyer Morty\\"
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

/// Validates that clients handle all of the supported field types, as nullable optional
/// fields. If a field is null, it is expected to be NOT sent through.
// MARK: - EveryNullableOptionalType
struct EveryNullableOptionalType: Codable {
    /// Optional any property
    let optionalAny: JSONAny?
    /// Optional array property
    let optionalArray: [JSONAny]?
    /// Optional array with properties
    let optionalArrayWithProperties: [EveryNullableOptionalTypeOptionalArrayWithProperty?]?
    /// Optional boolean property
    let optionalBoolean: Bool?
    /// Optional integer property
    let optionalInt: Int?
    /// Optional number property
    let optionalNumber: Double?
    /// Optional object property
    let optionalObject: [String: JSONAny]?
    /// Optional object with properties
    let optionalObjectWithProperties: EveryNullableOptionalTypeOptionalObjectWithProperties?
    /// Optional string property
    let optionalString: String?
    /// Optional string property with a regex conditional
    let optionalStringWithRegex: String?

    enum CodingKeys: String, CodingKey {
        case optionalAny = \\"optional any\\"
        case optionalArray = \\"optional array\\"
        case optionalArrayWithProperties = \\"optional array with properties\\"
        case optionalBoolean = \\"optional boolean\\"
        case optionalInt = \\"optional int\\"
        case optionalNumber = \\"optional number\\"
        case optionalObject = \\"optional object\\"
        case optionalObjectWithProperties = \\"optional object with properties\\"
        case optionalString = \\"optional string\\"
        case optionalStringWithRegex = \\"optional string with regex\\"
    }
}

// MARK: EveryNullableOptionalType convenience initializers and mutators

extension EveryNullableOptionalType {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(EveryNullableOptionalType.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        optionalAny: JSONAny?? = nil,
        optionalArray: [JSONAny]?? = nil,
        optionalArrayWithProperties: [EveryNullableOptionalTypeOptionalArrayWithProperty?]?? = nil,
        optionalBoolean: Bool?? = nil,
        optionalInt: Int?? = nil,
        optionalNumber: Double?? = nil,
        optionalObject: [String: JSONAny]?? = nil,
        optionalObjectWithProperties: EveryNullableOptionalTypeOptionalObjectWithProperties?? = nil,
        optionalString: String?? = nil,
        optionalStringWithRegex: String?? = nil
    ) -> EveryNullableOptionalType {
        return EveryNullableOptionalType(
            optionalAny: optionalAny ?? self.optionalAny,
            optionalArray: optionalArray ?? self.optionalArray,
            optionalArrayWithProperties: optionalArrayWithProperties ?? self.optionalArrayWithProperties,
            optionalBoolean: optionalBoolean ?? self.optionalBoolean,
            optionalInt: optionalInt ?? self.optionalInt,
            optionalNumber: optionalNumber ?? self.optionalNumber,
            optionalObject: optionalObject ?? self.optionalObject,
            optionalObjectWithProperties: optionalObjectWithProperties ?? self.optionalObjectWithProperties,
            optionalString: optionalString ?? self.optionalString,
            optionalStringWithRegex: optionalStringWithRegex ?? self.optionalStringWithRegex
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

// MARK: - EveryNullableOptionalTypeOptionalArrayWithProperty
struct EveryNullableOptionalTypeOptionalArrayWithProperty: Codable {
    /// Optional any property
    let optionalAny: JSONAny?
    /// Optional array property
    let optionalArray: [JSONAny]?
    /// Optional boolean property
    let optionalBoolean: Bool?
    /// Optional integer property
    let optionalInt: Int?
    /// Optional number property
    let optionalNumber: Double?
    /// Optional object property
    let optionalObject: [String: JSONAny]?
    /// Optional string property
    let optionalString: String?
    /// Optional string property with a regex conditional
    let optionalStringWithRegex: String?

    enum CodingKeys: String, CodingKey {
        case optionalAny = \\"optional any\\"
        case optionalArray = \\"optional array\\"
        case optionalBoolean = \\"optional boolean\\"
        case optionalInt = \\"optional int\\"
        case optionalNumber = \\"optional number\\"
        case optionalObject = \\"optional object\\"
        case optionalString = \\"optional string\\"
        case optionalStringWithRegex = \\"optional string with regex\\"
    }
}

// MARK: EveryNullableOptionalTypeOptionalArrayWithProperty convenience initializers and mutators

extension EveryNullableOptionalTypeOptionalArrayWithProperty {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(EveryNullableOptionalTypeOptionalArrayWithProperty.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        optionalAny: JSONAny?? = nil,
        optionalArray: [JSONAny]?? = nil,
        optionalBoolean: Bool?? = nil,
        optionalInt: Int?? = nil,
        optionalNumber: Double?? = nil,
        optionalObject: [String: JSONAny]?? = nil,
        optionalString: String?? = nil,
        optionalStringWithRegex: String?? = nil
    ) -> EveryNullableOptionalTypeOptionalArrayWithProperty {
        return EveryNullableOptionalTypeOptionalArrayWithProperty(
            optionalAny: optionalAny ?? self.optionalAny,
            optionalArray: optionalArray ?? self.optionalArray,
            optionalBoolean: optionalBoolean ?? self.optionalBoolean,
            optionalInt: optionalInt ?? self.optionalInt,
            optionalNumber: optionalNumber ?? self.optionalNumber,
            optionalObject: optionalObject ?? self.optionalObject,
            optionalString: optionalString ?? self.optionalString,
            optionalStringWithRegex: optionalStringWithRegex ?? self.optionalStringWithRegex
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

// MARK: - EveryNullableOptionalTypeOptionalObjectWithProperties
struct EveryNullableOptionalTypeOptionalObjectWithProperties: Codable {
    /// Optional any property
    let optionalAny: JSONAny?
    /// Optional array property
    let optionalArray: [JSONAny]?
    /// Optional boolean property
    let optionalBoolean: Bool?
    /// Optional integer property
    let optionalInt: Int?
    /// Optional number property
    let optionalNumber: Double?
    /// Optional object property
    let optionalObject: [String: JSONAny]?
    /// Optional string property
    let optionalString: String?
    /// Optional string property with a regex conditional
    let optionalStringWithRegex: String?

    enum CodingKeys: String, CodingKey {
        case optionalAny = \\"optional any\\"
        case optionalArray = \\"optional array\\"
        case optionalBoolean = \\"optional boolean\\"
        case optionalInt = \\"optional int\\"
        case optionalNumber = \\"optional number\\"
        case optionalObject = \\"optional object\\"
        case optionalString = \\"optional string\\"
        case optionalStringWithRegex = \\"optional string with regex\\"
    }
}

// MARK: EveryNullableOptionalTypeOptionalObjectWithProperties convenience initializers and mutators

extension EveryNullableOptionalTypeOptionalObjectWithProperties {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(EveryNullableOptionalTypeOptionalObjectWithProperties.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        optionalAny: JSONAny?? = nil,
        optionalArray: [JSONAny]?? = nil,
        optionalBoolean: Bool?? = nil,
        optionalInt: Int?? = nil,
        optionalNumber: Double?? = nil,
        optionalObject: [String: JSONAny]?? = nil,
        optionalString: String?? = nil,
        optionalStringWithRegex: String?? = nil
    ) -> EveryNullableOptionalTypeOptionalObjectWithProperties {
        return EveryNullableOptionalTypeOptionalObjectWithProperties(
            optionalAny: optionalAny ?? self.optionalAny,
            optionalArray: optionalArray ?? self.optionalArray,
            optionalBoolean: optionalBoolean ?? self.optionalBoolean,
            optionalInt: optionalInt ?? self.optionalInt,
            optionalNumber: optionalNumber ?? self.optionalNumber,
            optionalObject: optionalObject ?? self.optionalObject,
            optionalString: optionalString ?? self.optionalString,
            optionalStringWithRegex: optionalStringWithRegex ?? self.optionalStringWithRegex
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

/// Validates that clients handle all of the supported field types, as nullable required
/// fields. If a field is null, it is expected to be sent through.
// MARK: - EveryNullableRequiredType
struct EveryNullableRequiredType: Codable {
    /// Required any property
    let requiredAny: JSONAny
    /// Required array property
    let requiredArray: [JSONAny]?
    /// Required array with properties
    let requiredArrayWithProperties: [EveryNullableRequiredTypeRequiredArrayWithProperty?]?
    /// Required boolean property
    let requiredBoolean: Bool?
    /// Required integer property
    let requiredInt: Int?
    /// Required number property
    let requiredNumber: Double?
    /// Required object property
    let requiredObject: [String: JSONAny]?
    /// Required object with properties
    let requiredObjectWithProperties: EveryNullableRequiredTypeRequiredObjectWithProperties?
    /// Required string property
    let requiredString: String?
    /// Required string property with a regex conditional
    let requiredStringWithRegex: String?

    enum CodingKeys: String, CodingKey {
        case requiredAny = \\"required any\\"
        case requiredArray = \\"required array\\"
        case requiredArrayWithProperties = \\"required array with properties\\"
        case requiredBoolean = \\"required boolean\\"
        case requiredInt = \\"required int\\"
        case requiredNumber = \\"required number\\"
        case requiredObject = \\"required object\\"
        case requiredObjectWithProperties = \\"required object with properties\\"
        case requiredString = \\"required string\\"
        case requiredStringWithRegex = \\"required string with regex\\"
    }
}

// MARK: EveryNullableRequiredType convenience initializers and mutators

extension EveryNullableRequiredType {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(EveryNullableRequiredType.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        requiredAny: JSONAny? = nil,
        requiredArray: [JSONAny]?? = nil,
        requiredArrayWithProperties: [EveryNullableRequiredTypeRequiredArrayWithProperty?]?? = nil,
        requiredBoolean: Bool?? = nil,
        requiredInt: Int?? = nil,
        requiredNumber: Double?? = nil,
        requiredObject: [String: JSONAny]?? = nil,
        requiredObjectWithProperties: EveryNullableRequiredTypeRequiredObjectWithProperties?? = nil,
        requiredString: String?? = nil,
        requiredStringWithRegex: String?? = nil
    ) -> EveryNullableRequiredType {
        return EveryNullableRequiredType(
            requiredAny: requiredAny ?? self.requiredAny,
            requiredArray: requiredArray ?? self.requiredArray,
            requiredArrayWithProperties: requiredArrayWithProperties ?? self.requiredArrayWithProperties,
            requiredBoolean: requiredBoolean ?? self.requiredBoolean,
            requiredInt: requiredInt ?? self.requiredInt,
            requiredNumber: requiredNumber ?? self.requiredNumber,
            requiredObject: requiredObject ?? self.requiredObject,
            requiredObjectWithProperties: requiredObjectWithProperties ?? self.requiredObjectWithProperties,
            requiredString: requiredString ?? self.requiredString,
            requiredStringWithRegex: requiredStringWithRegex ?? self.requiredStringWithRegex
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

// MARK: - EveryNullableRequiredTypeRequiredArrayWithProperty
struct EveryNullableRequiredTypeRequiredArrayWithProperty: Codable {
    /// Required any property
    let requiredAny: JSONAny
    /// Required array property
    let requiredArray: [JSONAny]?
    /// Required boolean property
    let requiredBoolean: Bool?
    /// Required integer property
    let requiredInt: Int?
    /// Required number property
    let requiredNumber: Double?
    /// Required object property
    let requiredObject: [String: JSONAny]?
    /// Required string property
    let requiredString: String?
    /// Required string property with a regex conditional
    let requiredStringWithRegex: String?

    enum CodingKeys: String, CodingKey {
        case requiredAny = \\"required any\\"
        case requiredArray = \\"required array\\"
        case requiredBoolean = \\"required boolean\\"
        case requiredInt = \\"required int\\"
        case requiredNumber = \\"required number\\"
        case requiredObject = \\"required object\\"
        case requiredString = \\"required string\\"
        case requiredStringWithRegex = \\"required string with regex\\"
    }
}

// MARK: EveryNullableRequiredTypeRequiredArrayWithProperty convenience initializers and mutators

extension EveryNullableRequiredTypeRequiredArrayWithProperty {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(EveryNullableRequiredTypeRequiredArrayWithProperty.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        requiredAny: JSONAny? = nil,
        requiredArray: [JSONAny]?? = nil,
        requiredBoolean: Bool?? = nil,
        requiredInt: Int?? = nil,
        requiredNumber: Double?? = nil,
        requiredObject: [String: JSONAny]?? = nil,
        requiredString: String?? = nil,
        requiredStringWithRegex: String?? = nil
    ) -> EveryNullableRequiredTypeRequiredArrayWithProperty {
        return EveryNullableRequiredTypeRequiredArrayWithProperty(
            requiredAny: requiredAny ?? self.requiredAny,
            requiredArray: requiredArray ?? self.requiredArray,
            requiredBoolean: requiredBoolean ?? self.requiredBoolean,
            requiredInt: requiredInt ?? self.requiredInt,
            requiredNumber: requiredNumber ?? self.requiredNumber,
            requiredObject: requiredObject ?? self.requiredObject,
            requiredString: requiredString ?? self.requiredString,
            requiredStringWithRegex: requiredStringWithRegex ?? self.requiredStringWithRegex
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

// MARK: - EveryNullableRequiredTypeRequiredObjectWithProperties
struct EveryNullableRequiredTypeRequiredObjectWithProperties: Codable {
    /// Required any property
    let requiredAny: JSONAny
    /// Required array property
    let requiredArray: [JSONAny]?
    /// Required boolean property
    let requiredBoolean: Bool?
    /// Required integer property
    let requiredInt: Int?
    /// Required number property
    let requiredNumber: Double?
    /// Required object property
    let requiredObject: [String: JSONAny]?
    /// Required string property
    let requiredString: String?
    /// Required string property with a regex conditional
    let requiredStringWithRegex: String?

    enum CodingKeys: String, CodingKey {
        case requiredAny = \\"required any\\"
        case requiredArray = \\"required array\\"
        case requiredBoolean = \\"required boolean\\"
        case requiredInt = \\"required int\\"
        case requiredNumber = \\"required number\\"
        case requiredObject = \\"required object\\"
        case requiredString = \\"required string\\"
        case requiredStringWithRegex = \\"required string with regex\\"
    }
}

// MARK: EveryNullableRequiredTypeRequiredObjectWithProperties convenience initializers and mutators

extension EveryNullableRequiredTypeRequiredObjectWithProperties {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(EveryNullableRequiredTypeRequiredObjectWithProperties.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        requiredAny: JSONAny? = nil,
        requiredArray: [JSONAny]?? = nil,
        requiredBoolean: Bool?? = nil,
        requiredInt: Int?? = nil,
        requiredNumber: Double?? = nil,
        requiredObject: [String: JSONAny]?? = nil,
        requiredString: String?? = nil,
        requiredStringWithRegex: String?? = nil
    ) -> EveryNullableRequiredTypeRequiredObjectWithProperties {
        return EveryNullableRequiredTypeRequiredObjectWithProperties(
            requiredAny: requiredAny ?? self.requiredAny,
            requiredArray: requiredArray ?? self.requiredArray,
            requiredBoolean: requiredBoolean ?? self.requiredBoolean,
            requiredInt: requiredInt ?? self.requiredInt,
            requiredNumber: requiredNumber ?? self.requiredNumber,
            requiredObject: requiredObject ?? self.requiredObject,
            requiredString: requiredString ?? self.requiredString,
            requiredStringWithRegex: requiredStringWithRegex ?? self.requiredStringWithRegex
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

/// Validates that clients handle all of the supported field types, as optional fields.
// MARK: - EveryOptionalType
struct EveryOptionalType: Codable {
    /// Optional any property
    let optionalAny: JSONAny?
    /// Optional array property
    let optionalArray: [JSONAny]?
    /// Optional array with properties
    let optionalArrayWithProperties: [OptionalArrayWithPropertyElement]?
    /// Optional boolean property
    let optionalBoolean: Bool?
    /// Optional integer property
    let optionalInt: Int?
    /// Optional number property
    let optionalNumber: Double?
    /// Optional object property
    let optionalObject: [String: JSONAny]?
    /// Optional object with properties
    let optionalObjectWithProperties: EveryOptionalTypeOptionalObjectWithProperties?
    /// Optional string property
    let optionalString: String?
    /// Optional string property with a regex conditional
    let optionalStringWithRegex: String?

    enum CodingKeys: String, CodingKey {
        case optionalAny = \\"optional any\\"
        case optionalArray = \\"optional array\\"
        case optionalArrayWithProperties = \\"optional array with properties\\"
        case optionalBoolean = \\"optional boolean\\"
        case optionalInt = \\"optional int\\"
        case optionalNumber = \\"optional number\\"
        case optionalObject = \\"optional object\\"
        case optionalObjectWithProperties = \\"optional object with properties\\"
        case optionalString = \\"optional string\\"
        case optionalStringWithRegex = \\"optional string with regex\\"
    }
}

// MARK: EveryOptionalType convenience initializers and mutators

extension EveryOptionalType {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(EveryOptionalType.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        optionalAny: JSONAny?? = nil,
        optionalArray: [JSONAny]?? = nil,
        optionalArrayWithProperties: [OptionalArrayWithPropertyElement]?? = nil,
        optionalBoolean: Bool?? = nil,
        optionalInt: Int?? = nil,
        optionalNumber: Double?? = nil,
        optionalObject: [String: JSONAny]?? = nil,
        optionalObjectWithProperties: EveryOptionalTypeOptionalObjectWithProperties?? = nil,
        optionalString: String?? = nil,
        optionalStringWithRegex: String?? = nil
    ) -> EveryOptionalType {
        return EveryOptionalType(
            optionalAny: optionalAny ?? self.optionalAny,
            optionalArray: optionalArray ?? self.optionalArray,
            optionalArrayWithProperties: optionalArrayWithProperties ?? self.optionalArrayWithProperties,
            optionalBoolean: optionalBoolean ?? self.optionalBoolean,
            optionalInt: optionalInt ?? self.optionalInt,
            optionalNumber: optionalNumber ?? self.optionalNumber,
            optionalObject: optionalObject ?? self.optionalObject,
            optionalObjectWithProperties: optionalObjectWithProperties ?? self.optionalObjectWithProperties,
            optionalString: optionalString ?? self.optionalString,
            optionalStringWithRegex: optionalStringWithRegex ?? self.optionalStringWithRegex
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

// MARK: - OptionalArrayWithPropertyElement
struct OptionalArrayWithPropertyElement: Codable {
    /// Optional any property
    let optionalAny: JSONAny?
    /// Optional array property
    let optionalArray: [JSONAny]?
    /// Optional boolean property
    let optionalBoolean: Bool?
    /// Optional integer property
    let optionalInt: Int?
    /// Optional number property
    let optionalNumber: Double?
    /// Optional object property
    let optionalObject: [String: JSONAny]?
    /// Optional string property
    let optionalString: String?
    /// Optional string property with a regex conditional
    let optionalStringWithRegex: String?

    enum CodingKeys: String, CodingKey {
        case optionalAny = \\"optional any\\"
        case optionalArray = \\"optional array\\"
        case optionalBoolean = \\"optional boolean\\"
        case optionalInt = \\"optional int\\"
        case optionalNumber = \\"optional number\\"
        case optionalObject = \\"optional object\\"
        case optionalString = \\"optional string\\"
        case optionalStringWithRegex = \\"optional string with regex\\"
    }
}

// MARK: OptionalArrayWithPropertyElement convenience initializers and mutators

extension OptionalArrayWithPropertyElement {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(OptionalArrayWithPropertyElement.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        optionalAny: JSONAny?? = nil,
        optionalArray: [JSONAny]?? = nil,
        optionalBoolean: Bool?? = nil,
        optionalInt: Int?? = nil,
        optionalNumber: Double?? = nil,
        optionalObject: [String: JSONAny]?? = nil,
        optionalString: String?? = nil,
        optionalStringWithRegex: String?? = nil
    ) -> OptionalArrayWithPropertyElement {
        return OptionalArrayWithPropertyElement(
            optionalAny: optionalAny ?? self.optionalAny,
            optionalArray: optionalArray ?? self.optionalArray,
            optionalBoolean: optionalBoolean ?? self.optionalBoolean,
            optionalInt: optionalInt ?? self.optionalInt,
            optionalNumber: optionalNumber ?? self.optionalNumber,
            optionalObject: optionalObject ?? self.optionalObject,
            optionalString: optionalString ?? self.optionalString,
            optionalStringWithRegex: optionalStringWithRegex ?? self.optionalStringWithRegex
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

/// Optional object with properties
// MARK: - EveryOptionalTypeOptionalObjectWithProperties
struct EveryOptionalTypeOptionalObjectWithProperties: Codable {
    /// Optional any property
    let optionalAny: JSONAny?
    /// Optional array property
    let optionalArray: [JSONAny]?
    /// Optional boolean property
    let optionalBoolean: Bool?
    /// Optional integer property
    let optionalInt: Int?
    /// Optional number property
    let optionalNumber: Double?
    /// Optional object property
    let optionalObject: [String: JSONAny]?
    /// Optional string property
    let optionalString: String?
    /// Optional string property with a regex conditional
    let optionalStringWithRegex: String?

    enum CodingKeys: String, CodingKey {
        case optionalAny = \\"optional any\\"
        case optionalArray = \\"optional array\\"
        case optionalBoolean = \\"optional boolean\\"
        case optionalInt = \\"optional int\\"
        case optionalNumber = \\"optional number\\"
        case optionalObject = \\"optional object\\"
        case optionalString = \\"optional string\\"
        case optionalStringWithRegex = \\"optional string with regex\\"
    }
}

// MARK: EveryOptionalTypeOptionalObjectWithProperties convenience initializers and mutators

extension EveryOptionalTypeOptionalObjectWithProperties {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(EveryOptionalTypeOptionalObjectWithProperties.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        optionalAny: JSONAny?? = nil,
        optionalArray: [JSONAny]?? = nil,
        optionalBoolean: Bool?? = nil,
        optionalInt: Int?? = nil,
        optionalNumber: Double?? = nil,
        optionalObject: [String: JSONAny]?? = nil,
        optionalString: String?? = nil,
        optionalStringWithRegex: String?? = nil
    ) -> EveryOptionalTypeOptionalObjectWithProperties {
        return EveryOptionalTypeOptionalObjectWithProperties(
            optionalAny: optionalAny ?? self.optionalAny,
            optionalArray: optionalArray ?? self.optionalArray,
            optionalBoolean: optionalBoolean ?? self.optionalBoolean,
            optionalInt: optionalInt ?? self.optionalInt,
            optionalNumber: optionalNumber ?? self.optionalNumber,
            optionalObject: optionalObject ?? self.optionalObject,
            optionalString: optionalString ?? self.optionalString,
            optionalStringWithRegex: optionalStringWithRegex ?? self.optionalStringWithRegex
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

/// Validates that clients handle all of the supported field types, as required fields.
// MARK: - EveryRequiredType
struct EveryRequiredType: Codable {
    /// Required any property
    let requiredAny: JSONAny
    /// Required array property
    let requiredArray: [JSONAny]
    /// Required array with properties
    let requiredArrayWithProperties: [RequiredArrayWithPropertyElement]
    /// Required boolean property
    let requiredBoolean: Bool
    /// Required integer property
    let requiredInt: Int
    /// Required number property
    let requiredNumber: Double
    /// Required object property
    let requiredObject: [String: JSONAny]
    /// Required object with properties
    let requiredObjectWithProperties: EveryRequiredTypeRequiredObjectWithProperties
    /// Required string property
    let requiredString: String
    /// Required string property with a regex conditional
    let requiredStringWithRegex: String

    enum CodingKeys: String, CodingKey {
        case requiredAny = \\"required any\\"
        case requiredArray = \\"required array\\"
        case requiredArrayWithProperties = \\"required array with properties\\"
        case requiredBoolean = \\"required boolean\\"
        case requiredInt = \\"required int\\"
        case requiredNumber = \\"required number\\"
        case requiredObject = \\"required object\\"
        case requiredObjectWithProperties = \\"required object with properties\\"
        case requiredString = \\"required string\\"
        case requiredStringWithRegex = \\"required string with regex\\"
    }
}

// MARK: EveryRequiredType convenience initializers and mutators

extension EveryRequiredType {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(EveryRequiredType.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        requiredAny: JSONAny? = nil,
        requiredArray: [JSONAny]? = nil,
        requiredArrayWithProperties: [RequiredArrayWithPropertyElement]? = nil,
        requiredBoolean: Bool? = nil,
        requiredInt: Int? = nil,
        requiredNumber: Double? = nil,
        requiredObject: [String: JSONAny]? = nil,
        requiredObjectWithProperties: EveryRequiredTypeRequiredObjectWithProperties? = nil,
        requiredString: String? = nil,
        requiredStringWithRegex: String? = nil
    ) -> EveryRequiredType {
        return EveryRequiredType(
            requiredAny: requiredAny ?? self.requiredAny,
            requiredArray: requiredArray ?? self.requiredArray,
            requiredArrayWithProperties: requiredArrayWithProperties ?? self.requiredArrayWithProperties,
            requiredBoolean: requiredBoolean ?? self.requiredBoolean,
            requiredInt: requiredInt ?? self.requiredInt,
            requiredNumber: requiredNumber ?? self.requiredNumber,
            requiredObject: requiredObject ?? self.requiredObject,
            requiredObjectWithProperties: requiredObjectWithProperties ?? self.requiredObjectWithProperties,
            requiredString: requiredString ?? self.requiredString,
            requiredStringWithRegex: requiredStringWithRegex ?? self.requiredStringWithRegex
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

// MARK: - RequiredArrayWithPropertyElement
struct RequiredArrayWithPropertyElement: Codable {
    /// Required any property
    let requiredAny: JSONAny
    /// Required array property
    let requiredArray: [JSONAny]
    /// Required boolean property
    let requiredBoolean: Bool
    /// Required integer property
    let requiredInt: Int
    /// Required number property
    let requiredNumber: Double
    /// Required object property
    let requiredObject: [String: JSONAny]
    /// Required string property
    let requiredString: String
    /// Required string property with a regex conditional
    let requiredStringWithRegex: String

    enum CodingKeys: String, CodingKey {
        case requiredAny = \\"required any\\"
        case requiredArray = \\"required array\\"
        case requiredBoolean = \\"required boolean\\"
        case requiredInt = \\"required int\\"
        case requiredNumber = \\"required number\\"
        case requiredObject = \\"required object\\"
        case requiredString = \\"required string\\"
        case requiredStringWithRegex = \\"required string with regex\\"
    }
}

// MARK: RequiredArrayWithPropertyElement convenience initializers and mutators

extension RequiredArrayWithPropertyElement {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(RequiredArrayWithPropertyElement.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        requiredAny: JSONAny? = nil,
        requiredArray: [JSONAny]? = nil,
        requiredBoolean: Bool? = nil,
        requiredInt: Int? = nil,
        requiredNumber: Double? = nil,
        requiredObject: [String: JSONAny]? = nil,
        requiredString: String? = nil,
        requiredStringWithRegex: String? = nil
    ) -> RequiredArrayWithPropertyElement {
        return RequiredArrayWithPropertyElement(
            requiredAny: requiredAny ?? self.requiredAny,
            requiredArray: requiredArray ?? self.requiredArray,
            requiredBoolean: requiredBoolean ?? self.requiredBoolean,
            requiredInt: requiredInt ?? self.requiredInt,
            requiredNumber: requiredNumber ?? self.requiredNumber,
            requiredObject: requiredObject ?? self.requiredObject,
            requiredString: requiredString ?? self.requiredString,
            requiredStringWithRegex: requiredStringWithRegex ?? self.requiredStringWithRegex
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

/// Required object with properties
// MARK: - EveryRequiredTypeRequiredObjectWithProperties
struct EveryRequiredTypeRequiredObjectWithProperties: Codable {
    /// Required any property
    let requiredAny: JSONAny
    /// Required array property
    let requiredArray: [JSONAny]
    /// Required boolean property
    let requiredBoolean: Bool
    /// Required integer property
    let requiredInt: Int
    /// Required number property
    let requiredNumber: Double
    /// Required object property
    let requiredObject: [String: JSONAny]
    /// Required string property
    let requiredString: String
    /// Required string property with a regex conditional
    let requiredStringWithRegex: String

    enum CodingKeys: String, CodingKey {
        case requiredAny = \\"required any\\"
        case requiredArray = \\"required array\\"
        case requiredBoolean = \\"required boolean\\"
        case requiredInt = \\"required int\\"
        case requiredNumber = \\"required number\\"
        case requiredObject = \\"required object\\"
        case requiredString = \\"required string\\"
        case requiredStringWithRegex = \\"required string with regex\\"
    }
}

// MARK: EveryRequiredTypeRequiredObjectWithProperties convenience initializers and mutators

extension EveryRequiredTypeRequiredObjectWithProperties {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(EveryRequiredTypeRequiredObjectWithProperties.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        requiredAny: JSONAny? = nil,
        requiredArray: [JSONAny]? = nil,
        requiredBoolean: Bool? = nil,
        requiredInt: Int? = nil,
        requiredNumber: Double? = nil,
        requiredObject: [String: JSONAny]? = nil,
        requiredString: String? = nil,
        requiredStringWithRegex: String? = nil
    ) -> EveryRequiredTypeRequiredObjectWithProperties {
        return EveryRequiredTypeRequiredObjectWithProperties(
            requiredAny: requiredAny ?? self.requiredAny,
            requiredArray: requiredArray ?? self.requiredArray,
            requiredBoolean: requiredBoolean ?? self.requiredBoolean,
            requiredInt: requiredInt ?? self.requiredInt,
            requiredNumber: requiredNumber ?? self.requiredNumber,
            requiredObject: requiredObject ?? self.requiredObject,
            requiredString: requiredString ?? self.requiredString,
            requiredStringWithRegex: requiredStringWithRegex ?? self.requiredStringWithRegex
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

/// Validates that clients correctly serialize large numbers (integers and floats).
// MARK: - LargeNumbersEvent
struct LargeNumbersEvent: Codable {
    let largeNullableOptionalInteger: Int?
    let largeNullableOptionalNumber: Double?
    let largeNullableRequiredInteger: Int?
    let largeNullableRequiredNumber: Double?
    let largeOptionalInteger: Int?
    let largeOptionalNumber: Double?
    let largeRequiredInteger: Int
    let largeRequiredNumber: Double

    enum CodingKeys: String, CodingKey {
        case largeNullableOptionalInteger = \\"large nullable optional integer\\"
        case largeNullableOptionalNumber = \\"large nullable optional number\\"
        case largeNullableRequiredInteger = \\"large nullable required integer\\"
        case largeNullableRequiredNumber = \\"large nullable required number\\"
        case largeOptionalInteger = \\"large optional integer\\"
        case largeOptionalNumber = \\"large optional number\\"
        case largeRequiredInteger = \\"large required integer\\"
        case largeRequiredNumber = \\"large required number\\"
    }
}

// MARK: LargeNumbersEvent convenience initializers and mutators

extension LargeNumbersEvent {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(LargeNumbersEvent.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        largeNullableOptionalInteger: Int?? = nil,
        largeNullableOptionalNumber: Double?? = nil,
        largeNullableRequiredInteger: Int?? = nil,
        largeNullableRequiredNumber: Double?? = nil,
        largeOptionalInteger: Int?? = nil,
        largeOptionalNumber: Double?? = nil,
        largeRequiredInteger: Int? = nil,
        largeRequiredNumber: Double? = nil
    ) -> LargeNumbersEvent {
        return LargeNumbersEvent(
            largeNullableOptionalInteger: largeNullableOptionalInteger ?? self.largeNullableOptionalInteger,
            largeNullableOptionalNumber: largeNullableOptionalNumber ?? self.largeNullableOptionalNumber,
            largeNullableRequiredInteger: largeNullableRequiredInteger ?? self.largeNullableRequiredInteger,
            largeNullableRequiredNumber: largeNullableRequiredNumber ?? self.largeNullableRequiredNumber,
            largeOptionalInteger: largeOptionalInteger ?? self.largeOptionalInteger,
            largeOptionalNumber: largeOptionalNumber ?? self.largeOptionalNumber,
            largeRequiredInteger: largeRequiredInteger ?? self.largeRequiredInteger,
            largeRequiredNumber: largeRequiredNumber ?? self.largeRequiredNumber
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

/// Validates that clients handle arrays-within-arrays.
// MARK: - NestedArrays
struct NestedArrays: Codable {
    /// All known characters from each universe.
    let universeCharacters: [[UniverseCharacter]]
}

// MARK: NestedArrays convenience initializers and mutators

extension NestedArrays {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(NestedArrays.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        universeCharacters: [[UniverseCharacter]]? = nil
    ) -> NestedArrays {
        return NestedArrays(
            universeCharacters: universeCharacters ?? self.universeCharacters
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

// MARK: - UniverseCharacter
struct UniverseCharacter: Codable {
    /// The character's name.
    let name: String
}

// MARK: UniverseCharacter convenience initializers and mutators

extension UniverseCharacter {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(UniverseCharacter.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        name: String? = nil
    ) -> UniverseCharacter {
        return UniverseCharacter(
            name: name ?? self.name
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

/// Validates that clients handle objects-within-objects.
// MARK: - NestedObjects
struct NestedObjects: Codable {
    let garage: Garage
}

// MARK: NestedObjects convenience initializers and mutators

extension NestedObjects {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(NestedObjects.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        garage: Garage? = nil
    ) -> NestedObjects {
        return NestedObjects(
            garage: garage ?? self.garage
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

// MARK: - Garage
struct Garage: Codable {
    let tunnel: Tunnel
}

// MARK: Garage convenience initializers and mutators

extension Garage {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(Garage.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        tunnel: Tunnel? = nil
    ) -> Garage {
        return Garage(
            tunnel: tunnel ?? self.tunnel
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

// MARK: - Tunnel
struct Tunnel: Codable {
    let subterraneanLab: SubterraneanLab

    enum CodingKeys: String, CodingKey {
        case subterraneanLab = \\"subterranean lab\\"
    }
}

// MARK: Tunnel convenience initializers and mutators

extension Tunnel {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(Tunnel.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        subterraneanLab: SubterraneanLab? = nil
    ) -> Tunnel {
        return Tunnel(
            subterraneanLab: subterraneanLab ?? self.subterraneanLab
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

// MARK: - SubterraneanLab
struct SubterraneanLab: Codable {
    let jerrySMemories, mortySMemories: [JSONAny]?
    let summerSContingencyPlan: String?

    enum CodingKeys: String, CodingKey {
        case jerrySMemories = \\"jerry's memories\\"
        case mortySMemories = \\"morty's memories\\"
        case summerSContingencyPlan = \\"summer's contingency plan\\"
    }
}

// MARK: SubterraneanLab convenience initializers and mutators

extension SubterraneanLab {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(SubterraneanLab.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        jerrySMemories: [JSONAny]?? = nil,
        mortySMemories: [JSONAny]?? = nil,
        summerSContingencyPlan: String?? = nil
    ) -> SubterraneanLab {
        return SubterraneanLab(
            jerrySMemories: jerrySMemories ?? self.jerrySMemories,
            mortySMemories: mortySMemories ?? self.mortySMemories,
            summerSContingencyPlan: summerSContingencyPlan ?? self.summerSContingencyPlan
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

/// Validates that clients handle collisions in property names within a single event.
// MARK: - PropertiesCollided
struct PropertiesCollided: Codable {
    let propertyCollided, propertiesCollidedPropertyCollided: String

    enum CodingKeys: String, CodingKey {
        case propertyCollided = \\"Property Collided\\"
        case propertiesCollidedPropertyCollided = \\"property_collided\\"
    }
}

// MARK: PropertiesCollided convenience initializers and mutators

extension PropertiesCollided {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(PropertiesCollided.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        propertyCollided: String? = nil,
        propertiesCollidedPropertyCollided: String? = nil
    ) -> PropertiesCollided {
        return PropertiesCollided(
            propertyCollided: propertyCollided ?? self.propertyCollided,
            propertiesCollidedPropertyCollided: propertiesCollidedPropertyCollided ?? self.propertiesCollidedPropertyCollided
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

/// Validates that clients handle collisions in object names across multiple events.
// MARK: - PropertyObjectNameCollision1
struct PropertyObjectNameCollision1: Codable {
    let universe: PropertyObjectNameCollision1_Universe?
}

// MARK: PropertyObjectNameCollision1 convenience initializers and mutators

extension PropertyObjectNameCollision1 {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(PropertyObjectNameCollision1.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        universe: PropertyObjectNameCollision1_Universe?? = nil
    ) -> PropertyObjectNameCollision1 {
        return PropertyObjectNameCollision1(
            universe: universe ?? self.universe
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

// MARK: - PropertyObjectNameCollision1_Universe
struct PropertyObjectNameCollision1_Universe: Codable {
    /// The common name of this universe.
    let name: String
    /// The most important occupants in this universe.
    let occupants: [PurpleOccupant]
}

// MARK: PropertyObjectNameCollision1_Universe convenience initializers and mutators

extension PropertyObjectNameCollision1_Universe {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(PropertyObjectNameCollision1_Universe.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        name: String? = nil,
        occupants: [PurpleOccupant]? = nil
    ) -> PropertyObjectNameCollision1_Universe {
        return PropertyObjectNameCollision1_Universe(
            name: name ?? self.name,
            occupants: occupants ?? self.occupants
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

// MARK: - PurpleOccupant
struct PurpleOccupant: Codable {
    /// The name of this occupant.
    let name: String
}

// MARK: PurpleOccupant convenience initializers and mutators

extension PurpleOccupant {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(PurpleOccupant.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        name: String? = nil
    ) -> PurpleOccupant {
        return PurpleOccupant(
            name: name ?? self.name
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

/// Validates that clients handle collisions in object names across multiple events.
// MARK: - PropertyObjectNameCollision2
struct PropertyObjectNameCollision2: Codable {
    let universe: PropertyObjectNameCollision2_Universe?
}

// MARK: PropertyObjectNameCollision2 convenience initializers and mutators

extension PropertyObjectNameCollision2 {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(PropertyObjectNameCollision2.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        universe: PropertyObjectNameCollision2_Universe?? = nil
    ) -> PropertyObjectNameCollision2 {
        return PropertyObjectNameCollision2(
            universe: universe ?? self.universe
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

// MARK: - PropertyObjectNameCollision2_Universe
struct PropertyObjectNameCollision2_Universe: Codable {
    /// The common name of this universe.
    let name: String
    /// The most important occupants in this universe.
    let occupants: [FluffyOccupant]
}

// MARK: PropertyObjectNameCollision2_Universe convenience initializers and mutators

extension PropertyObjectNameCollision2_Universe {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(PropertyObjectNameCollision2_Universe.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        name: String? = nil,
        occupants: [FluffyOccupant]? = nil
    ) -> PropertyObjectNameCollision2_Universe {
        return PropertyObjectNameCollision2_Universe(
            name: name ?? self.name,
            occupants: occupants ?? self.occupants
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

// MARK: - FluffyOccupant
struct FluffyOccupant: Codable {
    /// The name of this occupant.
    let name: String
}

// MARK: FluffyOccupant convenience initializers and mutators

extension FluffyOccupant {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(FluffyOccupant.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        name: String? = nil
    ) -> FluffyOccupant {
        return FluffyOccupant(
            name: name ?? self.name
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

/// Validates that clients sanitize property names that contain invalid identifier characters.
// MARK: - PropertySanitized
struct PropertySanitized: Codable {
    let the0000TerriblePropertyName3: String

    enum CodingKeys: String, CodingKey {
        case the0000TerriblePropertyName3 = \\"0000---terrible-property-name~!3\\"
    }
}

// MARK: PropertySanitized convenience initializers and mutators

extension PropertySanitized {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(PropertySanitized.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        the0000TerriblePropertyName3: String? = nil
    ) -> PropertySanitized {
        return PropertySanitized(
            the0000TerriblePropertyName3: the0000TerriblePropertyName3 ?? self.the0000TerriblePropertyName3
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

/// Validates that clients support fields with various types of arrays.
// MARK: - SimpleArrayTypes
struct SimpleArrayTypes: Codable {
    let any: [JSONAny]?
    let boolean: [Bool]?
    let integer: [Int]?
    let nullable: [String?]?
    let number: [Double]?
    let object: [Object]?
    let string: [String]?
}

// MARK: SimpleArrayTypes convenience initializers and mutators

extension SimpleArrayTypes {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(SimpleArrayTypes.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        any: [JSONAny]?? = nil,
        boolean: [Bool]?? = nil,
        integer: [Int]?? = nil,
        nullable: [String?]?? = nil,
        number: [Double]?? = nil,
        object: [Object]?? = nil,
        string: [String]?? = nil
    ) -> SimpleArrayTypes {
        return SimpleArrayTypes(
            any: any ?? self.any,
            boolean: boolean ?? self.boolean,
            integer: integer ?? self.integer,
            nullable: nullable ?? self.nullable,
            number: number ?? self.number,
            object: object ?? self.object,
            string: string ?? self.string
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

// MARK: - Object
struct Object: Codable {
    let name: String?
}

// MARK: Object convenience initializers and mutators

extension Object {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(Object.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        name: String?? = nil
    ) -> Object {
        return Object(
            name: name ?? self.name
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

/// Validates that clients support fields with multiple (union) types.
// MARK: - UnionType
struct UnionType: Codable {
    let universeName: UniverseName

    enum CodingKeys: String, CodingKey {
        case universeName = \\"universe_name\\"
    }
}

// MARK: UnionType convenience initializers and mutators

extension UnionType {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(UnionType.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        universeName: UniverseName? = nil
    ) -> UnionType {
        return UnionType(
            universeName: universeName ?? self.universeName
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

enum UniverseName: Codable {
    case integer(Int)
    case string(String)
    case null

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let x = try? container.decode(Int.self) {
            self = .integer(x)
            return
        }
        if let x = try? container.decode(String.self) {
            self = .string(x)
            return
        }
        if container.decodeNil() {
            self = .null
            return
        }
        throw DecodingError.typeMismatch(UniverseName.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: \\"Wrong type for UniverseName\\"))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .integer(let x):
            try container.encode(x)
        case .string(let x):
            try container.encode(x)
        case .null:
            try container.encodeNil()
        }
    }
}

// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

/// Properties without IDs
// MARK: - NoIDType
struct NoIDType: Codable {
    /// a property without an ID
    let noIDProp: String

    enum CodingKeys: String, CodingKey {
        case noIDProp = \\"no_id_prop\\"
    }
}

// MARK: NoIDType convenience initializers and mutators

extension NoIDType {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(NoIDType.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func with(
        noIDProp: String? = nil
    ) -> NoIDType {
        return NoIDType(
            noIDProp: noIDProp ?? self.noIDProp
        )
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

typealias The42_TerribleEventName3 = [String: JSONAny]
typealias AnalyticsInstanceMissing = [String: JSONAny]
typealias AnalyticsInstanceMissingThrewError = [String: JSONAny]
typealias CustomViolationHandlerCalled = [String: JSONAny]
typealias DefaultViolationHandlerCalled = [String: JSONAny]
typealias EmptyEvent = [String: JSONAny]
typealias EventCollided = [String: JSONAny]
typealias PurpleEventCollided = [String: JSONAny]

extension Dictionary where Key == String, Value == JSONAny {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(The42_TerribleEventName3.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

extension Dictionary where Key == String, Value == JSONAny {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(AnalyticsInstanceMissing.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

extension Dictionary where Key == String, Value == JSONAny {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(AnalyticsInstanceMissingThrewError.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

extension Dictionary where Key == String, Value == JSONAny {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(CustomViolationHandlerCalled.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

extension Dictionary where Key == String, Value == JSONAny {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(DefaultViolationHandlerCalled.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

extension Dictionary where Key == String, Value == JSONAny {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(EmptyEvent.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

extension Dictionary where Key == String, Value == JSONAny {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(EventCollided.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

extension Dictionary where Key == String, Value == JSONAny {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(PurpleEventCollided.self, from: data)
    }

    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: \\"JSONDecoding\\", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }

    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }

    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }

    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

// MARK: - Helper functions for creating encoders and decoders

func newJSONDecoder() -> JSONDecoder {
    let decoder = JSONDecoder()
    if #available(iOS 10.0, OSX 10.12, tvOS 10.0, watchOS 3.0, *) {
        decoder.dateDecodingStrategy = .iso8601
    }
    return decoder
}

func newJSONEncoder() -> JSONEncoder {
    let encoder = JSONEncoder()
    if #available(iOS 10.0, OSX 10.12, tvOS 10.0, watchOS 3.0, *) {
        encoder.dateEncodingStrategy = .iso8601
    }
    return encoder
}

// MARK: - Encode/decode helpers

class JSONNull: Codable, Hashable {

    public static func == (lhs: JSONNull, rhs: JSONNull) -> Bool {
        return true
    }

    public var hashValue: Int {
        return 0
    }

    public init() {}

    public required init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if !container.decodeNil() {
            throw DecodingError.typeMismatch(JSONNull.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: \\"Wrong type for JSONNull\\"))
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encodeNil()
    }
}

class JSONCodingKey: CodingKey {
    let key: String

    required init?(intValue: Int) {
        return nil
    }

    required init?(stringValue: String) {
        key = stringValue
    }

    var intValue: Int? {
        return nil
    }

    var stringValue: String {
        return key
    }
}

class JSONAny: Codable {

    let value: Any

    static func decodingError(forCodingPath codingPath: [CodingKey]) -> DecodingError {
        let context = DecodingError.Context(codingPath: codingPath, debugDescription: \\"Cannot decode JSONAny\\")
        return DecodingError.typeMismatch(JSONAny.self, context)
    }

    static func encodingError(forValue value: Any, codingPath: [CodingKey]) -> EncodingError {
        let context = EncodingError.Context(codingPath: codingPath, debugDescription: \\"Cannot encode JSONAny\\")
        return EncodingError.invalidValue(value, context)
    }

    static func decode(from container: SingleValueDecodingContainer) throws -> Any {
        if let value = try? container.decode(Bool.self) {
            return value
        }
        if let value = try? container.decode(Int64.self) {
            return value
        }
        if let value = try? container.decode(Double.self) {
            return value
        }
        if let value = try? container.decode(String.self) {
            return value
        }
        if container.decodeNil() {
            return JSONNull()
        }
        throw decodingError(forCodingPath: container.codingPath)
    }

    static func decode(from container: inout UnkeyedDecodingContainer) throws -> Any {
        if let value = try? container.decode(Bool.self) {
            return value
        }
        if let value = try? container.decode(Int64.self) {
            return value
        }
        if let value = try? container.decode(Double.self) {
            return value
        }
        if let value = try? container.decode(String.self) {
            return value
        }
        if let value = try? container.decodeNil() {
            if value {
                return JSONNull()
            }
        }
        if var container = try? container.nestedUnkeyedContainer() {
            return try decodeArray(from: &container)
        }
        if var container = try? container.nestedContainer(keyedBy: JSONCodingKey.self) {
            return try decodeDictionary(from: &container)
        }
        throw decodingError(forCodingPath: container.codingPath)
    }

    static func decode(from container: inout KeyedDecodingContainer<JSONCodingKey>, forKey key: JSONCodingKey) throws -> Any {
        if let value = try? container.decode(Bool.self, forKey: key) {
            return value
        }
        if let value = try? container.decode(Int64.self, forKey: key) {
            return value
        }
        if let value = try? container.decode(Double.self, forKey: key) {
            return value
        }
        if let value = try? container.decode(String.self, forKey: key) {
            return value
        }
        if let value = try? container.decodeNil(forKey: key) {
            if value {
                return JSONNull()
            }
        }
        if var container = try? container.nestedUnkeyedContainer(forKey: key) {
            return try decodeArray(from: &container)
        }
        if var container = try? container.nestedContainer(keyedBy: JSONCodingKey.self, forKey: key) {
            return try decodeDictionary(from: &container)
        }
        throw decodingError(forCodingPath: container.codingPath)
    }

    static func decodeArray(from container: inout UnkeyedDecodingContainer) throws -> [Any] {
        var arr: [Any] = []
        while !container.isAtEnd {
            let value = try decode(from: &container)
            arr.append(value)
        }
        return arr
    }

    static func decodeDictionary(from container: inout KeyedDecodingContainer<JSONCodingKey>) throws -> [String: Any] {
        var dict = [String: Any]()
        for key in container.allKeys {
            let value = try decode(from: &container, forKey: key)
            dict[key.stringValue] = value
        }
        return dict
    }

    static func encode(to container: inout UnkeyedEncodingContainer, array: [Any]) throws {
        for value in array {
            if let value = value as? Bool {
                try container.encode(value)
            } else if let value = value as? Int64 {
                try container.encode(value)
            } else if let value = value as? Double {
                try container.encode(value)
            } else if let value = value as? String {
                try container.encode(value)
            } else if value is JSONNull {
                try container.encodeNil()
            } else if let value = value as? [Any] {
                var container = container.nestedUnkeyedContainer()
                try encode(to: &container, array: value)
            } else if let value = value as? [String: Any] {
                var container = container.nestedContainer(keyedBy: JSONCodingKey.self)
                try encode(to: &container, dictionary: value)
            } else {
                throw encodingError(forValue: value, codingPath: container.codingPath)
            }
        }
    }

    static func encode(to container: inout KeyedEncodingContainer<JSONCodingKey>, dictionary: [String: Any]) throws {
        for (key, value) in dictionary {
            let key = JSONCodingKey(stringValue: key)!
            if let value = value as? Bool {
                try container.encode(value, forKey: key)
            } else if let value = value as? Int64 {
                try container.encode(value, forKey: key)
            } else if let value = value as? Double {
                try container.encode(value, forKey: key)
            } else if let value = value as? String {
                try container.encode(value, forKey: key)
            } else if value is JSONNull {
                try container.encodeNil(forKey: key)
            } else if let value = value as? [Any] {
                var container = container.nestedUnkeyedContainer(forKey: key)
                try encode(to: &container, array: value)
            } else if let value = value as? [String: Any] {
                var container = container.nestedContainer(keyedBy: JSONCodingKey.self, forKey: key)
                try encode(to: &container, dictionary: value)
            } else {
                throw encodingError(forValue: value, codingPath: container.codingPath)
            }
        }
    }

    static func encode(to container: inout SingleValueEncodingContainer, value: Any) throws {
        if let value = value as? Bool {
            try container.encode(value)
        } else if let value = value as? Int64 {
            try container.encode(value)
        } else if let value = value as? Double {
            try container.encode(value)
        } else if let value = value as? String {
            try container.encode(value)
        } else if value is JSONNull {
            try container.encodeNil()
        } else {
            throw encodingError(forValue: value, codingPath: container.codingPath)
        }
    }

    public required init(from decoder: Decoder) throws {
        if var arrayContainer = try? decoder.unkeyedContainer() {
            self.value = try JSONAny.decodeArray(from: &arrayContainer)
        } else if var container = try? decoder.container(keyedBy: JSONCodingKey.self) {
            self.value = try JSONAny.decodeDictionary(from: &container)
        } else {
            let container = try decoder.singleValueContainer()
            self.value = try JSONAny.decode(from: container)
        }
    }

    public func encode(to encoder: Encoder) throws {
        if let arr = self.value as? [Any] {
            var container = encoder.unkeyedContainer()
            try JSONAny.encode(to: &container, array: arr)
        } else if let dict = self.value as? [String: Any] {
            var container = encoder.container(keyedBy: JSONCodingKey.self)
            try JSONAny.encode(to: &container, dictionary: dict)
        } else {
            var container = encoder.singleValueContainer()
            try JSONAny.encode(to: &container, value: self.value)
        }
    }
}

import Segment

extension Analytics {
    func customViolationHandler(_ properties: CustomViolationHandler) {
        self.track(name: \\"Custom Violation Handler\\", properties: properties)
    }
    func defaultViolationHandler(_ properties: DefaultViolationHandler) {
        self.track(name: \\"Default Violation Handler\\", properties: properties)
    }
    func enumTypes(_ properties: EnumTypes) {
        self.track(name: \\"Enum Types\\", properties: properties)
    }
    func everyNullableOptionalType(_ properties: EveryNullableOptionalType) {
        self.track(name: \\"Every Nullable Optional Type\\", properties: properties)
    }
    func everyNullableRequiredType(_ properties: EveryNullableRequiredType) {
        self.track(name: \\"Every Nullable Required Type\\", properties: properties)
    }
    func everyOptionalType(_ properties: EveryOptionalType) {
        self.track(name: \\"Every Optional Type\\", properties: properties)
    }
    func everyRequiredType(_ properties: EveryRequiredType) {
        self.track(name: \\"Every Required Type\\", properties: properties)
    }
    func largeNumbersEvent(_ properties: LargeNumbersEvent) {
        self.track(name: \\"Large Numbers Event\\", properties: properties)
    }
    func nestedArrays(_ properties: NestedArrays) {
        self.track(name: \\"Nested Arrays\\", properties: properties)
    }
    func nestedObjects(_ properties: NestedObjects) {
        self.track(name: \\"Nested Objects\\", properties: properties)
    }
    func propertiesCollided(_ properties: PropertiesCollided) {
        self.track(name: \\"Properties Collided\\", properties: properties)
    }
    func propertyObjectNameCollision1(_ properties: PropertyObjectNameCollision1) {
        self.track(name: \\"Property Object Name Collision #1\\", properties: properties)
    }
    func propertyObjectNameCollision2(_ properties: PropertyObjectNameCollision2) {
        self.track(name: \\"Property Object Name Collision #2\\", properties: properties)
    }
    func propertySanitized(_ properties: PropertySanitized) {
        self.track(name: \\"Property Sanitized\\", properties: properties)
    }
    func simpleArrayTypes(_ properties: SimpleArrayTypes) {
        self.track(name: \\"Simple Array Types\\", properties: properties)
    }
    func unionType(_ properties: UnionType) {
        self.track(name: \\"Union Type\\", properties: properties)
    }
    func noIDType(_ properties: NoIDType) {
        self.track(name: \\"NoID type\\", properties: properties)
    }
}

"
`;

exports[`build builds client Language: typescript, SDK:analytics-js 1`] = `
"// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

/**
 * This event is fired in order to trigger a custom violation handler. It should be called
 * with a JSON Schema violation.
 */
export interface CustomViolationHandler {
    \\"regex property\\": string;
}

/**
 * This event is fired in order to trigger the default violation handler. It should be
 * called with a JSON Schema violation.
 */
export interface DefaultViolationHandler {
    \\"regex property\\": string;
}

/**
 * Validates that client property sanitize enums.
 */
export interface EnumTypes {
    /**
     * A string property that only accepts a single enum value.
     */
    \\"string const\\"?: StringConst;
    /**
     * A string property that accepts multiple enum values.
     */
    \\"string enum\\"?: StringEnum;
}

/**
 * A string property that only accepts a single enum value.
 */
export enum StringConst {
    RickSanchez = \\"Rick Sanchez\\",
}

/**
 * A string property that accepts multiple enum values.
 */
export enum StringEnum {
    EvilMorty = \\"Evil Morty\\",
    LawyerMorty = \\"Lawyer Morty\\",
}

/**
 * Validates that clients handle all of the supported field types, as nullable optional
 * fields. If a field is null, it is expected to be NOT sent through.
 */
export interface EveryNullableOptionalType {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[] | null;
    /**
     * Optional array with properties
     */
    \\"optional array with properties\\"?: Array<null | EveryNullableOptionalTypeOptionalArrayWithProperty> | null;
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean | null;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number | null;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number | null;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any } | null;
    /**
     * Optional object with properties
     */
    \\"optional object with properties\\"?: null | EveryNullableOptionalTypeOptionalObjectWithProperties;
    /**
     * Optional string property
     */
    \\"optional string\\"?: null | string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: null | string;
}

export interface EveryNullableOptionalTypeOptionalArrayWithProperty {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[] | null;
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean | null;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number | null;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number | null;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any } | null;
    /**
     * Optional string property
     */
    \\"optional string\\"?: null | string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: null | string;
}

export interface EveryNullableOptionalTypeOptionalObjectWithProperties {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[] | null;
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean | null;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number | null;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number | null;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any } | null;
    /**
     * Optional string property
     */
    \\"optional string\\"?: null | string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: null | string;
}

/**
 * Validates that clients handle all of the supported field types, as nullable required
 * fields. If a field is null, it is expected to be sent through.
 */
export interface EveryNullableRequiredType {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[] | null;
    /**
     * Required array with properties
     */
    \\"required array with properties\\": Array<null | EveryNullableRequiredTypeRequiredArrayWithProperty> | null;
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean | null;
    /**
     * Required integer property
     */
    \\"required int\\": number | null;
    /**
     * Required number property
     */
    \\"required number\\": number | null;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any } | null;
    /**
     * Required object with properties
     */
    \\"required object with properties\\": null | EveryNullableRequiredTypeRequiredObjectWithProperties;
    /**
     * Required string property
     */
    \\"required string\\": null | string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": null | string;
}

export interface EveryNullableRequiredTypeRequiredArrayWithProperty {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[] | null;
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean | null;
    /**
     * Required integer property
     */
    \\"required int\\": number | null;
    /**
     * Required number property
     */
    \\"required number\\": number | null;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any } | null;
    /**
     * Required string property
     */
    \\"required string\\": null | string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": null | string;
}

export interface EveryNullableRequiredTypeRequiredObjectWithProperties {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[] | null;
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean | null;
    /**
     * Required integer property
     */
    \\"required int\\": number | null;
    /**
     * Required number property
     */
    \\"required number\\": number | null;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any } | null;
    /**
     * Required string property
     */
    \\"required string\\": null | string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": null | string;
}

/**
 * Validates that clients handle all of the supported field types, as optional fields.
 */
export interface EveryOptionalType {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[];
    /**
     * Optional array with properties
     */
    \\"optional array with properties\\"?: OptionalArrayWithPropertyElement[];
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any };
    /**
     * Optional object with properties
     */
    \\"optional object with properties\\"?: EveryOptionalTypeOptionalObjectWithProperties;
    /**
     * Optional string property
     */
    \\"optional string\\"?: string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: string;
}

export interface OptionalArrayWithPropertyElement {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[];
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any };
    /**
     * Optional string property
     */
    \\"optional string\\"?: string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: string;
}

/**
 * Optional object with properties
 */
export interface EveryOptionalTypeOptionalObjectWithProperties {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[];
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any };
    /**
     * Optional string property
     */
    \\"optional string\\"?: string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: string;
}

/**
 * Validates that clients handle all of the supported field types, as required fields.
 */
export interface EveryRequiredType {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[];
    /**
     * Required array with properties
     */
    \\"required array with properties\\": RequiredArrayWithPropertyElement[];
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean;
    /**
     * Required integer property
     */
    \\"required int\\": number;
    /**
     * Required number property
     */
    \\"required number\\": number;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any };
    /**
     * Required object with properties
     */
    \\"required object with properties\\": EveryRequiredTypeRequiredObjectWithProperties;
    /**
     * Required string property
     */
    \\"required string\\": string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": string;
}

export interface RequiredArrayWithPropertyElement {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[];
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean;
    /**
     * Required integer property
     */
    \\"required int\\": number;
    /**
     * Required number property
     */
    \\"required number\\": number;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any };
    /**
     * Required string property
     */
    \\"required string\\": string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": string;
}

/**
 * Required object with properties
 */
export interface EveryRequiredTypeRequiredObjectWithProperties {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[];
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean;
    /**
     * Required integer property
     */
    \\"required int\\": number;
    /**
     * Required number property
     */
    \\"required number\\": number;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any };
    /**
     * Required string property
     */
    \\"required string\\": string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": string;
}

/**
 * Validates that clients correctly serialize large numbers (integers and floats).
 */
export interface LargeNumbersEvent {
    \\"large nullable optional integer\\"?: number | null;
    \\"large nullable optional number\\"?:  number | null;
    \\"large nullable required integer\\":  number | null;
    \\"large nullable required number\\":   number | null;
    \\"large optional integer\\"?:          number;
    \\"large optional number\\"?:           number;
    \\"large required integer\\":           number;
    \\"large required number\\":            number;
}

/**
 * Validates that clients handle arrays-within-arrays.
 */
export interface NestedArrays {
    /**
     * All known characters from each universe.
     */
    universeCharacters: Array<UniverseCharacter[]>;
}

export interface UniverseCharacter {
    /**
     * The character's name.
     */
    name: string;
}

/**
 * Validates that clients handle objects-within-objects.
 */
export interface NestedObjects {
    garage: Garage;
}

export interface Garage {
    tunnel: Tunnel;
}

export interface Tunnel {
    \\"subterranean lab\\": SubterraneanLab;
}

export interface SubterraneanLab {
    \\"jerry's memories\\"?:          any[];
    \\"morty's memories\\"?:          any[];
    \\"summer's contingency plan\\"?: string;
}

/**
 * Validates that clients handle collisions in property names within a single event.
 */
export interface PropertiesCollided {
    \\"Property Collided\\": string;
    property_collided:   string;
}

/**
 * Validates that clients handle collisions in object names across multiple events.
 */
export interface PropertyObjectNameCollision1 {
    universe?: PropertyObjectNameCollision1_Universe;
}

export interface PropertyObjectNameCollision1_Universe {
    /**
     * The common name of this universe.
     */
    name: string;
    /**
     * The most important occupants in this universe.
     */
    occupants: PurpleOccupant[];
}

export interface PurpleOccupant {
    /**
     * The name of this occupant.
     */
    name: string;
}

/**
 * Validates that clients handle collisions in object names across multiple events.
 */
export interface PropertyObjectNameCollision2 {
    universe?: PropertyObjectNameCollision2_Universe;
}

export interface PropertyObjectNameCollision2_Universe {
    /**
     * The common name of this universe.
     */
    name: string;
    /**
     * The most important occupants in this universe.
     */
    occupants: FluffyOccupant[];
}

export interface FluffyOccupant {
    /**
     * The name of this occupant.
     */
    name: string;
}

/**
 * Validates that clients sanitize property names that contain invalid identifier characters.
 */
export interface PropertySanitized {
    \\"0000---terrible-property-name~!3\\": string;
}

/**
 * Validates that clients support fields with various types of arrays.
 */
export interface SimpleArrayTypes {
    any?:      any[];
    boolean?:  boolean[];
    integer?:  number[];
    nullable?: Array<null | string>;
    number?:   number[];
    object?:   Object[];
    string?:   string[];
}

export interface Object {
    name?: string;
}

/**
 * Validates that clients support fields with multiple (union) types.
 */
export interface UnionType {
    universe_name: number | null | string;
}

/**
 * Properties without IDs
 */
export interface NoIDType {
    /**
     * a property without an ID
     */
    no_id_prop: string;
}

/**
 * Ajv is a peer dependency for development builds. It's used to apply run-time validation
 * to message payloads before passing them on to the underlying analytics instance.
 *
 * Note that the production bundle does not depend on Ajv.
 * 
 * You can install it with: \`npm install --save-dev ajv\`.
 */
import Ajv, { ErrorObject } from 'ajv'

/**
 * The analytics.js snippet should be available via window.analytics.
 * You can install it by following instructions at: https://segment.com/docs/sources/website/analytics.js/quickstart/
 * Make sure to also include the TypeScript declarations with: \`npm install --dev @types/segment-analytics\`
 */
import type { AnalyticsSnippet, Analytics, AnalyticsBrowser, Options } from '@segment/analytics-next'

declare global {
    interface Window {
        analytics: AnalyticsSnippet;
    }
}

type AnyAnalytics = AnalyticsSnippet | Analytics | AnalyticsBrowser

/** The callback exposed by analytics.js. */
export type Callback = () => void

export type ViolationHandler = (
    message: Record<string, any>,
    violations: ErrorObject[]
) => void

/**
 * The default handler that is fired if none is supplied with setTypewriterOptions.
 * This handler will log a warning message to the console.
 */
export const defaultValidationErrorHandler: ViolationHandler = (message, violations) => {
    const msg = JSON.stringify(
        {
            type: 'Typewriter JSON Schema Validation Error',
            description:
                \`You made an analytics call (\${message.event}) using Typewriter that doesn't match the \` +
                'Tracking Plan spec.',
            errors: violations,
        },
        undefined,
        2,
    );

    console.warn(msg);
};

let onViolation = defaultValidationErrorHandler

let analytics: () => AnyAnalytics | undefined = () => {
    return window.analytics;
};

/** Options to customize the runtime behavior of a Typewriter client. */
export interface TypewriterOptions {
    /**
     * Underlying analytics instance where analytics calls are forwarded on to.
     * Defaults to window.analytics.
     */
    analytics?: AnyAnalytics;
    /**
     * Handler fired when if an event does not match its spec. This handler
     * does not fire in production mode, because it requires inlining the full
     * JSON Schema spec for each event in your Tracking Plan.
     *
     * By default, it will throw errors if NODE_ENV = \\"test\\" so that tests will fail
     * if a message does not match the spec. Otherwise, errors will be logged to stderr.
     */
    onViolation?: ViolationHandler;
}

/**
 * Updates the run-time configuration of this Typewriter client.
 *
 * @param {TypewriterOptions} options - the options to upsert
 *
 * @typedef {Object} TypewriterOptions
 * @property {AnyAnalytics} [analytics] - Underlying analytics instance where analytics
 * 		calls are forwarded on to. Defaults to window.analytics.
 * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
 * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
 * 		it will throw errors if NODE_ENV=\\"test\\" so that tests will fail if a message does not match the spec. Otherwise, errors
 * 		will be logged to stderr.
 */
export function setTypewriterOptions(options: TypewriterOptions) {
    analytics = options.analytics ? () => options.analytics || window.analytics : analytics;
    onViolation = options.onViolation || onViolation
}

/**
    * Validates a message against a JSON Schema using Ajv. If the message
    * is invalid, the \`onViolation\` handler will be called.
    */
function validateAgainstSchema(
    message: Record<string, any>,
    schema: object
) {
    const ajv = new Ajv({ allErrors: true, verbose: true })

    if (!ajv.validate(schema, message) && ajv.errors) {
        onViolation(message, ajv.errors)
    }
}

/**
 * Helper to attach metadata on Typewriter to outbound requests.
 * This is used for attribution and debugging by the Segment team.
 */
function withTypewriterContext(message: Options = {}): Options {
    return {
        ...message,
        context: {
            ...(message.context || {}),
            typewriter: {
                language: 'typescript',
                
            },
        },
    };
}

/**
 * Fires a 'CustomViolationHandler' track call.
 *
 * @param CustomViolationHandler props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 	call is fired.
 */
export function customViolationHandler(props: CustomViolationHandler, options?: Options, callback?: Callback): void {

    const schema = {\\"$id\\":\\"Custom_Violation_Handler\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"This event is fired in order to trigger a custom violation handler. It should be called with a JSON Schema violation.\\",\\"properties\\":{\\"regex property\\":{\\"$id\\":\\"/properties/regex%20property\\",\\"description\\":\\"\\",\\"pattern\\":\\"Lawyer Morty|Evil Morty\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"regex property\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(props, schema);

    const a = analytics();
    if (a) {
        a.track('Custom Violation Handler', props || {}, {...options,   context: {
            ...(options?.context || {}),
            typewriter: {
                language: 'typescript',
                version: '',
            },
        },}, callback);
    }
}
/**
 * Fires a 'DefaultViolationHandler' track call.
 *
 * @param DefaultViolationHandler props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 	call is fired.
 */
export function defaultViolationHandler(props: DefaultViolationHandler, options?: Options, callback?: Callback): void {

    const schema = {\\"$id\\":\\"Default_Violation_Handler\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"This event is fired in order to trigger the default violation handler. It should be called with a JSON Schema violation.\\",\\"properties\\":{\\"regex property\\":{\\"$id\\":\\"/properties/regex%20property\\",\\"description\\":\\"\\",\\"pattern\\":\\"Lawyer Morty|Evil Morty\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"regex property\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(props, schema);

    const a = analytics();
    if (a) {
        a.track('Default Violation Handler', props || {}, {...options,   context: {
            ...(options?.context || {}),
            typewriter: {
                language: 'typescript',
                version: '',
            },
        },}, callback);
    }
}
/**
 * Fires a 'EnumTypes' track call.
 *
 * @param EnumTypes props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 	call is fired.
 */
export function enumTypes(props: EnumTypes, options?: Options, callback?: Callback): void {

    const schema = {\\"$id\\":\\"Enum_Types\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Validates that client property sanitize enums.\\",\\"properties\\":{\\"string const\\":{\\"$id\\":\\"/properties/string%20const\\",\\"description\\":\\"A string property that only accepts a single enum value.\\",\\"enum\\":[\\"Rick Sanchez\\"],\\"type\\":\\"string\\"},\\"string enum\\":{\\"$id\\":\\"/properties/string%20enum\\",\\"description\\":\\"A string property that accepts multiple enum values.\\",\\"enum\\":[\\"Evil Morty\\",\\"Lawyer Morty\\"],\\"type\\":\\"string\\"}},\\"type\\":\\"object\\"};
    validateAgainstSchema(props, schema);

    const a = analytics();
    if (a) {
        a.track('Enum Types', props || {}, {...options,   context: {
            ...(options?.context || {}),
            typewriter: {
                language: 'typescript',
                version: '',
            },
        },}, callback);
    }
}
/**
 * Fires a 'EveryNullableOptionalType' track call.
 *
 * @param EveryNullableOptionalType props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 	call is fired.
 */
export function everyNullableOptionalType(props: EveryNullableOptionalType, options?: Options, callback?: Callback): void {

    const schema = {\\"$id\\":\\"Every_Nullable_Optional_Type\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Validates that clients handle all of the supported field types, as nullable optional fields. If a field is null, it is expected to be NOT sent through.\\",\\"properties\\":{\\"optional any\\":{\\"$id\\":\\"/properties/optional%20any\\",\\"description\\":\\"Optional any property\\"},\\"optional array\\":{\\"$id\\":\\"/properties/optional%20array\\",\\"description\\":\\"Optional array property\\",\\"type\\":[\\"array\\",\\"null\\"]},\\"optional array with properties\\":{\\"$id\\":\\"/properties/optional%20array%20with%20properties\\",\\"description\\":\\"Optional array with properties\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items\\",\\"properties\\":{\\"optional any\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20any\\",\\"description\\":\\"Optional any property\\"},\\"optional array\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20array\\",\\"description\\":\\"Optional array property\\",\\"type\\":[\\"array\\",\\"null\\"]},\\"optional boolean\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20boolean\\",\\"description\\":\\"Optional boolean property\\",\\"type\\":[\\"boolean\\",\\"null\\"]},\\"optional int\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20int\\",\\"description\\":\\"Optional integer property\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"optional number\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20number\\",\\"description\\":\\"Optional number property\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"optional object\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20object\\",\\"description\\":\\"Optional object property\\",\\"properties\\":{},\\"required\\":[],\\"type\\":[\\"object\\",\\"null\\"]},\\"optional string\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20string\\",\\"description\\":\\"Optional string property\\",\\"type\\":[\\"string\\",\\"null\\"]},\\"optional string with regex\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20string%20with%20regex\\",\\"description\\":\\"Optional string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":[\\"string\\",\\"null\\"]}},\\"type\\":[\\"object\\",\\"null\\"]},\\"type\\":[\\"array\\",\\"null\\"]},\\"optional boolean\\":{\\"$id\\":\\"/properties/optional%20boolean\\",\\"description\\":\\"Optional boolean property\\",\\"type\\":[\\"boolean\\",\\"null\\"]},\\"optional int\\":{\\"$id\\":\\"/properties/optional%20int\\",\\"description\\":\\"Optional integer property\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"optional number\\":{\\"$id\\":\\"/properties/optional%20number\\",\\"description\\":\\"Optional number property\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"optional object\\":{\\"$id\\":\\"/properties/optional%20object\\",\\"description\\":\\"Optional object property\\",\\"properties\\":{},\\"required\\":[],\\"type\\":[\\"object\\",\\"null\\"]},\\"optional object with properties\\":{\\"$id\\":\\"/properties/optional%20object%20with%20properties\\",\\"description\\":\\"Optional object with properties\\",\\"properties\\":{\\"optional any\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20any\\",\\"description\\":\\"Optional any property\\"},\\"optional array\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20array\\",\\"description\\":\\"Optional array property\\",\\"type\\":[\\"array\\",\\"null\\"]},\\"optional boolean\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20boolean\\",\\"description\\":\\"Optional boolean property\\",\\"type\\":[\\"boolean\\",\\"null\\"]},\\"optional int\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20int\\",\\"description\\":\\"Optional integer property\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"optional number\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20number\\",\\"description\\":\\"Optional number property\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"optional object\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20object\\",\\"description\\":\\"Optional object property\\",\\"properties\\":{},\\"required\\":[],\\"type\\":[\\"object\\",\\"null\\"]},\\"optional string\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20string\\",\\"description\\":\\"Optional string property\\",\\"type\\":[\\"string\\",\\"null\\"]},\\"optional string with regex\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20string%20with%20regex\\",\\"description\\":\\"Optional string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":[\\"string\\",\\"null\\"]}},\\"required\\":[],\\"type\\":[\\"object\\",\\"null\\"]},\\"optional string\\":{\\"$id\\":\\"/properties/optional%20string\\",\\"description\\":\\"Optional string property\\",\\"type\\":[\\"string\\",\\"null\\"]},\\"optional string with regex\\":{\\"$id\\":\\"/properties/optional%20string%20with%20regex\\",\\"description\\":\\"Optional string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":[\\"string\\",\\"null\\"]}},\\"type\\":\\"object\\"};
    validateAgainstSchema(props, schema);

    const a = analytics();
    if (a) {
        a.track('Every Nullable Optional Type', props || {}, {...options,   context: {
            ...(options?.context || {}),
            typewriter: {
                language: 'typescript',
                version: '',
            },
        },}, callback);
    }
}
/**
 * Fires a 'EveryNullableRequiredType' track call.
 *
 * @param EveryNullableRequiredType props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 	call is fired.
 */
export function everyNullableRequiredType(props: EveryNullableRequiredType, options?: Options, callback?: Callback): void {

    const schema = {\\"$id\\":\\"Every_Nullable_Required_Type\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Validates that clients handle all of the supported field types, as nullable required fields. If a field is null, it is expected to be sent through.\\",\\"properties\\":{\\"required any\\":{\\"$id\\":\\"/properties/required%20any\\",\\"description\\":\\"Required any property\\"},\\"required array\\":{\\"$id\\":\\"/properties/required%20array\\",\\"description\\":\\"Required array property\\",\\"type\\":[\\"array\\",\\"null\\"]},\\"required array with properties\\":{\\"$id\\":\\"/properties/required%20array%20with%20properties\\",\\"description\\":\\"Required array with properties\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items\\",\\"properties\\":{\\"required any\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20any\\",\\"description\\":\\"Required any property\\"},\\"required array\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20array\\",\\"description\\":\\"Required array property\\",\\"type\\":[\\"array\\",\\"null\\"]},\\"required boolean\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20boolean\\",\\"description\\":\\"Required boolean property\\",\\"type\\":[\\"boolean\\",\\"null\\"]},\\"required int\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20int\\",\\"description\\":\\"Required integer property\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"required number\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20number\\",\\"description\\":\\"Required number property\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"required object\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20object\\",\\"description\\":\\"Required object property\\",\\"properties\\":{},\\"required\\":[],\\"type\\":[\\"object\\",\\"null\\"]},\\"required string\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20string\\",\\"description\\":\\"Required string property\\",\\"type\\":[\\"string\\",\\"null\\"]},\\"required string with regex\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20string%20with%20regex\\",\\"description\\":\\"Required string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":[\\"string\\",\\"null\\"]}},\\"required\\":[\\"required any\\",\\"required array\\",\\"required boolean\\",\\"required int\\",\\"required number\\",\\"required object\\",\\"required string\\",\\"required string with regex\\"],\\"type\\":[\\"object\\",\\"null\\"]},\\"type\\":[\\"array\\",\\"null\\"]},\\"required boolean\\":{\\"$id\\":\\"/properties/required%20boolean\\",\\"description\\":\\"Required boolean property\\",\\"type\\":[\\"boolean\\",\\"null\\"]},\\"required int\\":{\\"$id\\":\\"/properties/required%20int\\",\\"description\\":\\"Required integer property\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"required number\\":{\\"$id\\":\\"/properties/required%20number\\",\\"description\\":\\"Required number property\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"required object\\":{\\"$id\\":\\"/properties/required%20object\\",\\"description\\":\\"Required object property\\",\\"properties\\":{},\\"required\\":[],\\"type\\":[\\"object\\",\\"null\\"]},\\"required object with properties\\":{\\"$id\\":\\"/properties/required%20object%20with%20properties\\",\\"description\\":\\"Required object with properties\\",\\"properties\\":{\\"required any\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20any\\",\\"description\\":\\"Required any property\\"},\\"required array\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20array\\",\\"description\\":\\"Required array property\\",\\"type\\":[\\"array\\",\\"null\\"]},\\"required boolean\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20boolean\\",\\"description\\":\\"Required boolean property\\",\\"type\\":[\\"boolean\\",\\"null\\"]},\\"required int\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20int\\",\\"description\\":\\"Required integer property\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"required number\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20number\\",\\"description\\":\\"Required number property\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"required object\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20object\\",\\"description\\":\\"Required object property\\",\\"properties\\":{},\\"required\\":[],\\"type\\":[\\"object\\",\\"null\\"]},\\"required string\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20string\\",\\"description\\":\\"Required string property\\",\\"type\\":[\\"string\\",\\"null\\"]},\\"required string with regex\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20string%20with%20regex\\",\\"description\\":\\"Required string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":[\\"string\\",\\"null\\"]}},\\"required\\":[\\"required any\\",\\"required array\\",\\"required boolean\\",\\"required int\\",\\"required number\\",\\"required object\\",\\"required string\\",\\"required string with regex\\"],\\"type\\":[\\"object\\",\\"null\\"]},\\"required string\\":{\\"$id\\":\\"/properties/required%20string\\",\\"description\\":\\"Required string property\\",\\"type\\":[\\"string\\",\\"null\\"]},\\"required string with regex\\":{\\"$id\\":\\"/properties/required%20string%20with%20regex\\",\\"description\\":\\"Required string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":[\\"string\\",\\"null\\"]}},\\"required\\":[\\"required any\\",\\"required array\\",\\"required boolean\\",\\"required int\\",\\"required number\\",\\"required object\\",\\"required string\\",\\"required string with regex\\",\\"required object with properties\\",\\"required array with properties\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(props, schema);

    const a = analytics();
    if (a) {
        a.track('Every Nullable Required Type', props || {}, {...options,   context: {
            ...(options?.context || {}),
            typewriter: {
                language: 'typescript',
                version: '',
            },
        },}, callback);
    }
}
/**
 * Fires a 'EveryOptionalType' track call.
 *
 * @param EveryOptionalType props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 	call is fired.
 */
export function everyOptionalType(props: EveryOptionalType, options?: Options, callback?: Callback): void {

    const schema = {\\"$id\\":\\"Every_Optional_Type\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Validates that clients handle all of the supported field types, as optional fields.\\",\\"properties\\":{\\"optional any\\":{\\"$id\\":\\"/properties/optional%20any\\",\\"description\\":\\"Optional any property\\"},\\"optional array\\":{\\"$id\\":\\"/properties/optional%20array\\",\\"description\\":\\"Optional array property\\",\\"type\\":\\"array\\"},\\"optional array with properties\\":{\\"$id\\":\\"/properties/optional%20array%20with%20properties\\",\\"description\\":\\"Optional array with properties\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items\\",\\"properties\\":{\\"optional any\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20any\\",\\"description\\":\\"Optional any property\\"},\\"optional array\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20array\\",\\"description\\":\\"Optional array property\\",\\"type\\":\\"array\\"},\\"optional boolean\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20boolean\\",\\"description\\":\\"Optional boolean property\\",\\"type\\":\\"boolean\\"},\\"optional int\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20int\\",\\"description\\":\\"Optional integer property\\",\\"type\\":\\"integer\\"},\\"optional number\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20number\\",\\"description\\":\\"Optional number property\\",\\"type\\":\\"number\\"},\\"optional object\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20object\\",\\"description\\":\\"Optional object property\\",\\"key\\":\\"optional object\\",\\"properties\\":{},\\"type\\":\\"object\\"},\\"optional string\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20string\\",\\"description\\":\\"Optional string property\\",\\"type\\":\\"string\\"},\\"optional string with regex\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20string%20with%20regex\\",\\"description\\":\\"Optional string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":\\"string\\"}},\\"type\\":\\"object\\"},\\"type\\":\\"array\\"},\\"optional boolean\\":{\\"$id\\":\\"/properties/optional%20boolean\\",\\"description\\":\\"Optional boolean property\\",\\"type\\":\\"boolean\\"},\\"optional int\\":{\\"$id\\":\\"/properties/optional%20int\\",\\"description\\":\\"Optional integer property\\",\\"type\\":\\"integer\\"},\\"optional number\\":{\\"$id\\":\\"/properties/optional%20number\\",\\"description\\":\\"Optional number property\\",\\"type\\":\\"number\\"},\\"optional object\\":{\\"$id\\":\\"/properties/optional%20object\\",\\"description\\":\\"Optional object property\\",\\"key\\":\\"optional object\\",\\"properties\\":{},\\"type\\":\\"object\\"},\\"optional object with properties\\":{\\"$id\\":\\"/properties/optional%20object%20with%20properties\\",\\"description\\":\\"Optional object with properties\\",\\"properties\\":{\\"optional any\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20any\\",\\"description\\":\\"Optional any property\\"},\\"optional array\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20array\\",\\"description\\":\\"Optional array property\\",\\"type\\":\\"array\\"},\\"optional boolean\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20boolean\\",\\"description\\":\\"Optional boolean property\\",\\"type\\":\\"boolean\\"},\\"optional int\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20int\\",\\"description\\":\\"Optional integer property\\",\\"type\\":\\"integer\\"},\\"optional number\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20number\\",\\"description\\":\\"Optional number property\\",\\"type\\":\\"number\\"},\\"optional object\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20object\\",\\"description\\":\\"Optional object property\\",\\"key\\":\\"optional object\\",\\"properties\\":{},\\"type\\":\\"object\\"},\\"optional string\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20string\\",\\"description\\":\\"Optional string property\\",\\"type\\":\\"string\\"},\\"optional string with regex\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20string%20with%20regex\\",\\"description\\":\\"Optional string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":\\"string\\"}},\\"type\\":\\"object\\"},\\"optional string\\":{\\"$id\\":\\"/properties/optional%20string\\",\\"description\\":\\"Optional string property\\",\\"type\\":\\"string\\"},\\"optional string with regex\\":{\\"$id\\":\\"/properties/optional%20string%20with%20regex\\",\\"description\\":\\"Optional string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":\\"string\\"}},\\"type\\":\\"object\\"};
    validateAgainstSchema(props, schema);

    const a = analytics();
    if (a) {
        a.track('Every Optional Type', props || {}, {...options,   context: {
            ...(options?.context || {}),
            typewriter: {
                language: 'typescript',
                version: '',
            },
        },}, callback);
    }
}
/**
 * Fires a 'EveryRequiredType' track call.
 *
 * @param EveryRequiredType props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 	call is fired.
 */
export function everyRequiredType(props: EveryRequiredType, options?: Options, callback?: Callback): void {

    const schema = {\\"$id\\":\\"Every_Required_Type\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Validates that clients handle all of the supported field types, as required fields. \\",\\"properties\\":{\\"required any\\":{\\"$id\\":\\"/properties/required%20any\\",\\"description\\":\\"Required any property\\"},\\"required array\\":{\\"$id\\":\\"/properties/required%20array\\",\\"description\\":\\"Required array property\\",\\"type\\":\\"array\\"},\\"required array with properties\\":{\\"$id\\":\\"/properties/required%20array%20with%20properties\\",\\"description\\":\\"Required array with properties\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items\\",\\"properties\\":{\\"required any\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20any\\",\\"description\\":\\"Required any property\\"},\\"required array\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20array\\",\\"description\\":\\"Required array property\\",\\"type\\":\\"array\\"},\\"required boolean\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20boolean\\",\\"description\\":\\"Required boolean property\\",\\"type\\":\\"boolean\\"},\\"required int\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20int\\",\\"description\\":\\"Required integer property\\",\\"type\\":\\"integer\\"},\\"required number\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20number\\",\\"description\\":\\"Required number property\\",\\"type\\":\\"number\\"},\\"required object\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20object\\",\\"description\\":\\"Required object property\\",\\"key\\":\\"required object\\",\\"properties\\":{},\\"required\\":[],\\"type\\":\\"object\\"},\\"required string\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20string\\",\\"description\\":\\"Required string property\\",\\"type\\":\\"string\\"},\\"required string with regex\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20string%20with%20regex\\",\\"description\\":\\"Required string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"required any\\",\\"required array\\",\\"required boolean\\",\\"required int\\",\\"required number\\",\\"required object\\",\\"required string\\",\\"required string with regex\\"],\\"type\\":\\"object\\"},\\"type\\":\\"array\\"},\\"required boolean\\":{\\"$id\\":\\"/properties/required%20boolean\\",\\"description\\":\\"Required boolean property\\",\\"type\\":\\"boolean\\"},\\"required int\\":{\\"$id\\":\\"/properties/required%20int\\",\\"description\\":\\"Required integer property\\",\\"type\\":\\"integer\\"},\\"required number\\":{\\"$id\\":\\"/properties/required%20number\\",\\"description\\":\\"Required number property\\",\\"type\\":\\"number\\"},\\"required object\\":{\\"$id\\":\\"/properties/required%20object\\",\\"description\\":\\"Required object property\\",\\"key\\":\\"required object\\",\\"properties\\":{},\\"required\\":[],\\"type\\":\\"object\\"},\\"required object with properties\\":{\\"$id\\":\\"/properties/required%20object%20with%20properties\\",\\"description\\":\\"Required object with properties\\",\\"properties\\":{\\"required any\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20any\\",\\"description\\":\\"Required any property\\"},\\"required array\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20array\\",\\"description\\":\\"Required array property\\",\\"type\\":\\"array\\"},\\"required boolean\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20boolean\\",\\"description\\":\\"Required boolean property\\",\\"type\\":\\"boolean\\"},\\"required int\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20int\\",\\"description\\":\\"Required integer property\\",\\"type\\":\\"integer\\"},\\"required number\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20number\\",\\"description\\":\\"Required number property\\",\\"type\\":\\"number\\"},\\"required object\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20object\\",\\"description\\":\\"Required object property\\",\\"key\\":\\"required object\\",\\"properties\\":{},\\"required\\":[],\\"type\\":\\"object\\"},\\"required string\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20string\\",\\"description\\":\\"Required string property\\",\\"type\\":\\"string\\"},\\"required string with regex\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20string%20with%20regex\\",\\"description\\":\\"Required string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"required any\\",\\"required array\\",\\"required boolean\\",\\"required int\\",\\"required number\\",\\"required object\\",\\"required string\\",\\"required string with regex\\"],\\"type\\":\\"object\\"},\\"required string\\":{\\"$id\\":\\"/properties/required%20string\\",\\"description\\":\\"Required string property\\",\\"type\\":\\"string\\"},\\"required string with regex\\":{\\"$id\\":\\"/properties/required%20string%20with%20regex\\",\\"description\\":\\"Required string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"required any\\",\\"required array\\",\\"required boolean\\",\\"required int\\",\\"required number\\",\\"required object\\",\\"required string\\",\\"required string with regex\\",\\"required object with properties\\",\\"required array with properties\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(props, schema);

    const a = analytics();
    if (a) {
        a.track('Every Required Type', props || {}, {...options,   context: {
            ...(options?.context || {}),
            typewriter: {
                language: 'typescript',
                version: '',
            },
        },}, callback);
    }
}
/**
 * Fires a 'LargeNumbersEvent' track call.
 *
 * @param LargeNumbersEvent props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 	call is fired.
 */
export function largeNumbersEvent(props: LargeNumbersEvent, options?: Options, callback?: Callback): void {

    const schema = {\\"$id\\":\\"Large_Numbers_Event\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Validates that clients correctly serialize large numbers (integers and floats).\\",\\"properties\\":{\\"large nullable optional integer\\":{\\"$id\\":\\"/properties/large%20nullable%20optional%20integer\\",\\"description\\":\\"\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"large nullable optional number\\":{\\"$id\\":\\"/properties/large%20nullable%20optional%20number\\",\\"description\\":\\"\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"large nullable required integer\\":{\\"$id\\":\\"/properties/large%20nullable%20required%20integer\\",\\"description\\":\\"\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"large nullable required number\\":{\\"$id\\":\\"/properties/large%20nullable%20required%20number\\",\\"description\\":\\"\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"large optional integer\\":{\\"$id\\":\\"/properties/large%20optional%20integer\\",\\"description\\":\\"\\",\\"type\\":\\"integer\\"},\\"large optional number\\":{\\"$id\\":\\"/properties/large%20optional%20number\\",\\"description\\":\\"\\",\\"type\\":\\"number\\"},\\"large required integer\\":{\\"$id\\":\\"/properties/large%20required%20integer\\",\\"description\\":\\"\\",\\"type\\":\\"integer\\"},\\"large required number\\":{\\"$id\\":\\"/properties/large%20required%20number\\",\\"description\\":\\"\\",\\"type\\":\\"number\\"}},\\"required\\":[\\"large required integer\\",\\"large required number\\",\\"large nullable required integer\\",\\"large nullable required number\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(props, schema);

    const a = analytics();
    if (a) {
        a.track('Large Numbers Event', props || {}, {...options,   context: {
            ...(options?.context || {}),
            typewriter: {
                language: 'typescript',
                version: '',
            },
        },}, callback);
    }
}
/**
 * Fires a 'NestedArrays' track call.
 *
 * @param NestedArrays props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 	call is fired.
 */
export function nestedArrays(props: NestedArrays, options?: Options, callback?: Callback): void {

    const schema = {\\"$id\\":\\"Nested_Arrays\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Validates that clients handle arrays-within-arrays.\\",\\"properties\\":{\\"universeCharacters\\":{\\"$id\\":\\"/properties/universeCharacters\\",\\"description\\":\\"All known characters from each universe.\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/universeCharacters/items\\",\\"description\\":\\"\\",\\"items\\":{\\"description\\":\\"\\",\\"id\\":\\"/properties/properties/properties/universeCharacters/items/items\\",\\"properties\\":{\\"name\\":{\\"description\\":\\"The character's name.\\",\\"id\\":\\"/properties/properties/properties/universeCharacters/items/items/properties/name\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"name\\"],\\"type\\":\\"object\\"},\\"type\\":\\"array\\"},\\"type\\":\\"array\\"}},\\"required\\":[\\"universeCharacters\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(props, schema);

    const a = analytics();
    if (a) {
        a.track('Nested Arrays', props || {}, {...options,   context: {
            ...(options?.context || {}),
            typewriter: {
                language: 'typescript',
                version: '',
            },
        },}, callback);
    }
}
/**
 * Fires a 'NestedObjects' track call.
 *
 * @param NestedObjects props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 	call is fired.
 */
export function nestedObjects(props: NestedObjects, options?: Options, callback?: Callback): void {

    const schema = {\\"$id\\":\\"Nested_Objects\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Validates that clients handle objects-within-objects.\\",\\"properties\\":{\\"garage\\":{\\"$id\\":\\"/properties/garage\\",\\"description\\":\\"\\",\\"properties\\":{\\"tunnel\\":{\\"$id\\":\\"/properties/properties/properties/garage/properties/tunnel\\",\\"description\\":\\"\\",\\"properties\\":{\\"subterranean lab\\":{\\"$id\\":\\"/properties/properties/properties/garage/properties/tunnel/properties/subterranean%20lab\\",\\"description\\":\\"\\",\\"properties\\":{\\"jerry's memories\\":{\\"$id\\":\\"/properties/properties/properties/garage/properties/tunnel/properties/subterranean%20lab/properties/jerry's%20memories\\",\\"description\\":\\"\\",\\"type\\":\\"array\\"},\\"morty's memories\\":{\\"$id\\":\\"/properties/properties/properties/garage/properties/tunnel/properties/subterranean%20lab/properties/morty's%20memories\\",\\"description\\":\\"\\",\\"type\\":\\"array\\"},\\"summer's contingency plan\\":{\\"$id\\":\\"/properties/properties/properties/garage/properties/tunnel/properties/subterranean%20lab/properties/summer's%20contingency%20plan\\",\\"description\\":\\"\\",\\"type\\":\\"string\\"}},\\"required\\":[],\\"type\\":\\"object\\"}},\\"required\\":[\\"subterranean lab\\"],\\"type\\":\\"object\\"}},\\"required\\":[\\"tunnel\\"],\\"type\\":\\"object\\"}},\\"required\\":[\\"garage\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(props, schema);

    const a = analytics();
    if (a) {
        a.track('Nested Objects', props || {}, {...options,   context: {
            ...(options?.context || {}),
            typewriter: {
                language: 'typescript',
                version: '',
            },
        },}, callback);
    }
}
/**
 * Fires a 'PropertiesCollided' track call.
 *
 * @param PropertiesCollided props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 	call is fired.
 */
export function propertiesCollided(props: PropertiesCollided, options?: Options, callback?: Callback): void {

    const schema = {\\"$id\\":\\"Properties_Collided\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Validates that clients handle collisions in property names within a single event.\\",\\"properties\\":{\\"Property Collided\\":{\\"$id\\":\\"/properties/Property%20Collided\\",\\"description\\":\\"\\",\\"type\\":\\"string\\"},\\"property_collided\\":{\\"$id\\":\\"/properties/property_collided\\",\\"description\\":\\"\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"property_collided\\",\\"Property Collided\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(props, schema);

    const a = analytics();
    if (a) {
        a.track('Properties Collided', props || {}, {...options,   context: {
            ...(options?.context || {}),
            typewriter: {
                language: 'typescript',
                version: '',
            },
        },}, callback);
    }
}
/**
 * Fires a 'PropertyObjectNameCollision1' track call.
 *
 * @param PropertyObjectNameCollision1 props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 	call is fired.
 */
export function propertyObjectNameCollision1(props: PropertyObjectNameCollision1, options?: Options, callback?: Callback): void {

    const schema = {\\"$id\\":\\"Property_Object_Name_Collision_1\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Validates that clients handle collisions in object names across multiple events.\\",\\"properties\\":{\\"universe\\":{\\"$id\\":\\"/properties/universe\\",\\"description\\":\\"\\",\\"properties\\":{\\"name\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/name\\",\\"description\\":\\"The common name of this universe.\\",\\"type\\":\\"string\\"},\\"occupants\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/occupants\\",\\"description\\":\\"The most important occupants in this universe.\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/occupants/items\\",\\"description\\":\\"\\",\\"properties\\":{\\"name\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/occupants/items/properties/name\\",\\"description\\":\\"The name of this occupant.\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"name\\"],\\"type\\":\\"object\\"},\\"type\\":\\"array\\"}},\\"required\\":[\\"name\\",\\"occupants\\"],\\"type\\":\\"object\\"}},\\"type\\":\\"object\\"};
    validateAgainstSchema(props, schema);

    const a = analytics();
    if (a) {
        a.track('Property Object Name Collision #1', props || {}, {...options,   context: {
            ...(options?.context || {}),
            typewriter: {
                language: 'typescript',
                version: '',
            },
        },}, callback);
    }
}
/**
 * Fires a 'PropertyObjectNameCollision2' track call.
 *
 * @param PropertyObjectNameCollision2 props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 	call is fired.
 */
export function propertyObjectNameCollision2(props: PropertyObjectNameCollision2, options?: Options, callback?: Callback): void {

    const schema = {\\"$id\\":\\"Property_Object_Name_Collision_2\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Validates that clients handle collisions in object names across multiple events.\\",\\"properties\\":{\\"universe\\":{\\"$id\\":\\"/properties/universe\\",\\"description\\":\\"\\",\\"properties\\":{\\"name\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/name\\",\\"description\\":\\"The common name of this universe.\\",\\"type\\":\\"string\\"},\\"occupants\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/occupants\\",\\"description\\":\\"The most important occupants in this universe.\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/occupants/items\\",\\"description\\":\\"\\",\\"properties\\":{\\"name\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/occupants/items/properties/name\\",\\"description\\":\\"The name of this occupant.\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"name\\"],\\"type\\":\\"object\\"},\\"type\\":\\"array\\"}},\\"required\\":[\\"name\\",\\"occupants\\"],\\"type\\":\\"object\\"}},\\"type\\":\\"object\\"};
    validateAgainstSchema(props, schema);

    const a = analytics();
    if (a) {
        a.track('Property Object Name Collision #2', props || {}, {...options,   context: {
            ...(options?.context || {}),
            typewriter: {
                language: 'typescript',
                version: '',
            },
        },}, callback);
    }
}
/**
 * Fires a 'PropertySanitized' track call.
 *
 * @param PropertySanitized props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 	call is fired.
 */
export function propertySanitized(props: PropertySanitized, options?: Options, callback?: Callback): void {

    const schema = {\\"$id\\":\\"Property_Sanitized\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Validates that clients sanitize property names that contain invalid identifier characters.\\",\\"properties\\":{\\"0000---terrible-property-name~!3\\":{\\"$id\\":\\"/properties/0000---terrible-property-name~!3\\",\\"description\\":\\"\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"0000---terrible-property-name~!3\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(props, schema);

    const a = analytics();
    if (a) {
        a.track('Property Sanitized', props || {}, {...options,   context: {
            ...(options?.context || {}),
            typewriter: {
                language: 'typescript',
                version: '',
            },
        },}, callback);
    }
}
/**
 * Fires a 'SimpleArrayTypes' track call.
 *
 * @param SimpleArrayTypes props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 	call is fired.
 */
export function simpleArrayTypes(props: SimpleArrayTypes, options?: Options, callback?: Callback): void {

    const schema = {\\"$id\\":\\"Simple_Array_Types\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Validates that clients support fields with various types of arrays.\\",\\"properties\\":{\\"any\\":{\\"$id\\":\\"/properties/any\\",\\"description\\":\\"\\",\\"items\\":{\\"description\\":\\"\\"},\\"type\\":\\"array\\"},\\"boolean\\":{\\"$id\\":\\"/properties/boolean\\",\\"description\\":\\"\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/boolean/items\\",\\"description\\":\\"\\",\\"type\\":\\"boolean\\"},\\"type\\":\\"array\\"},\\"integer\\":{\\"$id\\":\\"/properties/integer\\",\\"description\\":\\"\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/integer/items\\",\\"description\\":\\"\\",\\"type\\":\\"integer\\"},\\"type\\":\\"array\\"},\\"nullable\\":{\\"$id\\":\\"/properties/nullable\\",\\"description\\":\\"\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/nullable/items\\",\\"description\\":\\"\\",\\"type\\":[\\"string\\",\\"null\\"]},\\"type\\":\\"array\\"},\\"number\\":{\\"$id\\":\\"/properties/number\\",\\"description\\":\\"\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/number/items\\",\\"description\\":\\"\\",\\"type\\":\\"number\\"},\\"type\\":\\"array\\"},\\"object\\":{\\"$id\\":\\"/properties/object\\",\\"description\\":\\"\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/object/items\\",\\"description\\":\\"\\",\\"properties\\":{\\"name\\":{\\"$id\\":\\"/properties/properties/properties/object/items/properties/name\\",\\"description\\":\\"\\",\\"type\\":\\"string\\"}},\\"required\\":[],\\"type\\":\\"object\\"},\\"type\\":\\"array\\"},\\"string\\":{\\"$id\\":\\"/properties/string\\",\\"description\\":\\"\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/string/items\\",\\"description\\":\\"\\",\\"type\\":\\"string\\"},\\"type\\":\\"array\\"}},\\"type\\":\\"object\\"};
    validateAgainstSchema(props, schema);

    const a = analytics();
    if (a) {
        a.track('Simple Array Types', props || {}, {...options,   context: {
            ...(options?.context || {}),
            typewriter: {
                language: 'typescript',
                version: '',
            },
        },}, callback);
    }
}
/**
 * Fires a 'UnionType' track call.
 *
 * @param UnionType props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 	call is fired.
 */
export function unionType(props: UnionType, options?: Options, callback?: Callback): void {

    const schema = {\\"$id\\":\\"Union_Type\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Validates that clients support fields with multiple (union) types.\\",\\"properties\\":{\\"universe_name\\":{\\"$id\\":\\"/properties/universe_name\\",\\"description\\":\\"\\",\\"type\\":[\\"string\\",\\"null\\",\\"integer\\"]}},\\"required\\":[\\"universe_name\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(props, schema);

    const a = analytics();
    if (a) {
        a.track('Union Type', props || {}, {...options,   context: {
            ...(options?.context || {}),
            typewriter: {
                language: 'typescript',
                version: '',
            },
        },}, callback);
    }
}
/**
 * Fires a 'NoIDType' track call.
 *
 * @param NoIDType props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 	call is fired.
 */
export function noIDType(props: NoIDType, options?: Options, callback?: Callback): void {

    const schema = {\\"$id\\":\\"NoID_Type\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Properties without IDs\\",\\"properties\\":{\\"no_id_prop\\":{\\"description\\":\\"a property without an ID\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"no_id_prop\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(props, schema);

    const a = analytics();
    if (a) {
        a.track('NoID type', props || {}, {...options,   context: {
            ...(options?.context || {}),
            typewriter: {
                language: 'typescript',
                version: '',
            },
        },}, callback);
    }
}

const clientAPI = {
    /**
     * Updates the run-time configuration of this Typewriter client.
     *
     * @param {TypewriterOptions} options - the options to upsert
     *
     * @typedef {Object} TypewriterOptions
     * @property {AnyAnalytics} [analytics] - Underlying analytics instance where analytics
     * 		calls are forwarded on to. Defaults to window.analytics.
     * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
     * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
     * 		it will throw errors if NODE_ENV=\\"test\\" so that tests will fail if a message does not match the spec. Otherwise, errors
     * 		will be logged to stderr.
     */
    setTypewriterOptions,

    /**
     * Fires a 'CustomViolationHandler' track call.
     *
     * @param CustomViolationHandler props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    customViolationHandler,
    /**
     * Fires a 'DefaultViolationHandler' track call.
     *
     * @param DefaultViolationHandler props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    defaultViolationHandler,
    /**
     * Fires a 'EnumTypes' track call.
     *
     * @param EnumTypes props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    enumTypes,
    /**
     * Fires a 'EveryNullableOptionalType' track call.
     *
     * @param EveryNullableOptionalType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    everyNullableOptionalType,
    /**
     * Fires a 'EveryNullableRequiredType' track call.
     *
     * @param EveryNullableRequiredType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    everyNullableRequiredType,
    /**
     * Fires a 'EveryOptionalType' track call.
     *
     * @param EveryOptionalType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    everyOptionalType,
    /**
     * Fires a 'EveryRequiredType' track call.
     *
     * @param EveryRequiredType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    everyRequiredType,
    /**
     * Fires a 'LargeNumbersEvent' track call.
     *
     * @param LargeNumbersEvent props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    largeNumbersEvent,
    /**
     * Fires a 'NestedArrays' track call.
     *
     * @param NestedArrays props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    nestedArrays,
    /**
     * Fires a 'NestedObjects' track call.
     *
     * @param NestedObjects props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    nestedObjects,
    /**
     * Fires a 'PropertiesCollided' track call.
     *
     * @param PropertiesCollided props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    propertiesCollided,
    /**
     * Fires a 'PropertyObjectNameCollision1' track call.
     *
     * @param PropertyObjectNameCollision1 props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    propertyObjectNameCollision1,
    /**
     * Fires a 'PropertyObjectNameCollision2' track call.
     *
     * @param PropertyObjectNameCollision2 props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    propertyObjectNameCollision2,
    /**
     * Fires a 'PropertySanitized' track call.
     *
     * @param PropertySanitized props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    propertySanitized,
    /**
     * Fires a 'SimpleArrayTypes' track call.
     *
     * @param SimpleArrayTypes props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    simpleArrayTypes,
    /**
     * Fires a 'UnionType' track call.
     *
     * @param UnionType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    unionType,
    /**
     * Fires a 'NoIDType' track call.
     *
     * @param NoIDType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    noIDType,
};

export default new Proxy<typeof clientAPI>(clientAPI, {
    get(target, method) {
        if (typeof method === 'string' && target.hasOwnProperty(method)) {
            return target[method as keyof typeof clientAPI];
        }

        return () => {
            console.warn(\`  You made an analytics call (\${String(method)}) that can't be found. Either:
         a) Re-generate your typewriter client: \\\\\`npx typewriter\\\\\`
         b) Add it to your Tracking Plan: https://app.segment.com/segment-oscb/protocols/tracking-plans/rs_1zTHJU9fd5mt7cndWnd4PgJbMCE\`);
            const a = analytics();
            if (a) {
                a.track(
                    'Unknown Analytics Call Fired',
                    {
                        method,
                    },
                    withTypewriterContext(),
                );
            }
        };
    },
});

"
`;

exports[`build builds client Language: typescript, SDK:analytics-node 1`] = `
"// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

/**
 * This event is fired in order to trigger a custom violation handler. It should be called
 * with a JSON Schema violation.
 */
export interface CustomViolationHandler {
    \\"regex property\\": string;
}

/**
 * This event is fired in order to trigger the default violation handler. It should be
 * called with a JSON Schema violation.
 */
export interface DefaultViolationHandler {
    \\"regex property\\": string;
}

/**
 * Validates that client property sanitize enums.
 */
export interface EnumTypes {
    /**
     * A string property that only accepts a single enum value.
     */
    \\"string const\\"?: StringConst;
    /**
     * A string property that accepts multiple enum values.
     */
    \\"string enum\\"?: StringEnum;
}

/**
 * A string property that only accepts a single enum value.
 */
export enum StringConst {
    RickSanchez = \\"Rick Sanchez\\",
}

/**
 * A string property that accepts multiple enum values.
 */
export enum StringEnum {
    EvilMorty = \\"Evil Morty\\",
    LawyerMorty = \\"Lawyer Morty\\",
}

/**
 * Validates that clients handle all of the supported field types, as nullable optional
 * fields. If a field is null, it is expected to be NOT sent through.
 */
export interface EveryNullableOptionalType {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[] | null;
    /**
     * Optional array with properties
     */
    \\"optional array with properties\\"?: Array<null | EveryNullableOptionalTypeOptionalArrayWithProperty> | null;
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean | null;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number | null;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number | null;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any } | null;
    /**
     * Optional object with properties
     */
    \\"optional object with properties\\"?: null | EveryNullableOptionalTypeOptionalObjectWithProperties;
    /**
     * Optional string property
     */
    \\"optional string\\"?: null | string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: null | string;
}

export interface EveryNullableOptionalTypeOptionalArrayWithProperty {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[] | null;
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean | null;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number | null;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number | null;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any } | null;
    /**
     * Optional string property
     */
    \\"optional string\\"?: null | string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: null | string;
}

export interface EveryNullableOptionalTypeOptionalObjectWithProperties {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[] | null;
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean | null;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number | null;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number | null;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any } | null;
    /**
     * Optional string property
     */
    \\"optional string\\"?: null | string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: null | string;
}

/**
 * Validates that clients handle all of the supported field types, as nullable required
 * fields. If a field is null, it is expected to be sent through.
 */
export interface EveryNullableRequiredType {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[] | null;
    /**
     * Required array with properties
     */
    \\"required array with properties\\": Array<null | EveryNullableRequiredTypeRequiredArrayWithProperty> | null;
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean | null;
    /**
     * Required integer property
     */
    \\"required int\\": number | null;
    /**
     * Required number property
     */
    \\"required number\\": number | null;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any } | null;
    /**
     * Required object with properties
     */
    \\"required object with properties\\": null | EveryNullableRequiredTypeRequiredObjectWithProperties;
    /**
     * Required string property
     */
    \\"required string\\": null | string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": null | string;
}

export interface EveryNullableRequiredTypeRequiredArrayWithProperty {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[] | null;
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean | null;
    /**
     * Required integer property
     */
    \\"required int\\": number | null;
    /**
     * Required number property
     */
    \\"required number\\": number | null;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any } | null;
    /**
     * Required string property
     */
    \\"required string\\": null | string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": null | string;
}

export interface EveryNullableRequiredTypeRequiredObjectWithProperties {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[] | null;
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean | null;
    /**
     * Required integer property
     */
    \\"required int\\": number | null;
    /**
     * Required number property
     */
    \\"required number\\": number | null;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any } | null;
    /**
     * Required string property
     */
    \\"required string\\": null | string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": null | string;
}

/**
 * Validates that clients handle all of the supported field types, as optional fields.
 */
export interface EveryOptionalType {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[];
    /**
     * Optional array with properties
     */
    \\"optional array with properties\\"?: OptionalArrayWithPropertyElement[];
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any };
    /**
     * Optional object with properties
     */
    \\"optional object with properties\\"?: EveryOptionalTypeOptionalObjectWithProperties;
    /**
     * Optional string property
     */
    \\"optional string\\"?: string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: string;
}

export interface OptionalArrayWithPropertyElement {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[];
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any };
    /**
     * Optional string property
     */
    \\"optional string\\"?: string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: string;
}

/**
 * Optional object with properties
 */
export interface EveryOptionalTypeOptionalObjectWithProperties {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[];
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any };
    /**
     * Optional string property
     */
    \\"optional string\\"?: string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: string;
}

/**
 * Validates that clients handle all of the supported field types, as required fields.
 */
export interface EveryRequiredType {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[];
    /**
     * Required array with properties
     */
    \\"required array with properties\\": RequiredArrayWithPropertyElement[];
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean;
    /**
     * Required integer property
     */
    \\"required int\\": number;
    /**
     * Required number property
     */
    \\"required number\\": number;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any };
    /**
     * Required object with properties
     */
    \\"required object with properties\\": EveryRequiredTypeRequiredObjectWithProperties;
    /**
     * Required string property
     */
    \\"required string\\": string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": string;
}

export interface RequiredArrayWithPropertyElement {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[];
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean;
    /**
     * Required integer property
     */
    \\"required int\\": number;
    /**
     * Required number property
     */
    \\"required number\\": number;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any };
    /**
     * Required string property
     */
    \\"required string\\": string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": string;
}

/**
 * Required object with properties
 */
export interface EveryRequiredTypeRequiredObjectWithProperties {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[];
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean;
    /**
     * Required integer property
     */
    \\"required int\\": number;
    /**
     * Required number property
     */
    \\"required number\\": number;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any };
    /**
     * Required string property
     */
    \\"required string\\": string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": string;
}

/**
 * Validates that clients correctly serialize large numbers (integers and floats).
 */
export interface LargeNumbersEvent {
    \\"large nullable optional integer\\"?: number | null;
    \\"large nullable optional number\\"?:  number | null;
    \\"large nullable required integer\\":  number | null;
    \\"large nullable required number\\":   number | null;
    \\"large optional integer\\"?:          number;
    \\"large optional number\\"?:           number;
    \\"large required integer\\":           number;
    \\"large required number\\":            number;
}

/**
 * Validates that clients handle arrays-within-arrays.
 */
export interface NestedArrays {
    /**
     * All known characters from each universe.
     */
    universeCharacters: Array<UniverseCharacter[]>;
}

export interface UniverseCharacter {
    /**
     * The character's name.
     */
    name: string;
}

/**
 * Validates that clients handle objects-within-objects.
 */
export interface NestedObjects {
    garage: Garage;
}

export interface Garage {
    tunnel: Tunnel;
}

export interface Tunnel {
    \\"subterranean lab\\": SubterraneanLab;
}

export interface SubterraneanLab {
    \\"jerry's memories\\"?:          any[];
    \\"morty's memories\\"?:          any[];
    \\"summer's contingency plan\\"?: string;
}

/**
 * Validates that clients handle collisions in property names within a single event.
 */
export interface PropertiesCollided {
    \\"Property Collided\\": string;
    property_collided:   string;
}

/**
 * Validates that clients handle collisions in object names across multiple events.
 */
export interface PropertyObjectNameCollision1 {
    universe?: PropertyObjectNameCollision1_Universe;
}

export interface PropertyObjectNameCollision1_Universe {
    /**
     * The common name of this universe.
     */
    name: string;
    /**
     * The most important occupants in this universe.
     */
    occupants: PurpleOccupant[];
}

export interface PurpleOccupant {
    /**
     * The name of this occupant.
     */
    name: string;
}

/**
 * Validates that clients handle collisions in object names across multiple events.
 */
export interface PropertyObjectNameCollision2 {
    universe?: PropertyObjectNameCollision2_Universe;
}

export interface PropertyObjectNameCollision2_Universe {
    /**
     * The common name of this universe.
     */
    name: string;
    /**
     * The most important occupants in this universe.
     */
    occupants: FluffyOccupant[];
}

export interface FluffyOccupant {
    /**
     * The name of this occupant.
     */
    name: string;
}

/**
 * Validates that clients sanitize property names that contain invalid identifier characters.
 */
export interface PropertySanitized {
    \\"0000---terrible-property-name~!3\\": string;
}

/**
 * Validates that clients support fields with various types of arrays.
 */
export interface SimpleArrayTypes {
    any?:      any[];
    boolean?:  boolean[];
    integer?:  number[];
    nullable?: Array<null | string>;
    number?:   number[];
    object?:   Object[];
    string?:   string[];
}

export interface Object {
    name?: string;
}

/**
 * Validates that clients support fields with multiple (union) types.
 */
export interface UnionType {
    universe_name: number | null | string;
}

/**
 * Properties without IDs
 */
export interface NoIDType {
    /**
     * a property without an ID
     */
    no_id_prop: string;
}

/**
 * Ajv is a peer dependency for development builds. It's used to apply run-time validation
 * to message payloads before passing them on to the underlying analytics instance.
 *
 * Note that the production bundle does not depend on Ajv.
 * 
 * You can install it with: \`npm install --save-dev ajv\`.
 */
import Ajv, { ErrorObject } from 'ajv'
import { Analytics, TrackParams } from '@segment/analytics-node'

/**
 * An ID associated with the user. Note: at least one of userId or anonymousId must be included!
 **/
type Identity =
    | { userId: string; anonymousId?: string }
    | { userId?: string; anonymousId: string }

/**
 * TrackMessage represents a message payload for an analytics \`.track()\` call.
 * See: https://segment.com/docs/spec/track/
 */
export type TrackMessage<PropertiesType> = Omit<
    TrackParams,
    'event' | 'properties'
> & { event?: string, properties: PropertiesType } & Identity

/** The callback exposed by analytics-node. */
export type Callback = Parameters<Analytics['track']>[1]

export type ViolationHandler = (
    message: TrackMessage<Record<string, any>>,
    violations: ErrorObject[]
) => void

/**
 * The default handler that is fired if none is supplied with setTypewriterOptions.
 * If NODE_ENV=\\"test\\", this handler will throw an error. Otherwise, it will log
 * a warning message to the console.
 */
 export const defaultValidationErrorHandler: ViolationHandler = (
    message,
    violations
) => {
    const msg = JSON.stringify(
        {
            type: 'Typewriter JSON Schema Validation Error',
            description:
                \`You made an analytics call (\${message.event}) using Typewriter that doesn't match the \` +
                'Tracking Plan spec.',
            errors: violations,
        },
        undefined,
        2
    )

    if (process.env.NODE_ENV === 'test') {
        throw new Error(msg)
    }
    console.warn(msg)
}

let onViolation = defaultValidationErrorHandler

const missingAnalyticsNodeError = new Error(\`You must set an analytics-node instance:

>	import { Analytics } from '@segment/analytics-node'
>	import { setTypewriterOptions } from './analytics'
>
> const analytics = new Analytics({ writeKey: 'SEGMENT_WRITE_KEY' })
>	setTypewriterOptions({ analytics: analytics	})

For more information on @segment/analytics-node, see: https://segment.com/docs/sources/server/node/quickstart/
\`)

let analytics: () => Analytics | undefined = () => {
    throw missingAnalyticsNodeError
}

/** Options to customize the runtime behavior of a Typewriter client. */
export interface TypewriterOptions {
    /**
     * Underlying analytics instance where analytics calls are forwarded on to.
     */
    analytics: Analytics
    /**
     * Handler fired when if an event does not match its spec. This handler
     * does not fire in production mode, because it requires inlining the full
     * JSON Schema spec for each event in your Tracking Plan.
     *
     * By default, it will throw errors if NODE_ENV = \\"test\\" so that tests will fail
     * if a message does not match the spec. Otherwise, errors will be logged to stderr.
     */
    onViolation?: ViolationHandler
}

/**
 * Updates the run-time configuration of this Typewriter client.
 * This function must be called with a configured analytics-node instance before firing
 * any analytics calls, or else a \`missingAnalyticsNodeError\` error will be thrown.
 *
 * @param {TypewriterOptions} options - the options to upsert
 *
 * @typedef {Object} TypewriterOptions
 * @property {Analytics} analytics - Underlying analytics instance where analytics
 * 		calls are forwarded on to.
 * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
 * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
 * 		it will throw errors if NODE_ENV=\\"test\\" so that tests will fail if a message does not match the spec. Otherwise, errors
 * 		will be logged to stderr.
 */
export function setTypewriterOptions(options: TypewriterOptions) {
    analytics = options.analytics ? () => options.analytics : analytics
    onViolation = options.onViolation || onViolation
}

/**
    * Validates a message against a JSON Schema using Ajv. If the message
    * is invalid, the \`onViolation\` handler will be called.
    */
function validateAgainstSchema(
    message: TrackMessage<Record<string, any>>,
    schema: object
) {
    const ajv = new Ajv({ allErrors: true, verbose: true })

    if (!ajv.validate(schema, message.properties) && ajv.errors) {
        onViolation(message, ajv.errors)
    }
}

/**
 * Helper to attach metadata on Typewriter to outbound requests.
 * This is used for attribution and debugging by the Segment team.
 */
function withTypewriterContext<P extends Record<string, any>, T extends TrackMessage<P>>(
    message: T
) {
    return {
        ...message,
        context: {
            ...(message.context || {}),
            typewriter: {
                language: 'typescript',
                
            },
        },
    }
}


/**
 * Fires a 'Custom Violation Handler' track call.
 * This event is fired in order to trigger a custom violation handler. It should be called with a JSON Schema violation.
 *
 * @param {TrackMessage<CustomViolationHandler>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function customViolationHandler(
    message: TrackMessage<CustomViolationHandler>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Custom Violation Handler',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Custom_Violation_Handler\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"This event is fired in order to trigger a custom violation handler. It should be called with a JSON Schema violation.\\",\\"properties\\":{\\"regex property\\":{\\"$id\\":\\"/properties/regex%20property\\",\\"description\\":\\"\\",\\"pattern\\":\\"Lawyer Morty|Evil Morty\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"regex property\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Default Violation Handler' track call.
 * This event is fired in order to trigger the default violation handler. It should be called with a JSON Schema violation.
 *
 * @param {TrackMessage<DefaultViolationHandler>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function defaultViolationHandler(
    message: TrackMessage<DefaultViolationHandler>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Default Violation Handler',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Default_Violation_Handler\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"This event is fired in order to trigger the default violation handler. It should be called with a JSON Schema violation.\\",\\"properties\\":{\\"regex property\\":{\\"$id\\":\\"/properties/regex%20property\\",\\"description\\":\\"\\",\\"pattern\\":\\"Lawyer Morty|Evil Morty\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"regex property\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Enum Types' track call.
 * Validates that client property sanitize enums.
 *
 * @param {TrackMessage<EnumTypes>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function enumTypes(
    message: TrackMessage<EnumTypes>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Enum Types',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Enum_Types\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Validates that client property sanitize enums.\\",\\"properties\\":{\\"string const\\":{\\"$id\\":\\"/properties/string%20const\\",\\"description\\":\\"A string property that only accepts a single enum value.\\",\\"enum\\":[\\"Rick Sanchez\\"],\\"type\\":\\"string\\"},\\"string enum\\":{\\"$id\\":\\"/properties/string%20enum\\",\\"description\\":\\"A string property that accepts multiple enum values.\\",\\"enum\\":[\\"Evil Morty\\",\\"Lawyer Morty\\"],\\"type\\":\\"string\\"}},\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Every Nullable Optional Type' track call.
 * Validates that clients handle all of the supported field types, as nullable optional fields. If a field is null, it is expected to be NOT sent through.
 *
 * @param {TrackMessage<EveryNullableOptionalType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function everyNullableOptionalType(
    message: TrackMessage<EveryNullableOptionalType>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Every Nullable Optional Type',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Every_Nullable_Optional_Type\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Validates that clients handle all of the supported field types, as nullable optional fields. If a field is null, it is expected to be NOT sent through.\\",\\"properties\\":{\\"optional any\\":{\\"$id\\":\\"/properties/optional%20any\\",\\"description\\":\\"Optional any property\\"},\\"optional array\\":{\\"$id\\":\\"/properties/optional%20array\\",\\"description\\":\\"Optional array property\\",\\"type\\":[\\"array\\",\\"null\\"]},\\"optional array with properties\\":{\\"$id\\":\\"/properties/optional%20array%20with%20properties\\",\\"description\\":\\"Optional array with properties\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items\\",\\"properties\\":{\\"optional any\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20any\\",\\"description\\":\\"Optional any property\\"},\\"optional array\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20array\\",\\"description\\":\\"Optional array property\\",\\"type\\":[\\"array\\",\\"null\\"]},\\"optional boolean\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20boolean\\",\\"description\\":\\"Optional boolean property\\",\\"type\\":[\\"boolean\\",\\"null\\"]},\\"optional int\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20int\\",\\"description\\":\\"Optional integer property\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"optional number\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20number\\",\\"description\\":\\"Optional number property\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"optional object\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20object\\",\\"description\\":\\"Optional object property\\",\\"properties\\":{},\\"required\\":[],\\"type\\":[\\"object\\",\\"null\\"]},\\"optional string\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20string\\",\\"description\\":\\"Optional string property\\",\\"type\\":[\\"string\\",\\"null\\"]},\\"optional string with regex\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20string%20with%20regex\\",\\"description\\":\\"Optional string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":[\\"string\\",\\"null\\"]}},\\"type\\":[\\"object\\",\\"null\\"]},\\"type\\":[\\"array\\",\\"null\\"]},\\"optional boolean\\":{\\"$id\\":\\"/properties/optional%20boolean\\",\\"description\\":\\"Optional boolean property\\",\\"type\\":[\\"boolean\\",\\"null\\"]},\\"optional int\\":{\\"$id\\":\\"/properties/optional%20int\\",\\"description\\":\\"Optional integer property\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"optional number\\":{\\"$id\\":\\"/properties/optional%20number\\",\\"description\\":\\"Optional number property\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"optional object\\":{\\"$id\\":\\"/properties/optional%20object\\",\\"description\\":\\"Optional object property\\",\\"properties\\":{},\\"required\\":[],\\"type\\":[\\"object\\",\\"null\\"]},\\"optional object with properties\\":{\\"$id\\":\\"/properties/optional%20object%20with%20properties\\",\\"description\\":\\"Optional object with properties\\",\\"properties\\":{\\"optional any\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20any\\",\\"description\\":\\"Optional any property\\"},\\"optional array\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20array\\",\\"description\\":\\"Optional array property\\",\\"type\\":[\\"array\\",\\"null\\"]},\\"optional boolean\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20boolean\\",\\"description\\":\\"Optional boolean property\\",\\"type\\":[\\"boolean\\",\\"null\\"]},\\"optional int\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20int\\",\\"description\\":\\"Optional integer property\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"optional number\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20number\\",\\"description\\":\\"Optional number property\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"optional object\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20object\\",\\"description\\":\\"Optional object property\\",\\"properties\\":{},\\"required\\":[],\\"type\\":[\\"object\\",\\"null\\"]},\\"optional string\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20string\\",\\"description\\":\\"Optional string property\\",\\"type\\":[\\"string\\",\\"null\\"]},\\"optional string with regex\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20string%20with%20regex\\",\\"description\\":\\"Optional string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":[\\"string\\",\\"null\\"]}},\\"required\\":[],\\"type\\":[\\"object\\",\\"null\\"]},\\"optional string\\":{\\"$id\\":\\"/properties/optional%20string\\",\\"description\\":\\"Optional string property\\",\\"type\\":[\\"string\\",\\"null\\"]},\\"optional string with regex\\":{\\"$id\\":\\"/properties/optional%20string%20with%20regex\\",\\"description\\":\\"Optional string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":[\\"string\\",\\"null\\"]}},\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Every Nullable Required Type' track call.
 * Validates that clients handle all of the supported field types, as nullable required fields. If a field is null, it is expected to be sent through.
 *
 * @param {TrackMessage<EveryNullableRequiredType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function everyNullableRequiredType(
    message: TrackMessage<EveryNullableRequiredType>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Every Nullable Required Type',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Every_Nullable_Required_Type\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Validates that clients handle all of the supported field types, as nullable required fields. If a field is null, it is expected to be sent through.\\",\\"properties\\":{\\"required any\\":{\\"$id\\":\\"/properties/required%20any\\",\\"description\\":\\"Required any property\\"},\\"required array\\":{\\"$id\\":\\"/properties/required%20array\\",\\"description\\":\\"Required array property\\",\\"type\\":[\\"array\\",\\"null\\"]},\\"required array with properties\\":{\\"$id\\":\\"/properties/required%20array%20with%20properties\\",\\"description\\":\\"Required array with properties\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items\\",\\"properties\\":{\\"required any\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20any\\",\\"description\\":\\"Required any property\\"},\\"required array\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20array\\",\\"description\\":\\"Required array property\\",\\"type\\":[\\"array\\",\\"null\\"]},\\"required boolean\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20boolean\\",\\"description\\":\\"Required boolean property\\",\\"type\\":[\\"boolean\\",\\"null\\"]},\\"required int\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20int\\",\\"description\\":\\"Required integer property\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"required number\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20number\\",\\"description\\":\\"Required number property\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"required object\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20object\\",\\"description\\":\\"Required object property\\",\\"properties\\":{},\\"required\\":[],\\"type\\":[\\"object\\",\\"null\\"]},\\"required string\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20string\\",\\"description\\":\\"Required string property\\",\\"type\\":[\\"string\\",\\"null\\"]},\\"required string with regex\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20string%20with%20regex\\",\\"description\\":\\"Required string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":[\\"string\\",\\"null\\"]}},\\"required\\":[\\"required any\\",\\"required array\\",\\"required boolean\\",\\"required int\\",\\"required number\\",\\"required object\\",\\"required string\\",\\"required string with regex\\"],\\"type\\":[\\"object\\",\\"null\\"]},\\"type\\":[\\"array\\",\\"null\\"]},\\"required boolean\\":{\\"$id\\":\\"/properties/required%20boolean\\",\\"description\\":\\"Required boolean property\\",\\"type\\":[\\"boolean\\",\\"null\\"]},\\"required int\\":{\\"$id\\":\\"/properties/required%20int\\",\\"description\\":\\"Required integer property\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"required number\\":{\\"$id\\":\\"/properties/required%20number\\",\\"description\\":\\"Required number property\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"required object\\":{\\"$id\\":\\"/properties/required%20object\\",\\"description\\":\\"Required object property\\",\\"properties\\":{},\\"required\\":[],\\"type\\":[\\"object\\",\\"null\\"]},\\"required object with properties\\":{\\"$id\\":\\"/properties/required%20object%20with%20properties\\",\\"description\\":\\"Required object with properties\\",\\"properties\\":{\\"required any\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20any\\",\\"description\\":\\"Required any property\\"},\\"required array\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20array\\",\\"description\\":\\"Required array property\\",\\"type\\":[\\"array\\",\\"null\\"]},\\"required boolean\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20boolean\\",\\"description\\":\\"Required boolean property\\",\\"type\\":[\\"boolean\\",\\"null\\"]},\\"required int\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20int\\",\\"description\\":\\"Required integer property\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"required number\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20number\\",\\"description\\":\\"Required number property\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"required object\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20object\\",\\"description\\":\\"Required object property\\",\\"properties\\":{},\\"required\\":[],\\"type\\":[\\"object\\",\\"null\\"]},\\"required string\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20string\\",\\"description\\":\\"Required string property\\",\\"type\\":[\\"string\\",\\"null\\"]},\\"required string with regex\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20string%20with%20regex\\",\\"description\\":\\"Required string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":[\\"string\\",\\"null\\"]}},\\"required\\":[\\"required any\\",\\"required array\\",\\"required boolean\\",\\"required int\\",\\"required number\\",\\"required object\\",\\"required string\\",\\"required string with regex\\"],\\"type\\":[\\"object\\",\\"null\\"]},\\"required string\\":{\\"$id\\":\\"/properties/required%20string\\",\\"description\\":\\"Required string property\\",\\"type\\":[\\"string\\",\\"null\\"]},\\"required string with regex\\":{\\"$id\\":\\"/properties/required%20string%20with%20regex\\",\\"description\\":\\"Required string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":[\\"string\\",\\"null\\"]}},\\"required\\":[\\"required any\\",\\"required array\\",\\"required boolean\\",\\"required int\\",\\"required number\\",\\"required object\\",\\"required string\\",\\"required string with regex\\",\\"required object with properties\\",\\"required array with properties\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Every Optional Type' track call.
 * Validates that clients handle all of the supported field types, as optional fields.
 *
 * @param {TrackMessage<EveryOptionalType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function everyOptionalType(
    message: TrackMessage<EveryOptionalType>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Every Optional Type',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Every_Optional_Type\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Validates that clients handle all of the supported field types, as optional fields.\\",\\"properties\\":{\\"optional any\\":{\\"$id\\":\\"/properties/optional%20any\\",\\"description\\":\\"Optional any property\\"},\\"optional array\\":{\\"$id\\":\\"/properties/optional%20array\\",\\"description\\":\\"Optional array property\\",\\"type\\":\\"array\\"},\\"optional array with properties\\":{\\"$id\\":\\"/properties/optional%20array%20with%20properties\\",\\"description\\":\\"Optional array with properties\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items\\",\\"properties\\":{\\"optional any\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20any\\",\\"description\\":\\"Optional any property\\"},\\"optional array\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20array\\",\\"description\\":\\"Optional array property\\",\\"type\\":\\"array\\"},\\"optional boolean\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20boolean\\",\\"description\\":\\"Optional boolean property\\",\\"type\\":\\"boolean\\"},\\"optional int\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20int\\",\\"description\\":\\"Optional integer property\\",\\"type\\":\\"integer\\"},\\"optional number\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20number\\",\\"description\\":\\"Optional number property\\",\\"type\\":\\"number\\"},\\"optional object\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20object\\",\\"description\\":\\"Optional object property\\",\\"key\\":\\"optional object\\",\\"properties\\":{},\\"type\\":\\"object\\"},\\"optional string\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20string\\",\\"description\\":\\"Optional string property\\",\\"type\\":\\"string\\"},\\"optional string with regex\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20string%20with%20regex\\",\\"description\\":\\"Optional string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":\\"string\\"}},\\"type\\":\\"object\\"},\\"type\\":\\"array\\"},\\"optional boolean\\":{\\"$id\\":\\"/properties/optional%20boolean\\",\\"description\\":\\"Optional boolean property\\",\\"type\\":\\"boolean\\"},\\"optional int\\":{\\"$id\\":\\"/properties/optional%20int\\",\\"description\\":\\"Optional integer property\\",\\"type\\":\\"integer\\"},\\"optional number\\":{\\"$id\\":\\"/properties/optional%20number\\",\\"description\\":\\"Optional number property\\",\\"type\\":\\"number\\"},\\"optional object\\":{\\"$id\\":\\"/properties/optional%20object\\",\\"description\\":\\"Optional object property\\",\\"key\\":\\"optional object\\",\\"properties\\":{},\\"type\\":\\"object\\"},\\"optional object with properties\\":{\\"$id\\":\\"/properties/optional%20object%20with%20properties\\",\\"description\\":\\"Optional object with properties\\",\\"properties\\":{\\"optional any\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20any\\",\\"description\\":\\"Optional any property\\"},\\"optional array\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20array\\",\\"description\\":\\"Optional array property\\",\\"type\\":\\"array\\"},\\"optional boolean\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20boolean\\",\\"description\\":\\"Optional boolean property\\",\\"type\\":\\"boolean\\"},\\"optional int\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20int\\",\\"description\\":\\"Optional integer property\\",\\"type\\":\\"integer\\"},\\"optional number\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20number\\",\\"description\\":\\"Optional number property\\",\\"type\\":\\"number\\"},\\"optional object\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20object\\",\\"description\\":\\"Optional object property\\",\\"key\\":\\"optional object\\",\\"properties\\":{},\\"type\\":\\"object\\"},\\"optional string\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20string\\",\\"description\\":\\"Optional string property\\",\\"type\\":\\"string\\"},\\"optional string with regex\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20string%20with%20regex\\",\\"description\\":\\"Optional string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":\\"string\\"}},\\"type\\":\\"object\\"},\\"optional string\\":{\\"$id\\":\\"/properties/optional%20string\\",\\"description\\":\\"Optional string property\\",\\"type\\":\\"string\\"},\\"optional string with regex\\":{\\"$id\\":\\"/properties/optional%20string%20with%20regex\\",\\"description\\":\\"Optional string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":\\"string\\"}},\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Every Required Type' track call.
 * Validates that clients handle all of the supported field types, as required fields.
 *
 * @param {TrackMessage<EveryRequiredType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function everyRequiredType(
    message: TrackMessage<EveryRequiredType>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Every Required Type',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Every_Required_Type\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Validates that clients handle all of the supported field types, as required fields. \\",\\"properties\\":{\\"required any\\":{\\"$id\\":\\"/properties/required%20any\\",\\"description\\":\\"Required any property\\"},\\"required array\\":{\\"$id\\":\\"/properties/required%20array\\",\\"description\\":\\"Required array property\\",\\"type\\":\\"array\\"},\\"required array with properties\\":{\\"$id\\":\\"/properties/required%20array%20with%20properties\\",\\"description\\":\\"Required array with properties\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items\\",\\"properties\\":{\\"required any\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20any\\",\\"description\\":\\"Required any property\\"},\\"required array\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20array\\",\\"description\\":\\"Required array property\\",\\"type\\":\\"array\\"},\\"required boolean\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20boolean\\",\\"description\\":\\"Required boolean property\\",\\"type\\":\\"boolean\\"},\\"required int\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20int\\",\\"description\\":\\"Required integer property\\",\\"type\\":\\"integer\\"},\\"required number\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20number\\",\\"description\\":\\"Required number property\\",\\"type\\":\\"number\\"},\\"required object\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20object\\",\\"description\\":\\"Required object property\\",\\"key\\":\\"required object\\",\\"properties\\":{},\\"required\\":[],\\"type\\":\\"object\\"},\\"required string\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20string\\",\\"description\\":\\"Required string property\\",\\"type\\":\\"string\\"},\\"required string with regex\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20string%20with%20regex\\",\\"description\\":\\"Required string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"required any\\",\\"required array\\",\\"required boolean\\",\\"required int\\",\\"required number\\",\\"required object\\",\\"required string\\",\\"required string with regex\\"],\\"type\\":\\"object\\"},\\"type\\":\\"array\\"},\\"required boolean\\":{\\"$id\\":\\"/properties/required%20boolean\\",\\"description\\":\\"Required boolean property\\",\\"type\\":\\"boolean\\"},\\"required int\\":{\\"$id\\":\\"/properties/required%20int\\",\\"description\\":\\"Required integer property\\",\\"type\\":\\"integer\\"},\\"required number\\":{\\"$id\\":\\"/properties/required%20number\\",\\"description\\":\\"Required number property\\",\\"type\\":\\"number\\"},\\"required object\\":{\\"$id\\":\\"/properties/required%20object\\",\\"description\\":\\"Required object property\\",\\"key\\":\\"required object\\",\\"properties\\":{},\\"required\\":[],\\"type\\":\\"object\\"},\\"required object with properties\\":{\\"$id\\":\\"/properties/required%20object%20with%20properties\\",\\"description\\":\\"Required object with properties\\",\\"properties\\":{\\"required any\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20any\\",\\"description\\":\\"Required any property\\"},\\"required array\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20array\\",\\"description\\":\\"Required array property\\",\\"type\\":\\"array\\"},\\"required boolean\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20boolean\\",\\"description\\":\\"Required boolean property\\",\\"type\\":\\"boolean\\"},\\"required int\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20int\\",\\"description\\":\\"Required integer property\\",\\"type\\":\\"integer\\"},\\"required number\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20number\\",\\"description\\":\\"Required number property\\",\\"type\\":\\"number\\"},\\"required object\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20object\\",\\"description\\":\\"Required object property\\",\\"key\\":\\"required object\\",\\"properties\\":{},\\"required\\":[],\\"type\\":\\"object\\"},\\"required string\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20string\\",\\"description\\":\\"Required string property\\",\\"type\\":\\"string\\"},\\"required string with regex\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20string%20with%20regex\\",\\"description\\":\\"Required string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"required any\\",\\"required array\\",\\"required boolean\\",\\"required int\\",\\"required number\\",\\"required object\\",\\"required string\\",\\"required string with regex\\"],\\"type\\":\\"object\\"},\\"required string\\":{\\"$id\\":\\"/properties/required%20string\\",\\"description\\":\\"Required string property\\",\\"type\\":\\"string\\"},\\"required string with regex\\":{\\"$id\\":\\"/properties/required%20string%20with%20regex\\",\\"description\\":\\"Required string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"required any\\",\\"required array\\",\\"required boolean\\",\\"required int\\",\\"required number\\",\\"required object\\",\\"required string\\",\\"required string with regex\\",\\"required object with properties\\",\\"required array with properties\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Large Numbers Event' track call.
 * Validates that clients correctly serialize large numbers (integers and floats).
 *
 * @param {TrackMessage<LargeNumbersEvent>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function largeNumbersEvent(
    message: TrackMessage<LargeNumbersEvent>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Large Numbers Event',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Large_Numbers_Event\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Validates that clients correctly serialize large numbers (integers and floats).\\",\\"properties\\":{\\"large nullable optional integer\\":{\\"$id\\":\\"/properties/large%20nullable%20optional%20integer\\",\\"description\\":\\"\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"large nullable optional number\\":{\\"$id\\":\\"/properties/large%20nullable%20optional%20number\\",\\"description\\":\\"\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"large nullable required integer\\":{\\"$id\\":\\"/properties/large%20nullable%20required%20integer\\",\\"description\\":\\"\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"large nullable required number\\":{\\"$id\\":\\"/properties/large%20nullable%20required%20number\\",\\"description\\":\\"\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"large optional integer\\":{\\"$id\\":\\"/properties/large%20optional%20integer\\",\\"description\\":\\"\\",\\"type\\":\\"integer\\"},\\"large optional number\\":{\\"$id\\":\\"/properties/large%20optional%20number\\",\\"description\\":\\"\\",\\"type\\":\\"number\\"},\\"large required integer\\":{\\"$id\\":\\"/properties/large%20required%20integer\\",\\"description\\":\\"\\",\\"type\\":\\"integer\\"},\\"large required number\\":{\\"$id\\":\\"/properties/large%20required%20number\\",\\"description\\":\\"\\",\\"type\\":\\"number\\"}},\\"required\\":[\\"large required integer\\",\\"large required number\\",\\"large nullable required integer\\",\\"large nullable required number\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Nested Arrays' track call.
 * Validates that clients handle arrays-within-arrays.
 *
 * @param {TrackMessage<NestedArrays>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function nestedArrays(
    message: TrackMessage<NestedArrays>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Nested Arrays',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Nested_Arrays\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Validates that clients handle arrays-within-arrays.\\",\\"properties\\":{\\"universeCharacters\\":{\\"$id\\":\\"/properties/universeCharacters\\",\\"description\\":\\"All known characters from each universe.\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/universeCharacters/items\\",\\"description\\":\\"\\",\\"items\\":{\\"description\\":\\"\\",\\"id\\":\\"/properties/properties/properties/universeCharacters/items/items\\",\\"properties\\":{\\"name\\":{\\"description\\":\\"The character's name.\\",\\"id\\":\\"/properties/properties/properties/universeCharacters/items/items/properties/name\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"name\\"],\\"type\\":\\"object\\"},\\"type\\":\\"array\\"},\\"type\\":\\"array\\"}},\\"required\\":[\\"universeCharacters\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Nested Objects' track call.
 * Validates that clients handle objects-within-objects.
 *
 * @param {TrackMessage<NestedObjects>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function nestedObjects(
    message: TrackMessage<NestedObjects>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Nested Objects',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Nested_Objects\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Validates that clients handle objects-within-objects.\\",\\"properties\\":{\\"garage\\":{\\"$id\\":\\"/properties/garage\\",\\"description\\":\\"\\",\\"properties\\":{\\"tunnel\\":{\\"$id\\":\\"/properties/properties/properties/garage/properties/tunnel\\",\\"description\\":\\"\\",\\"properties\\":{\\"subterranean lab\\":{\\"$id\\":\\"/properties/properties/properties/garage/properties/tunnel/properties/subterranean%20lab\\",\\"description\\":\\"\\",\\"properties\\":{\\"jerry's memories\\":{\\"$id\\":\\"/properties/properties/properties/garage/properties/tunnel/properties/subterranean%20lab/properties/jerry's%20memories\\",\\"description\\":\\"\\",\\"type\\":\\"array\\"},\\"morty's memories\\":{\\"$id\\":\\"/properties/properties/properties/garage/properties/tunnel/properties/subterranean%20lab/properties/morty's%20memories\\",\\"description\\":\\"\\",\\"type\\":\\"array\\"},\\"summer's contingency plan\\":{\\"$id\\":\\"/properties/properties/properties/garage/properties/tunnel/properties/subterranean%20lab/properties/summer's%20contingency%20plan\\",\\"description\\":\\"\\",\\"type\\":\\"string\\"}},\\"required\\":[],\\"type\\":\\"object\\"}},\\"required\\":[\\"subterranean lab\\"],\\"type\\":\\"object\\"}},\\"required\\":[\\"tunnel\\"],\\"type\\":\\"object\\"}},\\"required\\":[\\"garage\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Properties Collided' track call.
 * Validates that clients handle collisions in property names within a single event.
 *
 * @param {TrackMessage<PropertiesCollided>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function propertiesCollided(
    message: TrackMessage<PropertiesCollided>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Properties Collided',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Properties_Collided\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Validates that clients handle collisions in property names within a single event.\\",\\"properties\\":{\\"Property Collided\\":{\\"$id\\":\\"/properties/Property%20Collided\\",\\"description\\":\\"\\",\\"type\\":\\"string\\"},\\"property_collided\\":{\\"$id\\":\\"/properties/property_collided\\",\\"description\\":\\"\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"property_collided\\",\\"Property Collided\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Property Object Name Collision #1' track call.
 * Validates that clients handle collisions in object names across multiple events.
 *
 * @param {TrackMessage<PropertyObjectNameCollision1>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function propertyObjectNameCollision1(
    message: TrackMessage<PropertyObjectNameCollision1>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Property Object Name Collision #1',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Property_Object_Name_Collision_1\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Validates that clients handle collisions in object names across multiple events.\\",\\"properties\\":{\\"universe\\":{\\"$id\\":\\"/properties/universe\\",\\"description\\":\\"\\",\\"properties\\":{\\"name\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/name\\",\\"description\\":\\"The common name of this universe.\\",\\"type\\":\\"string\\"},\\"occupants\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/occupants\\",\\"description\\":\\"The most important occupants in this universe.\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/occupants/items\\",\\"description\\":\\"\\",\\"properties\\":{\\"name\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/occupants/items/properties/name\\",\\"description\\":\\"The name of this occupant.\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"name\\"],\\"type\\":\\"object\\"},\\"type\\":\\"array\\"}},\\"required\\":[\\"name\\",\\"occupants\\"],\\"type\\":\\"object\\"}},\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Property Object Name Collision #2' track call.
 * Validates that clients handle collisions in object names across multiple events.
 *
 * @param {TrackMessage<PropertyObjectNameCollision2>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function propertyObjectNameCollision2(
    message: TrackMessage<PropertyObjectNameCollision2>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Property Object Name Collision #2',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Property_Object_Name_Collision_2\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Validates that clients handle collisions in object names across multiple events.\\",\\"properties\\":{\\"universe\\":{\\"$id\\":\\"/properties/universe\\",\\"description\\":\\"\\",\\"properties\\":{\\"name\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/name\\",\\"description\\":\\"The common name of this universe.\\",\\"type\\":\\"string\\"},\\"occupants\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/occupants\\",\\"description\\":\\"The most important occupants in this universe.\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/occupants/items\\",\\"description\\":\\"\\",\\"properties\\":{\\"name\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/occupants/items/properties/name\\",\\"description\\":\\"The name of this occupant.\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"name\\"],\\"type\\":\\"object\\"},\\"type\\":\\"array\\"}},\\"required\\":[\\"name\\",\\"occupants\\"],\\"type\\":\\"object\\"}},\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Property Sanitized' track call.
 * Validates that clients sanitize property names that contain invalid identifier characters.
 *
 * @param {TrackMessage<PropertySanitized>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function propertySanitized(
    message: TrackMessage<PropertySanitized>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Property Sanitized',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Property_Sanitized\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Validates that clients sanitize property names that contain invalid identifier characters.\\",\\"properties\\":{\\"0000---terrible-property-name~!3\\":{\\"$id\\":\\"/properties/0000---terrible-property-name~!3\\",\\"description\\":\\"\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"0000---terrible-property-name~!3\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Simple Array Types' track call.
 * Validates that clients support fields with various types of arrays.
 *
 * @param {TrackMessage<SimpleArrayTypes>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function simpleArrayTypes(
    message: TrackMessage<SimpleArrayTypes>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Simple Array Types',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Simple_Array_Types\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Validates that clients support fields with various types of arrays.\\",\\"properties\\":{\\"any\\":{\\"$id\\":\\"/properties/any\\",\\"description\\":\\"\\",\\"items\\":{\\"description\\":\\"\\"},\\"type\\":\\"array\\"},\\"boolean\\":{\\"$id\\":\\"/properties/boolean\\",\\"description\\":\\"\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/boolean/items\\",\\"description\\":\\"\\",\\"type\\":\\"boolean\\"},\\"type\\":\\"array\\"},\\"integer\\":{\\"$id\\":\\"/properties/integer\\",\\"description\\":\\"\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/integer/items\\",\\"description\\":\\"\\",\\"type\\":\\"integer\\"},\\"type\\":\\"array\\"},\\"nullable\\":{\\"$id\\":\\"/properties/nullable\\",\\"description\\":\\"\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/nullable/items\\",\\"description\\":\\"\\",\\"type\\":[\\"string\\",\\"null\\"]},\\"type\\":\\"array\\"},\\"number\\":{\\"$id\\":\\"/properties/number\\",\\"description\\":\\"\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/number/items\\",\\"description\\":\\"\\",\\"type\\":\\"number\\"},\\"type\\":\\"array\\"},\\"object\\":{\\"$id\\":\\"/properties/object\\",\\"description\\":\\"\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/object/items\\",\\"description\\":\\"\\",\\"properties\\":{\\"name\\":{\\"$id\\":\\"/properties/properties/properties/object/items/properties/name\\",\\"description\\":\\"\\",\\"type\\":\\"string\\"}},\\"required\\":[],\\"type\\":\\"object\\"},\\"type\\":\\"array\\"},\\"string\\":{\\"$id\\":\\"/properties/string\\",\\"description\\":\\"\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/string/items\\",\\"description\\":\\"\\",\\"type\\":\\"string\\"},\\"type\\":\\"array\\"}},\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Union Type' track call.
 * Validates that clients support fields with multiple (union) types.
 *
 * @param {TrackMessage<UnionType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function unionType(
    message: TrackMessage<UnionType>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Union Type',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Union_Type\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Validates that clients support fields with multiple (union) types.\\",\\"properties\\":{\\"universe_name\\":{\\"$id\\":\\"/properties/universe_name\\",\\"description\\":\\"\\",\\"type\\":[\\"string\\",\\"null\\",\\"integer\\"]}},\\"required\\":[\\"universe_name\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'NoID type' track call.
 * Properties without IDs
 *
 * @param {TrackMessage<NoIDType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function noIDType(
    message: TrackMessage<NoIDType>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'NoID type',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"NoID_Type\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"description\\":\\"Properties without IDs\\",\\"properties\\":{\\"no_id_prop\\":{\\"description\\":\\"a property without an ID\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"no_id_prop\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}

const clientAPI = {
    /**
     * Updates the run-time configuration of this Typewriter client.
     * This function must be called with a configured analytics-node instance before firing
     * any analytics calls, or else a \`missingAnalyticsNodeError\` error will be thrown.
     *
     * @param {TypewriterOptions} options - the options to upsert
     *
     * @typedef {Object} TypewriterOptions
     * @property {Analytics} analytics - Underlying analytics instance where analytics
     * 		calls are forwarded on to.
     * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
     * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
     * 		it will throw errors if NODE_ENV=\\"test\\" so that tests will fail if a message does not match the spec. Otherwise, errors
     * 		will be logged to stderr.
     */
    setTypewriterOptions,

    /**
     * Fires a 'Custom Violation Handler' track call.
     * This event is fired in order to trigger a custom violation handler. It should be called with a JSON Schema violation.
     * 
     * @param CustomViolationHandler props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    customViolationHandler,
    /**
     * Fires a 'Default Violation Handler' track call.
     * This event is fired in order to trigger the default violation handler. It should be called with a JSON Schema violation.
     * 
     * @param DefaultViolationHandler props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    defaultViolationHandler,
    /**
     * Fires a 'Enum Types' track call.
     * Validates that client property sanitize enums.
     * 
     * @param EnumTypes props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    enumTypes,
    /**
     * Fires a 'Every Nullable Optional Type' track call.
     * Validates that clients handle all of the supported field types, as nullable optional fields. If a field is null, it is expected to be NOT sent through.
     * 
     * @param EveryNullableOptionalType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    everyNullableOptionalType,
    /**
     * Fires a 'Every Nullable Required Type' track call.
     * Validates that clients handle all of the supported field types, as nullable required fields. If a field is null, it is expected to be sent through.
     * 
     * @param EveryNullableRequiredType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    everyNullableRequiredType,
    /**
     * Fires a 'Every Optional Type' track call.
     * Validates that clients handle all of the supported field types, as optional fields.
     * 
     * @param EveryOptionalType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    everyOptionalType,
    /**
     * Fires a 'Every Required Type' track call.
     * Validates that clients handle all of the supported field types, as required fields.
     * 
     * @param EveryRequiredType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    everyRequiredType,
    /**
     * Fires a 'Large Numbers Event' track call.
     * Validates that clients correctly serialize large numbers (integers and floats).
     * 
     * @param LargeNumbersEvent props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    largeNumbersEvent,
    /**
     * Fires a 'Nested Arrays' track call.
     * Validates that clients handle arrays-within-arrays.
     * 
     * @param NestedArrays props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    nestedArrays,
    /**
     * Fires a 'Nested Objects' track call.
     * Validates that clients handle objects-within-objects.
     * 
     * @param NestedObjects props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    nestedObjects,
    /**
     * Fires a 'Properties Collided' track call.
     * Validates that clients handle collisions in property names within a single event.
     * 
     * @param PropertiesCollided props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    propertiesCollided,
    /**
     * Fires a 'Property Object Name Collision #1' track call.
     * Validates that clients handle collisions in object names across multiple events.
     * 
     * @param PropertyObjectNameCollision1 props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    propertyObjectNameCollision1,
    /**
     * Fires a 'Property Object Name Collision #2' track call.
     * Validates that clients handle collisions in object names across multiple events.
     * 
     * @param PropertyObjectNameCollision2 props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    propertyObjectNameCollision2,
    /**
     * Fires a 'Property Sanitized' track call.
     * Validates that clients sanitize property names that contain invalid identifier characters.
     * 
     * @param PropertySanitized props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    propertySanitized,
    /**
     * Fires a 'Simple Array Types' track call.
     * Validates that clients support fields with various types of arrays.
     * 
     * @param SimpleArrayTypes props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    simpleArrayTypes,
    /**
     * Fires a 'Union Type' track call.
     * Validates that clients support fields with multiple (union) types.
     * 
     * @param UnionType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    unionType,
    /**
     * Fires a 'NoID type' track call.
     * Properties without IDs
     * 
     * @param NoIDType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    noIDType,
};

export default new Proxy<typeof clientAPI>(clientAPI, {
    get(target, method) {
        if (typeof method === 'string' && target.hasOwnProperty(method)) {
            return target[method as keyof typeof clientAPI];
        }

        return () => {
            console.warn(\`  You made an analytics call (\${String(method)}) that can't be found. Either:
         a) Re-generate your typewriter client: \\\\\`npx typewriter\\\\\`
         b) Add it to your Tracking Plan: https://app.segment.com/segment-oscb/protocols/tracking-plans/rs_1zTHJU9fd5mt7cndWnd4PgJbMCE\`);
         const a = analytics()
         if (a) {
             a.track(
                 withTypewriterContext({
                     event: 'Unknown Analytics Call Fired',
                     properties: {
                         method,
                     },
                     userId: 'typewriter',
                 })
             )
         }
        };
    },
});

"
`;

exports[`build builds client Language: typescript, SDK:analytics-node 2`] = `
"// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

export interface CustomViolationHandler {
    \\"regex property\\": string;
}

export interface DefaultViolationHandler {
    \\"regex property\\": string;
}

export interface EnumTypes {
    /**
     * A string property that only accepts a single enum value.
     */
    \\"string const\\"?: StringConst;
    /**
     * A string property that accepts multiple enum values.
     */
    \\"string enum\\"?: StringEnum;
}

/**
 * A string property that only accepts a single enum value.
 */
export enum StringConst {
    RickSanchez = \\"Rick Sanchez\\",
}

/**
 * A string property that accepts multiple enum values.
 */
export enum StringEnum {
    EvilMorty = \\"Evil Morty\\",
    LawyerMorty = \\"Lawyer Morty\\",
}

export interface EveryNullableOptionalType {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[] | null;
    /**
     * Optional array with properties
     */
    \\"optional array with properties\\"?: Array<null | EveryNullableOptionalTypeOptionalArrayWithProperty> | null;
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean | null;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number | null;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number | null;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any } | null;
    /**
     * Optional object with properties
     */
    \\"optional object with properties\\"?: null | EveryNullableOptionalTypeOptionalObjectWithProperties;
    /**
     * Optional string property
     */
    \\"optional string\\"?: null | string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: null | string;
}

export interface EveryNullableOptionalTypeOptionalArrayWithProperty {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[] | null;
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean | null;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number | null;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number | null;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any } | null;
    /**
     * Optional string property
     */
    \\"optional string\\"?: null | string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: null | string;
}

export interface EveryNullableOptionalTypeOptionalObjectWithProperties {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[] | null;
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean | null;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number | null;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number | null;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any } | null;
    /**
     * Optional string property
     */
    \\"optional string\\"?: null | string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: null | string;
}

export interface EveryNullableRequiredType {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[] | null;
    /**
     * Required array with properties
     */
    \\"required array with properties\\": Array<null | EveryNullableRequiredTypeRequiredArrayWithProperty> | null;
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean | null;
    /**
     * Required integer property
     */
    \\"required int\\": number | null;
    /**
     * Required number property
     */
    \\"required number\\": number | null;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any } | null;
    /**
     * Required object with properties
     */
    \\"required object with properties\\": null | EveryNullableRequiredTypeRequiredObjectWithProperties;
    /**
     * Required string property
     */
    \\"required string\\": null | string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": null | string;
}

export interface EveryNullableRequiredTypeRequiredArrayWithProperty {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[] | null;
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean | null;
    /**
     * Required integer property
     */
    \\"required int\\": number | null;
    /**
     * Required number property
     */
    \\"required number\\": number | null;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any } | null;
    /**
     * Required string property
     */
    \\"required string\\": null | string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": null | string;
}

export interface EveryNullableRequiredTypeRequiredObjectWithProperties {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[] | null;
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean | null;
    /**
     * Required integer property
     */
    \\"required int\\": number | null;
    /**
     * Required number property
     */
    \\"required number\\": number | null;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any } | null;
    /**
     * Required string property
     */
    \\"required string\\": null | string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": null | string;
}

export interface EveryOptionalType {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[];
    /**
     * Optional array with properties
     */
    \\"optional array with properties\\"?: OptionalArrayWithPropertyElement[];
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any };
    /**
     * Optional object with properties
     */
    \\"optional object with properties\\"?: EveryOptionalTypeOptionalObjectWithProperties;
    /**
     * Optional string property
     */
    \\"optional string\\"?: string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: string;
}

export interface OptionalArrayWithPropertyElement {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[];
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any };
    /**
     * Optional string property
     */
    \\"optional string\\"?: string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: string;
}

/**
 * Optional object with properties
 */
export interface EveryOptionalTypeOptionalObjectWithProperties {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[];
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any };
    /**
     * Optional string property
     */
    \\"optional string\\"?: string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: string;
}

export interface EveryRequiredType {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[];
    /**
     * Required array with properties
     */
    \\"required array with properties\\": RequiredArrayWithPropertyElement[];
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean;
    /**
     * Required integer property
     */
    \\"required int\\": number;
    /**
     * Required number property
     */
    \\"required number\\": number;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any };
    /**
     * Required object with properties
     */
    \\"required object with properties\\": EveryRequiredTypeRequiredObjectWithProperties;
    /**
     * Required string property
     */
    \\"required string\\": string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": string;
}

export interface RequiredArrayWithPropertyElement {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[];
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean;
    /**
     * Required integer property
     */
    \\"required int\\": number;
    /**
     * Required number property
     */
    \\"required number\\": number;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any };
    /**
     * Required string property
     */
    \\"required string\\": string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": string;
}

/**
 * Required object with properties
 */
export interface EveryRequiredTypeRequiredObjectWithProperties {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[];
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean;
    /**
     * Required integer property
     */
    \\"required int\\": number;
    /**
     * Required number property
     */
    \\"required number\\": number;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any };
    /**
     * Required string property
     */
    \\"required string\\": string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": string;
}

export interface LargeNumbersEvent {
    \\"large nullable optional integer\\"?: number | null;
    \\"large nullable optional number\\"?:  number | null;
    \\"large nullable required integer\\":  number | null;
    \\"large nullable required number\\":   number | null;
    \\"large optional integer\\"?:          number;
    \\"large optional number\\"?:           number;
    \\"large required integer\\":           number;
    \\"large required number\\":            number;
}

export interface NestedArrays {
    /**
     * All known characters from each universe.
     */
    universeCharacters: Array<UniverseCharacter[]>;
}

export interface UniverseCharacter {
    /**
     * The character's name.
     */
    name: string;
}

export interface NestedObjects {
    garage: Garage;
}

export interface Garage {
    tunnel: Tunnel;
}

export interface Tunnel {
    \\"subterranean lab\\": SubterraneanLab;
}

export interface SubterraneanLab {
    \\"jerry's memories\\"?:          any[];
    \\"morty's memories\\"?:          any[];
    \\"summer's contingency plan\\"?: string;
}

export interface PropertiesCollided {
    \\"Property Collided\\": string;
    property_collided:   string;
}

export interface PropertyObjectNameCollision1 {
    universe?: PropertyObjectNameCollision1_Universe;
}

export interface PropertyObjectNameCollision1_Universe {
    /**
     * The common name of this universe.
     */
    name: string;
    /**
     * The most important occupants in this universe.
     */
    occupants: PurpleOccupant[];
}

export interface PurpleOccupant {
    /**
     * The name of this occupant.
     */
    name: string;
}

export interface PropertyObjectNameCollision2 {
    universe?: PropertyObjectNameCollision2_Universe;
}

export interface PropertyObjectNameCollision2_Universe {
    /**
     * The common name of this universe.
     */
    name: string;
    /**
     * The most important occupants in this universe.
     */
    occupants: FluffyOccupant[];
}

export interface FluffyOccupant {
    /**
     * The name of this occupant.
     */
    name: string;
}

export interface PropertySanitized {
    \\"0000---terrible-property-name~!3\\": string;
}

export interface SimpleArrayTypes {
    any?:      any[];
    boolean?:  boolean[];
    integer?:  number[];
    nullable?: Array<null | string>;
    number?:   number[];
    object?:   Object[];
    string?:   string[];
}

export interface Object {
    name?: string;
}

export interface UnionType {
    universe_name: number | null | string;
}

/**
 * Ajv is a peer dependency for development builds. It's used to apply run-time validation
 * to message payloads before passing them on to the underlying analytics instance.
 *
 * Note that the production bundle does not depend on Ajv.
 * 
 * You can install it with: \`npm install --save-dev ajv\`.
 */
import Ajv, { ErrorObject } from 'ajv'
import { Analytics, TrackParams } from '@segment/analytics-node'

/**
 * An ID associated with the user. Note: at least one of userId or anonymousId must be included!
 **/
type Identity =
    | { userId: string; anonymousId?: string }
    | { userId?: string; anonymousId: string }

/**
 * TrackMessage represents a message payload for an analytics \`.track()\` call.
 * See: https://segment.com/docs/spec/track/
 */
export type TrackMessage<PropertiesType> = Omit<
    TrackParams,
    'event' | 'properties'
> & { event?: string, properties: PropertiesType } & Identity

/** The callback exposed by analytics-node. */
export type Callback = Parameters<Analytics['track']>[1]

export type ViolationHandler = (
    message: TrackMessage<Record<string, any>>,
    violations: ErrorObject[]
) => void

/**
 * The default handler that is fired if none is supplied with setTypewriterOptions.
 * If NODE_ENV=\\"test\\", this handler will throw an error. Otherwise, it will log
 * a warning message to the console.
 */
 export const defaultValidationErrorHandler: ViolationHandler = (
    message,
    violations
) => {
    const msg = JSON.stringify(
        {
            type: 'Typewriter JSON Schema Validation Error',
            description:
                \`You made an analytics call (\${message.event}) using Typewriter that doesn't match the \` +
                'Tracking Plan spec.',
            errors: violations,
        },
        undefined,
        2
    )

    if (process.env.NODE_ENV === 'test') {
        throw new Error(msg)
    }
    console.warn(msg)
}

let onViolation = defaultValidationErrorHandler

const missingAnalyticsNodeError = new Error(\`You must set an analytics-node instance:

>	import { Analytics } from '@segment/analytics-node'
>	import { setTypewriterOptions } from './analytics'
>
> const analytics = new Analytics({ writeKey: 'SEGMENT_WRITE_KEY' })
>	setTypewriterOptions({ analytics: analytics	})

For more information on @segment/analytics-node, see: https://segment.com/docs/sources/server/node/quickstart/
\`)

let analytics: () => Analytics | undefined = () => {
    throw missingAnalyticsNodeError
}

/** Options to customize the runtime behavior of a Typewriter client. */
export interface TypewriterOptions {
    /**
     * Underlying analytics instance where analytics calls are forwarded on to.
     */
    analytics: Analytics
    /**
     * Handler fired when if an event does not match its spec. This handler
     * does not fire in production mode, because it requires inlining the full
     * JSON Schema spec for each event in your Tracking Plan.
     *
     * By default, it will throw errors if NODE_ENV = \\"test\\" so that tests will fail
     * if a message does not match the spec. Otherwise, errors will be logged to stderr.
     */
    onViolation?: ViolationHandler
}

/**
 * Updates the run-time configuration of this Typewriter client.
 * This function must be called with a configured analytics-node instance before firing
 * any analytics calls, or else a \`missingAnalyticsNodeError\` error will be thrown.
 *
 * @param {TypewriterOptions} options - the options to upsert
 *
 * @typedef {Object} TypewriterOptions
 * @property {Analytics} analytics - Underlying analytics instance where analytics
 * 		calls are forwarded on to.
 * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
 * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
 * 		it will throw errors if NODE_ENV=\\"test\\" so that tests will fail if a message does not match the spec. Otherwise, errors
 * 		will be logged to stderr.
 */
export function setTypewriterOptions(options: TypewriterOptions) {
    analytics = options.analytics ? () => options.analytics : analytics
    onViolation = options.onViolation || onViolation
}

/**
    * Validates a message against a JSON Schema using Ajv. If the message
    * is invalid, the \`onViolation\` handler will be called.
    */
function validateAgainstSchema(
    message: TrackMessage<Record<string, any>>,
    schema: object
) {
    const ajv = new Ajv({ allErrors: true, verbose: true })

    if (!ajv.validate(schema, message.properties) && ajv.errors) {
        onViolation(message, ajv.errors)
    }
}

/**
 * Helper to attach metadata on Typewriter to outbound requests.
 * This is used for attribution and debugging by the Segment team.
 */
function withTypewriterContext<P extends Record<string, any>, T extends TrackMessage<P>>(
    message: T
) {
    return {
        ...message,
        context: {
            ...(message.context || {}),
            typewriter: {
                language: 'typescript',
                
            },
        },
    }
}


/**
 * Fires a 'Custom Violation Handler' track call.
 * 
 *
 * @param {TrackMessage<CustomViolationHandler>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function customViolationHandler(
    message: TrackMessage<CustomViolationHandler>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Custom Violation Handler',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Custom_Violation_Handler\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"regex property\\":{\\"$id\\":\\"/properties/regex%20property\\",\\"description\\":\\"\\",\\"pattern\\":\\"Lawyer Morty|Evil Morty\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"regex property\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Default Violation Handler' track call.
 * 
 *
 * @param {TrackMessage<DefaultViolationHandler>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function defaultViolationHandler(
    message: TrackMessage<DefaultViolationHandler>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Default Violation Handler',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Default_Violation_Handler\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"regex property\\":{\\"$id\\":\\"/properties/regex%20property\\",\\"description\\":\\"\\",\\"pattern\\":\\"Lawyer Morty|Evil Morty\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"regex property\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Enum Types' track call.
 * 
 *
 * @param {TrackMessage<EnumTypes>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function enumTypes(
    message: TrackMessage<EnumTypes>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Enum Types',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Enum_Types\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"string const\\":{\\"$id\\":\\"/properties/string%20const\\",\\"description\\":\\"A string property that only accepts a single enum value.\\",\\"enum\\":[\\"Rick Sanchez\\"],\\"type\\":\\"string\\"},\\"string enum\\":{\\"$id\\":\\"/properties/string%20enum\\",\\"description\\":\\"A string property that accepts multiple enum values.\\",\\"enum\\":[\\"Evil Morty\\",\\"Lawyer Morty\\"],\\"type\\":\\"string\\"}},\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Every Nullable Optional Type' track call.
 * 
 *
 * @param {TrackMessage<EveryNullableOptionalType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function everyNullableOptionalType(
    message: TrackMessage<EveryNullableOptionalType>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Every Nullable Optional Type',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Every_Nullable_Optional_Type\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"optional any\\":{\\"$id\\":\\"/properties/optional%20any\\",\\"description\\":\\"Optional any property\\"},\\"optional array\\":{\\"$id\\":\\"/properties/optional%20array\\",\\"description\\":\\"Optional array property\\",\\"type\\":[\\"array\\",\\"null\\"]},\\"optional array with properties\\":{\\"$id\\":\\"/properties/optional%20array%20with%20properties\\",\\"description\\":\\"Optional array with properties\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items\\",\\"properties\\":{\\"optional any\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20any\\",\\"description\\":\\"Optional any property\\"},\\"optional array\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20array\\",\\"description\\":\\"Optional array property\\",\\"type\\":[\\"array\\",\\"null\\"]},\\"optional boolean\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20boolean\\",\\"description\\":\\"Optional boolean property\\",\\"type\\":[\\"boolean\\",\\"null\\"]},\\"optional int\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20int\\",\\"description\\":\\"Optional integer property\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"optional number\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20number\\",\\"description\\":\\"Optional number property\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"optional object\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20object\\",\\"description\\":\\"Optional object property\\",\\"properties\\":{},\\"required\\":[],\\"type\\":[\\"object\\",\\"null\\"]},\\"optional string\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20string\\",\\"description\\":\\"Optional string property\\",\\"type\\":[\\"string\\",\\"null\\"]},\\"optional string with regex\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20string%20with%20regex\\",\\"description\\":\\"Optional string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":[\\"string\\",\\"null\\"]}},\\"type\\":[\\"object\\",\\"null\\"]},\\"type\\":[\\"array\\",\\"null\\"]},\\"optional boolean\\":{\\"$id\\":\\"/properties/optional%20boolean\\",\\"description\\":\\"Optional boolean property\\",\\"type\\":[\\"boolean\\",\\"null\\"]},\\"optional int\\":{\\"$id\\":\\"/properties/optional%20int\\",\\"description\\":\\"Optional integer property\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"optional number\\":{\\"$id\\":\\"/properties/optional%20number\\",\\"description\\":\\"Optional number property\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"optional object\\":{\\"$id\\":\\"/properties/optional%20object\\",\\"description\\":\\"Optional object property\\",\\"properties\\":{},\\"required\\":[],\\"type\\":[\\"object\\",\\"null\\"]},\\"optional object with properties\\":{\\"$id\\":\\"/properties/optional%20object%20with%20properties\\",\\"description\\":\\"Optional object with properties\\",\\"properties\\":{\\"optional any\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20any\\",\\"description\\":\\"Optional any property\\"},\\"optional array\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20array\\",\\"description\\":\\"Optional array property\\",\\"type\\":[\\"array\\",\\"null\\"]},\\"optional boolean\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20boolean\\",\\"description\\":\\"Optional boolean property\\",\\"type\\":[\\"boolean\\",\\"null\\"]},\\"optional int\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20int\\",\\"description\\":\\"Optional integer property\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"optional number\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20number\\",\\"description\\":\\"Optional number property\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"optional object\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20object\\",\\"description\\":\\"Optional object property\\",\\"properties\\":{},\\"required\\":[],\\"type\\":[\\"object\\",\\"null\\"]},\\"optional string\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20string\\",\\"description\\":\\"Optional string property\\",\\"type\\":[\\"string\\",\\"null\\"]},\\"optional string with regex\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20string%20with%20regex\\",\\"description\\":\\"Optional string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":[\\"string\\",\\"null\\"]}},\\"required\\":[],\\"type\\":[\\"object\\",\\"null\\"]},\\"optional string\\":{\\"$id\\":\\"/properties/optional%20string\\",\\"description\\":\\"Optional string property\\",\\"type\\":[\\"string\\",\\"null\\"]},\\"optional string with regex\\":{\\"$id\\":\\"/properties/optional%20string%20with%20regex\\",\\"description\\":\\"Optional string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":[\\"string\\",\\"null\\"]}},\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Every Nullable Required Type' track call.
 * 
 *
 * @param {TrackMessage<EveryNullableRequiredType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function everyNullableRequiredType(
    message: TrackMessage<EveryNullableRequiredType>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Every Nullable Required Type',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Every_Nullable_Required_Type\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"required any\\":{\\"$id\\":\\"/properties/required%20any\\",\\"description\\":\\"Required any property\\"},\\"required array\\":{\\"$id\\":\\"/properties/required%20array\\",\\"description\\":\\"Required array property\\",\\"type\\":[\\"array\\",\\"null\\"]},\\"required array with properties\\":{\\"$id\\":\\"/properties/required%20array%20with%20properties\\",\\"description\\":\\"Required array with properties\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items\\",\\"properties\\":{\\"required any\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20any\\",\\"description\\":\\"Required any property\\"},\\"required array\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20array\\",\\"description\\":\\"Required array property\\",\\"type\\":[\\"array\\",\\"null\\"]},\\"required boolean\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20boolean\\",\\"description\\":\\"Required boolean property\\",\\"type\\":[\\"boolean\\",\\"null\\"]},\\"required int\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20int\\",\\"description\\":\\"Required integer property\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"required number\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20number\\",\\"description\\":\\"Required number property\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"required object\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20object\\",\\"description\\":\\"Required object property\\",\\"properties\\":{},\\"required\\":[],\\"type\\":[\\"object\\",\\"null\\"]},\\"required string\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20string\\",\\"description\\":\\"Required string property\\",\\"type\\":[\\"string\\",\\"null\\"]},\\"required string with regex\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20string%20with%20regex\\",\\"description\\":\\"Required string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":[\\"string\\",\\"null\\"]}},\\"required\\":[\\"required any\\",\\"required array\\",\\"required boolean\\",\\"required int\\",\\"required number\\",\\"required object\\",\\"required string\\",\\"required string with regex\\"],\\"type\\":[\\"object\\",\\"null\\"]},\\"type\\":[\\"array\\",\\"null\\"]},\\"required boolean\\":{\\"$id\\":\\"/properties/required%20boolean\\",\\"description\\":\\"Required boolean property\\",\\"type\\":[\\"boolean\\",\\"null\\"]},\\"required int\\":{\\"$id\\":\\"/properties/required%20int\\",\\"description\\":\\"Required integer property\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"required number\\":{\\"$id\\":\\"/properties/required%20number\\",\\"description\\":\\"Required number property\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"required object\\":{\\"$id\\":\\"/properties/required%20object\\",\\"description\\":\\"Required object property\\",\\"properties\\":{},\\"required\\":[],\\"type\\":[\\"object\\",\\"null\\"]},\\"required object with properties\\":{\\"$id\\":\\"/properties/required%20object%20with%20properties\\",\\"description\\":\\"Required object with properties\\",\\"properties\\":{\\"required any\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20any\\",\\"description\\":\\"Required any property\\"},\\"required array\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20array\\",\\"description\\":\\"Required array property\\",\\"type\\":[\\"array\\",\\"null\\"]},\\"required boolean\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20boolean\\",\\"description\\":\\"Required boolean property\\",\\"type\\":[\\"boolean\\",\\"null\\"]},\\"required int\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20int\\",\\"description\\":\\"Required integer property\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"required number\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20number\\",\\"description\\":\\"Required number property\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"required object\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20object\\",\\"description\\":\\"Required object property\\",\\"properties\\":{},\\"required\\":[],\\"type\\":[\\"object\\",\\"null\\"]},\\"required string\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20string\\",\\"description\\":\\"Required string property\\",\\"type\\":[\\"string\\",\\"null\\"]},\\"required string with regex\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20string%20with%20regex\\",\\"description\\":\\"Required string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":[\\"string\\",\\"null\\"]}},\\"required\\":[\\"required any\\",\\"required array\\",\\"required boolean\\",\\"required int\\",\\"required number\\",\\"required object\\",\\"required string\\",\\"required string with regex\\"],\\"type\\":[\\"object\\",\\"null\\"]},\\"required string\\":{\\"$id\\":\\"/properties/required%20string\\",\\"description\\":\\"Required string property\\",\\"type\\":[\\"string\\",\\"null\\"]},\\"required string with regex\\":{\\"$id\\":\\"/properties/required%20string%20with%20regex\\",\\"description\\":\\"Required string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":[\\"string\\",\\"null\\"]}},\\"required\\":[\\"required any\\",\\"required array\\",\\"required boolean\\",\\"required int\\",\\"required number\\",\\"required object\\",\\"required string\\",\\"required string with regex\\",\\"required object with properties\\",\\"required array with properties\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Every Optional Type' track call.
 * 
 *
 * @param {TrackMessage<EveryOptionalType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function everyOptionalType(
    message: TrackMessage<EveryOptionalType>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Every Optional Type',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Every_Optional_Type\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"optional any\\":{\\"$id\\":\\"/properties/optional%20any\\",\\"description\\":\\"Optional any property\\"},\\"optional array\\":{\\"$id\\":\\"/properties/optional%20array\\",\\"description\\":\\"Optional array property\\",\\"type\\":\\"array\\"},\\"optional array with properties\\":{\\"$id\\":\\"/properties/optional%20array%20with%20properties\\",\\"description\\":\\"Optional array with properties\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items\\",\\"properties\\":{\\"optional any\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20any\\",\\"description\\":\\"Optional any property\\"},\\"optional array\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20array\\",\\"description\\":\\"Optional array property\\",\\"type\\":\\"array\\"},\\"optional boolean\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20boolean\\",\\"description\\":\\"Optional boolean property\\",\\"type\\":\\"boolean\\"},\\"optional int\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20int\\",\\"description\\":\\"Optional integer property\\",\\"type\\":\\"integer\\"},\\"optional number\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20number\\",\\"description\\":\\"Optional number property\\",\\"type\\":\\"number\\"},\\"optional object\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20object\\",\\"description\\":\\"Optional object property\\",\\"key\\":\\"optional object\\",\\"properties\\":{},\\"type\\":\\"object\\"},\\"optional string\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20string\\",\\"description\\":\\"Optional string property\\",\\"type\\":\\"string\\"},\\"optional string with regex\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20string%20with%20regex\\",\\"description\\":\\"Optional string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":\\"string\\"}},\\"type\\":\\"object\\"},\\"type\\":\\"array\\"},\\"optional boolean\\":{\\"$id\\":\\"/properties/optional%20boolean\\",\\"description\\":\\"Optional boolean property\\",\\"type\\":\\"boolean\\"},\\"optional int\\":{\\"$id\\":\\"/properties/optional%20int\\",\\"description\\":\\"Optional integer property\\",\\"type\\":\\"integer\\"},\\"optional number\\":{\\"$id\\":\\"/properties/optional%20number\\",\\"description\\":\\"Optional number property\\",\\"type\\":\\"number\\"},\\"optional object\\":{\\"$id\\":\\"/properties/optional%20object\\",\\"description\\":\\"Optional object property\\",\\"key\\":\\"optional object\\",\\"properties\\":{},\\"type\\":\\"object\\"},\\"optional object with properties\\":{\\"$id\\":\\"/properties/optional%20object%20with%20properties\\",\\"description\\":\\"Optional object with properties\\",\\"properties\\":{\\"optional any\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20any\\",\\"description\\":\\"Optional any property\\"},\\"optional array\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20array\\",\\"description\\":\\"Optional array property\\",\\"type\\":\\"array\\"},\\"optional boolean\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20boolean\\",\\"description\\":\\"Optional boolean property\\",\\"type\\":\\"boolean\\"},\\"optional int\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20int\\",\\"description\\":\\"Optional integer property\\",\\"type\\":\\"integer\\"},\\"optional number\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20number\\",\\"description\\":\\"Optional number property\\",\\"type\\":\\"number\\"},\\"optional object\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20object\\",\\"description\\":\\"Optional object property\\",\\"key\\":\\"optional object\\",\\"properties\\":{},\\"type\\":\\"object\\"},\\"optional string\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20string\\",\\"description\\":\\"Optional string property\\",\\"type\\":\\"string\\"},\\"optional string with regex\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20string%20with%20regex\\",\\"description\\":\\"Optional string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":\\"string\\"}},\\"type\\":\\"object\\"},\\"optional string\\":{\\"$id\\":\\"/properties/optional%20string\\",\\"description\\":\\"Optional string property\\",\\"type\\":\\"string\\"},\\"optional string with regex\\":{\\"$id\\":\\"/properties/optional%20string%20with%20regex\\",\\"description\\":\\"Optional string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":\\"string\\"}},\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Every Required Type' track call.
 * 
 *
 * @param {TrackMessage<EveryRequiredType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function everyRequiredType(
    message: TrackMessage<EveryRequiredType>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Every Required Type',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Every_Required_Type\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"required any\\":{\\"$id\\":\\"/properties/required%20any\\",\\"description\\":\\"Required any property\\"},\\"required array\\":{\\"$id\\":\\"/properties/required%20array\\",\\"description\\":\\"Required array property\\",\\"type\\":\\"array\\"},\\"required array with properties\\":{\\"$id\\":\\"/properties/required%20array%20with%20properties\\",\\"description\\":\\"Required array with properties\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items\\",\\"properties\\":{\\"required any\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20any\\",\\"description\\":\\"Required any property\\"},\\"required array\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20array\\",\\"description\\":\\"Required array property\\",\\"type\\":\\"array\\"},\\"required boolean\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20boolean\\",\\"description\\":\\"Required boolean property\\",\\"type\\":\\"boolean\\"},\\"required int\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20int\\",\\"description\\":\\"Required integer property\\",\\"type\\":\\"integer\\"},\\"required number\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20number\\",\\"description\\":\\"Required number property\\",\\"type\\":\\"number\\"},\\"required object\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20object\\",\\"description\\":\\"Required object property\\",\\"key\\":\\"required object\\",\\"properties\\":{},\\"required\\":[],\\"type\\":\\"object\\"},\\"required string\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20string\\",\\"description\\":\\"Required string property\\",\\"type\\":\\"string\\"},\\"required string with regex\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20string%20with%20regex\\",\\"description\\":\\"Required string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"required any\\",\\"required array\\",\\"required boolean\\",\\"required int\\",\\"required number\\",\\"required object\\",\\"required string\\",\\"required string with regex\\"],\\"type\\":\\"object\\"},\\"type\\":\\"array\\"},\\"required boolean\\":{\\"$id\\":\\"/properties/required%20boolean\\",\\"description\\":\\"Required boolean property\\",\\"type\\":\\"boolean\\"},\\"required int\\":{\\"$id\\":\\"/properties/required%20int\\",\\"description\\":\\"Required integer property\\",\\"type\\":\\"integer\\"},\\"required number\\":{\\"$id\\":\\"/properties/required%20number\\",\\"description\\":\\"Required number property\\",\\"type\\":\\"number\\"},\\"required object\\":{\\"$id\\":\\"/properties/required%20object\\",\\"description\\":\\"Required object property\\",\\"key\\":\\"required object\\",\\"properties\\":{},\\"required\\":[],\\"type\\":\\"object\\"},\\"required object with properties\\":{\\"$id\\":\\"/properties/required%20object%20with%20properties\\",\\"description\\":\\"Required object with properties\\",\\"properties\\":{\\"required any\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20any\\",\\"description\\":\\"Required any property\\"},\\"required array\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20array\\",\\"description\\":\\"Required array property\\",\\"type\\":\\"array\\"},\\"required boolean\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20boolean\\",\\"description\\":\\"Required boolean property\\",\\"type\\":\\"boolean\\"},\\"required int\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20int\\",\\"description\\":\\"Required integer property\\",\\"type\\":\\"integer\\"},\\"required number\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20number\\",\\"description\\":\\"Required number property\\",\\"type\\":\\"number\\"},\\"required object\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20object\\",\\"description\\":\\"Required object property\\",\\"key\\":\\"required object\\",\\"properties\\":{},\\"required\\":[],\\"type\\":\\"object\\"},\\"required string\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20string\\",\\"description\\":\\"Required string property\\",\\"type\\":\\"string\\"},\\"required string with regex\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20string%20with%20regex\\",\\"description\\":\\"Required string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"required any\\",\\"required array\\",\\"required boolean\\",\\"required int\\",\\"required number\\",\\"required object\\",\\"required string\\",\\"required string with regex\\"],\\"type\\":\\"object\\"},\\"required string\\":{\\"$id\\":\\"/properties/required%20string\\",\\"description\\":\\"Required string property\\",\\"type\\":\\"string\\"},\\"required string with regex\\":{\\"$id\\":\\"/properties/required%20string%20with%20regex\\",\\"description\\":\\"Required string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"required any\\",\\"required array\\",\\"required boolean\\",\\"required int\\",\\"required number\\",\\"required object\\",\\"required string\\",\\"required string with regex\\",\\"required object with properties\\",\\"required array with properties\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Large Numbers Event' track call.
 * 
 *
 * @param {TrackMessage<LargeNumbersEvent>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function largeNumbersEvent(
    message: TrackMessage<LargeNumbersEvent>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Large Numbers Event',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Large_Numbers_Event\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"large nullable optional integer\\":{\\"$id\\":\\"/properties/large%20nullable%20optional%20integer\\",\\"description\\":\\"\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"large nullable optional number\\":{\\"$id\\":\\"/properties/large%20nullable%20optional%20number\\",\\"description\\":\\"\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"large nullable required integer\\":{\\"$id\\":\\"/properties/large%20nullable%20required%20integer\\",\\"description\\":\\"\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"large nullable required number\\":{\\"$id\\":\\"/properties/large%20nullable%20required%20number\\",\\"description\\":\\"\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"large optional integer\\":{\\"$id\\":\\"/properties/large%20optional%20integer\\",\\"description\\":\\"\\",\\"type\\":\\"integer\\"},\\"large optional number\\":{\\"$id\\":\\"/properties/large%20optional%20number\\",\\"description\\":\\"\\",\\"type\\":\\"number\\"},\\"large required integer\\":{\\"$id\\":\\"/properties/large%20required%20integer\\",\\"description\\":\\"\\",\\"type\\":\\"integer\\"},\\"large required number\\":{\\"$id\\":\\"/properties/large%20required%20number\\",\\"description\\":\\"\\",\\"type\\":\\"number\\"}},\\"required\\":[\\"large required integer\\",\\"large required number\\",\\"large nullable required integer\\",\\"large nullable required number\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Nested Arrays' track call.
 * 
 *
 * @param {TrackMessage<NestedArrays>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function nestedArrays(
    message: TrackMessage<NestedArrays>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Nested Arrays',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Nested_Arrays\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"universeCharacters\\":{\\"$id\\":\\"/properties/universeCharacters\\",\\"description\\":\\"All known characters from each universe.\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/universeCharacters/items\\",\\"description\\":\\"\\",\\"items\\":{\\"description\\":\\"\\",\\"id\\":\\"/properties/properties/properties/universeCharacters/items/items\\",\\"properties\\":{\\"name\\":{\\"description\\":\\"The character's name.\\",\\"id\\":\\"/properties/properties/properties/universeCharacters/items/items/properties/name\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"name\\"],\\"type\\":\\"object\\"},\\"type\\":\\"array\\"},\\"type\\":\\"array\\"}},\\"required\\":[\\"universeCharacters\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Nested Objects' track call.
 * 
 *
 * @param {TrackMessage<NestedObjects>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function nestedObjects(
    message: TrackMessage<NestedObjects>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Nested Objects',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Nested_Objects\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"garage\\":{\\"$id\\":\\"/properties/garage\\",\\"description\\":\\"\\",\\"properties\\":{\\"tunnel\\":{\\"$id\\":\\"/properties/properties/properties/garage/properties/tunnel\\",\\"description\\":\\"\\",\\"properties\\":{\\"subterranean lab\\":{\\"$id\\":\\"/properties/properties/properties/garage/properties/tunnel/properties/subterranean%20lab\\",\\"description\\":\\"\\",\\"properties\\":{\\"jerry's memories\\":{\\"$id\\":\\"/properties/properties/properties/garage/properties/tunnel/properties/subterranean%20lab/properties/jerry's%20memories\\",\\"description\\":\\"\\",\\"type\\":\\"array\\"},\\"morty's memories\\":{\\"$id\\":\\"/properties/properties/properties/garage/properties/tunnel/properties/subterranean%20lab/properties/morty's%20memories\\",\\"description\\":\\"\\",\\"type\\":\\"array\\"},\\"summer's contingency plan\\":{\\"$id\\":\\"/properties/properties/properties/garage/properties/tunnel/properties/subterranean%20lab/properties/summer's%20contingency%20plan\\",\\"description\\":\\"\\",\\"type\\":\\"string\\"}},\\"required\\":[],\\"type\\":\\"object\\"}},\\"required\\":[\\"subterranean lab\\"],\\"type\\":\\"object\\"}},\\"required\\":[\\"tunnel\\"],\\"type\\":\\"object\\"}},\\"required\\":[\\"garage\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Properties Collided' track call.
 * 
 *
 * @param {TrackMessage<PropertiesCollided>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function propertiesCollided(
    message: TrackMessage<PropertiesCollided>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Properties Collided',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Properties_Collided\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"Property Collided\\":{\\"$id\\":\\"/properties/Property%20Collided\\",\\"description\\":\\"\\",\\"type\\":\\"string\\"},\\"property_collided\\":{\\"$id\\":\\"/properties/property_collided\\",\\"description\\":\\"\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"property_collided\\",\\"Property Collided\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Property Object Name Collision #1' track call.
 * 
 *
 * @param {TrackMessage<PropertyObjectNameCollision1>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function propertyObjectNameCollision1(
    message: TrackMessage<PropertyObjectNameCollision1>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Property Object Name Collision #1',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Property_Object_Name_Collision_1\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"universe\\":{\\"$id\\":\\"/properties/universe\\",\\"description\\":\\"\\",\\"properties\\":{\\"name\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/name\\",\\"description\\":\\"The common name of this universe.\\",\\"type\\":\\"string\\"},\\"occupants\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/occupants\\",\\"description\\":\\"The most important occupants in this universe.\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/occupants/items\\",\\"description\\":\\"\\",\\"properties\\":{\\"name\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/occupants/items/properties/name\\",\\"description\\":\\"The name of this occupant.\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"name\\"],\\"type\\":\\"object\\"},\\"type\\":\\"array\\"}},\\"required\\":[\\"name\\",\\"occupants\\"],\\"type\\":\\"object\\"}},\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Property Object Name Collision #2' track call.
 * 
 *
 * @param {TrackMessage<PropertyObjectNameCollision2>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function propertyObjectNameCollision2(
    message: TrackMessage<PropertyObjectNameCollision2>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Property Object Name Collision #2',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Property_Object_Name_Collision_2\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"universe\\":{\\"$id\\":\\"/properties/universe\\",\\"description\\":\\"\\",\\"properties\\":{\\"name\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/name\\",\\"description\\":\\"The common name of this universe.\\",\\"type\\":\\"string\\"},\\"occupants\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/occupants\\",\\"description\\":\\"The most important occupants in this universe.\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/occupants/items\\",\\"description\\":\\"\\",\\"properties\\":{\\"name\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/occupants/items/properties/name\\",\\"description\\":\\"The name of this occupant.\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"name\\"],\\"type\\":\\"object\\"},\\"type\\":\\"array\\"}},\\"required\\":[\\"name\\",\\"occupants\\"],\\"type\\":\\"object\\"}},\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Property Sanitized' track call.
 * 
 *
 * @param {TrackMessage<PropertySanitized>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function propertySanitized(
    message: TrackMessage<PropertySanitized>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Property Sanitized',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Property_Sanitized\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"0000---terrible-property-name~!3\\":{\\"$id\\":\\"/properties/0000---terrible-property-name~!3\\",\\"description\\":\\"\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"0000---terrible-property-name~!3\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Simple Array Types' track call.
 * 
 *
 * @param {TrackMessage<SimpleArrayTypes>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function simpleArrayTypes(
    message: TrackMessage<SimpleArrayTypes>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Simple Array Types',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Simple_Array_Types\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"any\\":{\\"$id\\":\\"/properties/any\\",\\"description\\":\\"\\",\\"items\\":{\\"description\\":\\"\\"},\\"type\\":\\"array\\"},\\"boolean\\":{\\"$id\\":\\"/properties/boolean\\",\\"description\\":\\"\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/boolean/items\\",\\"description\\":\\"\\",\\"type\\":\\"boolean\\"},\\"type\\":\\"array\\"},\\"integer\\":{\\"$id\\":\\"/properties/integer\\",\\"description\\":\\"\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/integer/items\\",\\"description\\":\\"\\",\\"type\\":\\"integer\\"},\\"type\\":\\"array\\"},\\"nullable\\":{\\"$id\\":\\"/properties/nullable\\",\\"description\\":\\"\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/nullable/items\\",\\"description\\":\\"\\",\\"type\\":[\\"string\\",\\"null\\"]},\\"type\\":\\"array\\"},\\"number\\":{\\"$id\\":\\"/properties/number\\",\\"description\\":\\"\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/number/items\\",\\"description\\":\\"\\",\\"type\\":\\"number\\"},\\"type\\":\\"array\\"},\\"object\\":{\\"$id\\":\\"/properties/object\\",\\"description\\":\\"\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/object/items\\",\\"description\\":\\"\\",\\"properties\\":{\\"name\\":{\\"$id\\":\\"/properties/properties/properties/object/items/properties/name\\",\\"description\\":\\"\\",\\"type\\":\\"string\\"}},\\"required\\":[],\\"type\\":\\"object\\"},\\"type\\":\\"array\\"},\\"string\\":{\\"$id\\":\\"/properties/string\\",\\"description\\":\\"\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/string/items\\",\\"description\\":\\"\\",\\"type\\":\\"string\\"},\\"type\\":\\"array\\"}},\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Union Type' track call.
 * 
 *
 * @param {TrackMessage<UnionType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function unionType(
    message: TrackMessage<UnionType>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Union Type',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Union_Type\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"universe_name\\":{\\"$id\\":\\"/properties/universe_name\\",\\"description\\":\\"\\",\\"type\\":[\\"string\\",\\"null\\",\\"integer\\"]}},\\"required\\":[\\"universe_name\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}

const clientAPI = {
    /**
     * Updates the run-time configuration of this Typewriter client.
     * This function must be called with a configured analytics-node instance before firing
     * any analytics calls, or else a \`missingAnalyticsNodeError\` error will be thrown.
     *
     * @param {TypewriterOptions} options - the options to upsert
     *
     * @typedef {Object} TypewriterOptions
     * @property {Analytics} analytics - Underlying analytics instance where analytics
     * 		calls are forwarded on to.
     * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
     * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
     * 		it will throw errors if NODE_ENV=\\"test\\" so that tests will fail if a message does not match the spec. Otherwise, errors
     * 		will be logged to stderr.
     */
    setTypewriterOptions,

    /**
     * Fires a 'Custom Violation Handler' track call.
     * 
     * 
     * @param CustomViolationHandler props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    customViolationHandler,
    /**
     * Fires a 'Default Violation Handler' track call.
     * 
     * 
     * @param DefaultViolationHandler props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    defaultViolationHandler,
    /**
     * Fires a 'Enum Types' track call.
     * 
     * 
     * @param EnumTypes props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    enumTypes,
    /**
     * Fires a 'Every Nullable Optional Type' track call.
     * 
     * 
     * @param EveryNullableOptionalType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    everyNullableOptionalType,
    /**
     * Fires a 'Every Nullable Required Type' track call.
     * 
     * 
     * @param EveryNullableRequiredType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    everyNullableRequiredType,
    /**
     * Fires a 'Every Optional Type' track call.
     * 
     * 
     * @param EveryOptionalType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    everyOptionalType,
    /**
     * Fires a 'Every Required Type' track call.
     * 
     * 
     * @param EveryRequiredType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    everyRequiredType,
    /**
     * Fires a 'Large Numbers Event' track call.
     * 
     * 
     * @param LargeNumbersEvent props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    largeNumbersEvent,
    /**
     * Fires a 'Nested Arrays' track call.
     * 
     * 
     * @param NestedArrays props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    nestedArrays,
    /**
     * Fires a 'Nested Objects' track call.
     * 
     * 
     * @param NestedObjects props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    nestedObjects,
    /**
     * Fires a 'Properties Collided' track call.
     * 
     * 
     * @param PropertiesCollided props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    propertiesCollided,
    /**
     * Fires a 'Property Object Name Collision #1' track call.
     * 
     * 
     * @param PropertyObjectNameCollision1 props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    propertyObjectNameCollision1,
    /**
     * Fires a 'Property Object Name Collision #2' track call.
     * 
     * 
     * @param PropertyObjectNameCollision2 props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    propertyObjectNameCollision2,
    /**
     * Fires a 'Property Sanitized' track call.
     * 
     * 
     * @param PropertySanitized props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    propertySanitized,
    /**
     * Fires a 'Simple Array Types' track call.
     * 
     * 
     * @param SimpleArrayTypes props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    simpleArrayTypes,
    /**
     * Fires a 'Union Type' track call.
     * 
     * 
     * @param UnionType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    unionType,
};

export default new Proxy<typeof clientAPI>(clientAPI, {
    get(target, method) {
        if (typeof method === 'string' && target.hasOwnProperty(method)) {
            return target[method as keyof typeof clientAPI];
        }

        return () => {
            console.warn(\`  You made an analytics call (\${String(method)}) that can't be found. Either:
         a) Re-generate your typewriter client: \\\\\`npx typewriter\\\\\`
         b) Add it to your Tracking Plan: https://app.segment.com/segment-oscb/protocols/tracking-plans/rs_1zTHJU9fd5mt7cndWnd4PgJbMCE\`);
         const a = analytics()
         if (a) {
             a.track(
                 withTypewriterContext({
                     event: 'Unknown Analytics Call Fired',
                     properties: {
                         method,
                     },
                     userId: 'typewriter',
                 })
             )
         }
        };
    },
});

"
`;

exports[`build builds client Language: typescript, SDK:analytics-node 3`] = `
"// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

export interface CustomViolationHandler {
    \\"regex property\\": string;
}

export interface DefaultViolationHandler {
    \\"regex property\\": string;
}

export interface EnumTypes {
    /**
     * A string property that only accepts a single enum value.
     */
    \\"string const\\"?: StringConst;
    /**
     * A string property that accepts multiple enum values.
     */
    \\"string enum\\"?: StringEnum;
}

/**
 * A string property that only accepts a single enum value.
 */
export enum StringConst {
    RickSanchez = \\"Rick Sanchez\\",
}

/**
 * A string property that accepts multiple enum values.
 */
export enum StringEnum {
    EvilMorty = \\"Evil Morty\\",
    LawyerMorty = \\"Lawyer Morty\\",
}

export interface EveryNullableOptionalType {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[] | null;
    /**
     * Optional array with properties
     */
    \\"optional array with properties\\"?: Array<null | EveryNullableOptionalTypeOptionalArrayWithProperty> | null;
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean | null;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number | null;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number | null;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any } | null;
    /**
     * Optional object with properties
     */
    \\"optional object with properties\\"?: null | EveryNullableOptionalTypeOptionalObjectWithProperties;
    /**
     * Optional string property
     */
    \\"optional string\\"?: null | string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: null | string;
}

export interface EveryNullableOptionalTypeOptionalArrayWithProperty {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[] | null;
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean | null;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number | null;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number | null;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any } | null;
    /**
     * Optional string property
     */
    \\"optional string\\"?: null | string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: null | string;
}

export interface EveryNullableOptionalTypeOptionalObjectWithProperties {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[] | null;
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean | null;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number | null;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number | null;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any } | null;
    /**
     * Optional string property
     */
    \\"optional string\\"?: null | string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: null | string;
}

export interface EveryNullableRequiredType {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[] | null;
    /**
     * Required array with properties
     */
    \\"required array with properties\\": Array<null | EveryNullableRequiredTypeRequiredArrayWithProperty> | null;
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean | null;
    /**
     * Required integer property
     */
    \\"required int\\": number | null;
    /**
     * Required number property
     */
    \\"required number\\": number | null;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any } | null;
    /**
     * Required object with properties
     */
    \\"required object with properties\\": null | EveryNullableRequiredTypeRequiredObjectWithProperties;
    /**
     * Required string property
     */
    \\"required string\\": null | string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": null | string;
}

export interface EveryNullableRequiredTypeRequiredArrayWithProperty {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[] | null;
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean | null;
    /**
     * Required integer property
     */
    \\"required int\\": number | null;
    /**
     * Required number property
     */
    \\"required number\\": number | null;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any } | null;
    /**
     * Required string property
     */
    \\"required string\\": null | string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": null | string;
}

export interface EveryNullableRequiredTypeRequiredObjectWithProperties {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[] | null;
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean | null;
    /**
     * Required integer property
     */
    \\"required int\\": number | null;
    /**
     * Required number property
     */
    \\"required number\\": number | null;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any } | null;
    /**
     * Required string property
     */
    \\"required string\\": null | string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": null | string;
}

export interface EveryOptionalType {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[];
    /**
     * Optional array with properties
     */
    \\"optional array with properties\\"?: OptionalArrayWithPropertyElement[];
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any };
    /**
     * Optional object with properties
     */
    \\"optional object with properties\\"?: EveryOptionalTypeOptionalObjectWithProperties;
    /**
     * Optional string property
     */
    \\"optional string\\"?: string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: string;
}

export interface OptionalArrayWithPropertyElement {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[];
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any };
    /**
     * Optional string property
     */
    \\"optional string\\"?: string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: string;
}

/**
 * Optional object with properties
 */
export interface EveryOptionalTypeOptionalObjectWithProperties {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[];
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any };
    /**
     * Optional string property
     */
    \\"optional string\\"?: string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: string;
}

export interface EveryRequiredType {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[];
    /**
     * Required array with properties
     */
    \\"required array with properties\\": RequiredArrayWithPropertyElement[];
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean;
    /**
     * Required integer property
     */
    \\"required int\\": number;
    /**
     * Required number property
     */
    \\"required number\\": number;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any };
    /**
     * Required object with properties
     */
    \\"required object with properties\\": EveryRequiredTypeRequiredObjectWithProperties;
    /**
     * Required string property
     */
    \\"required string\\": string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": string;
}

export interface RequiredArrayWithPropertyElement {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[];
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean;
    /**
     * Required integer property
     */
    \\"required int\\": number;
    /**
     * Required number property
     */
    \\"required number\\": number;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any };
    /**
     * Required string property
     */
    \\"required string\\": string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": string;
}

/**
 * Required object with properties
 */
export interface EveryRequiredTypeRequiredObjectWithProperties {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[];
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean;
    /**
     * Required integer property
     */
    \\"required int\\": number;
    /**
     * Required number property
     */
    \\"required number\\": number;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any };
    /**
     * Required string property
     */
    \\"required string\\": string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": string;
}

export interface LargeNumbersEvent {
    \\"large nullable optional integer\\"?: number | null;
    \\"large nullable optional number\\"?:  number | null;
    \\"large nullable required integer\\":  number | null;
    \\"large nullable required number\\":   number | null;
    \\"large optional integer\\"?:          number;
    \\"large optional number\\"?:           number;
    \\"large required integer\\":           number;
    \\"large required number\\":            number;
}

export interface NestedArrays {
    /**
     * All known characters from each universe.
     */
    universeCharacters: Array<UniverseCharacter[]>;
}

export interface UniverseCharacter {
    /**
     * The character's name.
     */
    name: string;
}

export interface NestedObjects {
    garage: Garage;
}

export interface Garage {
    tunnel: Tunnel;
}

export interface Tunnel {
    \\"subterranean lab\\": SubterraneanLab;
}

export interface SubterraneanLab {
    \\"jerry's memories\\"?:          any[];
    \\"morty's memories\\"?:          any[];
    \\"summer's contingency plan\\"?: string;
}

export interface PropertiesCollided {
    \\"Property Collided\\": string;
    property_collided:   string;
}

export interface PropertyObjectNameCollision1 {
    universe?: PropertyObjectNameCollision1_Universe;
}

export interface PropertyObjectNameCollision1_Universe {
    /**
     * The common name of this universe.
     */
    name: string;
    /**
     * The most important occupants in this universe.
     */
    occupants: PurpleOccupant[];
}

export interface PurpleOccupant {
    /**
     * The name of this occupant.
     */
    name: string;
}

export interface PropertyObjectNameCollision2 {
    universe?: PropertyObjectNameCollision2_Universe;
}

export interface PropertyObjectNameCollision2_Universe {
    /**
     * The common name of this universe.
     */
    name: string;
    /**
     * The most important occupants in this universe.
     */
    occupants: FluffyOccupant[];
}

export interface FluffyOccupant {
    /**
     * The name of this occupant.
     */
    name: string;
}

export interface PropertySanitized {
    \\"0000---terrible-property-name~!3\\": string;
}

export interface SimpleArrayTypes {
    any?:      any[];
    boolean?:  boolean[];
    integer?:  number[];
    nullable?: Array<null | string>;
    number?:   number[];
    object?:   Object[];
    string?:   string[];
}

export interface Object {
    name?: string;
}

export interface UnionType {
    universe_name: number | null | string;
}

/**
 * Ajv is a peer dependency for development builds. It's used to apply run-time validation
 * to message payloads before passing them on to the underlying analytics instance.
 *
 * Note that the production bundle does not depend on Ajv.
 * 
 * You can install it with: \`npm install --save-dev ajv\`.
 */
import Ajv, { ErrorObject } from 'ajv'
import { Analytics, TrackParams } from '@segment/analytics-node'

/**
 * An ID associated with the user. Note: at least one of userId or anonymousId must be included!
 **/
type Identity =
    | { userId: string; anonymousId?: string }
    | { userId?: string; anonymousId: string }

/**
 * TrackMessage represents a message payload for an analytics \`.track()\` call.
 * See: https://segment.com/docs/spec/track/
 */
export type TrackMessage<PropertiesType> = Omit<
    TrackParams,
    'event' | 'properties'
> & { event?: string, properties: PropertiesType } & Identity

/** The callback exposed by analytics-node. */
export type Callback = Parameters<Analytics['track']>[1]

export type ViolationHandler = (
    message: TrackMessage<Record<string, any>>,
    violations: ErrorObject[]
) => void

/**
 * The default handler that is fired if none is supplied with setTypewriterOptions.
 * If NODE_ENV=\\"test\\", this handler will throw an error. Otherwise, it will log
 * a warning message to the console.
 */
 export const defaultValidationErrorHandler: ViolationHandler = (
    message,
    violations
) => {
    const msg = JSON.stringify(
        {
            type: 'Typewriter JSON Schema Validation Error',
            description:
                \`You made an analytics call (\${message.event}) using Typewriter that doesn't match the \` +
                'Tracking Plan spec.',
            errors: violations,
        },
        undefined,
        2
    )

    if (process.env.NODE_ENV === 'test') {
        throw new Error(msg)
    }
    console.warn(msg)
}

let onViolation = defaultValidationErrorHandler

const missingAnalyticsNodeError = new Error(\`You must set an analytics-node instance:

>	import { Analytics } from '@segment/analytics-node'
>	import { setTypewriterOptions } from './analytics'
>
> const analytics = new Analytics({ writeKey: 'SEGMENT_WRITE_KEY' })
>	setTypewriterOptions({ analytics: analytics	})

For more information on @segment/analytics-node, see: https://segment.com/docs/sources/server/node/quickstart/
\`)

let analytics: () => Analytics | undefined = () => {
    throw missingAnalyticsNodeError
}

/** Options to customize the runtime behavior of a Typewriter client. */
export interface TypewriterOptions {
    /**
     * Underlying analytics instance where analytics calls are forwarded on to.
     */
    analytics: Analytics
    /**
     * Handler fired when if an event does not match its spec. This handler
     * does not fire in production mode, because it requires inlining the full
     * JSON Schema spec for each event in your Tracking Plan.
     *
     * By default, it will throw errors if NODE_ENV = \\"test\\" so that tests will fail
     * if a message does not match the spec. Otherwise, errors will be logged to stderr.
     */
    onViolation?: ViolationHandler
}

/**
 * Updates the run-time configuration of this Typewriter client.
 * This function must be called with a configured analytics-node instance before firing
 * any analytics calls, or else a \`missingAnalyticsNodeError\` error will be thrown.
 *
 * @param {TypewriterOptions} options - the options to upsert
 *
 * @typedef {Object} TypewriterOptions
 * @property {Analytics} analytics - Underlying analytics instance where analytics
 * 		calls are forwarded on to.
 * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
 * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
 * 		it will throw errors if NODE_ENV=\\"test\\" so that tests will fail if a message does not match the spec. Otherwise, errors
 * 		will be logged to stderr.
 */
export function setTypewriterOptions(options: TypewriterOptions) {
    analytics = options.analytics ? () => options.analytics : analytics
    onViolation = options.onViolation || onViolation
}

/**
    * Validates a message against a JSON Schema using Ajv. If the message
    * is invalid, the \`onViolation\` handler will be called.
    */
function validateAgainstSchema(
    message: TrackMessage<Record<string, any>>,
    schema: object
) {
    const ajv = new Ajv({ allErrors: true, verbose: true })

    if (!ajv.validate(schema, message.properties) && ajv.errors) {
        onViolation(message, ajv.errors)
    }
}

/**
 * Helper to attach metadata on Typewriter to outbound requests.
 * This is used for attribution and debugging by the Segment team.
 */
function withTypewriterContext<P extends Record<string, any>, T extends TrackMessage<P>>(
    message: T
) {
    return {
        ...message,
        context: {
            ...(message.context || {}),
            typewriter: {
                language: 'typescript',
                
            },
        },
    }
}


/**
 * Fires a 'Custom Violation Handler' track call.
 * 
 *
 * @param {TrackMessage<CustomViolationHandler>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function customViolationHandler(
    message: TrackMessage<CustomViolationHandler>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Custom Violation Handler',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Custom_Violation_Handler\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"regex property\\":{\\"$id\\":\\"/properties/regex%20property\\",\\"description\\":\\"\\",\\"pattern\\":\\"Lawyer Morty|Evil Morty\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"regex property\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Default Violation Handler' track call.
 * 
 *
 * @param {TrackMessage<DefaultViolationHandler>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function defaultViolationHandler(
    message: TrackMessage<DefaultViolationHandler>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Default Violation Handler',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Default_Violation_Handler\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"regex property\\":{\\"$id\\":\\"/properties/regex%20property\\",\\"description\\":\\"\\",\\"pattern\\":\\"Lawyer Morty|Evil Morty\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"regex property\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Enum Types' track call.
 * 
 *
 * @param {TrackMessage<EnumTypes>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function enumTypes(
    message: TrackMessage<EnumTypes>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Enum Types',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Enum_Types\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"string const\\":{\\"$id\\":\\"/properties/string%20const\\",\\"description\\":\\"A string property that only accepts a single enum value.\\",\\"enum\\":[\\"Rick Sanchez\\"],\\"type\\":\\"string\\"},\\"string enum\\":{\\"$id\\":\\"/properties/string%20enum\\",\\"description\\":\\"A string property that accepts multiple enum values.\\",\\"enum\\":[\\"Evil Morty\\",\\"Lawyer Morty\\"],\\"type\\":\\"string\\"}},\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Every Nullable Optional Type' track call.
 * 
 *
 * @param {TrackMessage<EveryNullableOptionalType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function everyNullableOptionalType(
    message: TrackMessage<EveryNullableOptionalType>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Every Nullable Optional Type',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Every_Nullable_Optional_Type\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"optional any\\":{\\"$id\\":\\"/properties/optional%20any\\",\\"description\\":\\"Optional any property\\"},\\"optional array\\":{\\"$id\\":\\"/properties/optional%20array\\",\\"description\\":\\"Optional array property\\",\\"type\\":[\\"array\\",\\"null\\"]},\\"optional array with properties\\":{\\"$id\\":\\"/properties/optional%20array%20with%20properties\\",\\"description\\":\\"Optional array with properties\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items\\",\\"properties\\":{\\"optional any\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20any\\",\\"description\\":\\"Optional any property\\"},\\"optional array\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20array\\",\\"description\\":\\"Optional array property\\",\\"type\\":[\\"array\\",\\"null\\"]},\\"optional boolean\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20boolean\\",\\"description\\":\\"Optional boolean property\\",\\"type\\":[\\"boolean\\",\\"null\\"]},\\"optional int\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20int\\",\\"description\\":\\"Optional integer property\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"optional number\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20number\\",\\"description\\":\\"Optional number property\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"optional object\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20object\\",\\"description\\":\\"Optional object property\\",\\"properties\\":{},\\"required\\":[],\\"type\\":[\\"object\\",\\"null\\"]},\\"optional string\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20string\\",\\"description\\":\\"Optional string property\\",\\"type\\":[\\"string\\",\\"null\\"]},\\"optional string with regex\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20string%20with%20regex\\",\\"description\\":\\"Optional string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":[\\"string\\",\\"null\\"]}},\\"type\\":[\\"object\\",\\"null\\"]},\\"type\\":[\\"array\\",\\"null\\"]},\\"optional boolean\\":{\\"$id\\":\\"/properties/optional%20boolean\\",\\"description\\":\\"Optional boolean property\\",\\"type\\":[\\"boolean\\",\\"null\\"]},\\"optional int\\":{\\"$id\\":\\"/properties/optional%20int\\",\\"description\\":\\"Optional integer property\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"optional number\\":{\\"$id\\":\\"/properties/optional%20number\\",\\"description\\":\\"Optional number property\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"optional object\\":{\\"$id\\":\\"/properties/optional%20object\\",\\"description\\":\\"Optional object property\\",\\"properties\\":{},\\"required\\":[],\\"type\\":[\\"object\\",\\"null\\"]},\\"optional object with properties\\":{\\"$id\\":\\"/properties/optional%20object%20with%20properties\\",\\"description\\":\\"Optional object with properties\\",\\"properties\\":{\\"optional any\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20any\\",\\"description\\":\\"Optional any property\\"},\\"optional array\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20array\\",\\"description\\":\\"Optional array property\\",\\"type\\":[\\"array\\",\\"null\\"]},\\"optional boolean\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20boolean\\",\\"description\\":\\"Optional boolean property\\",\\"type\\":[\\"boolean\\",\\"null\\"]},\\"optional int\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20int\\",\\"description\\":\\"Optional integer property\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"optional number\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20number\\",\\"description\\":\\"Optional number property\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"optional object\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20object\\",\\"description\\":\\"Optional object property\\",\\"properties\\":{},\\"required\\":[],\\"type\\":[\\"object\\",\\"null\\"]},\\"optional string\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20string\\",\\"description\\":\\"Optional string property\\",\\"type\\":[\\"string\\",\\"null\\"]},\\"optional string with regex\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20string%20with%20regex\\",\\"description\\":\\"Optional string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":[\\"string\\",\\"null\\"]}},\\"required\\":[],\\"type\\":[\\"object\\",\\"null\\"]},\\"optional string\\":{\\"$id\\":\\"/properties/optional%20string\\",\\"description\\":\\"Optional string property\\",\\"type\\":[\\"string\\",\\"null\\"]},\\"optional string with regex\\":{\\"$id\\":\\"/properties/optional%20string%20with%20regex\\",\\"description\\":\\"Optional string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":[\\"string\\",\\"null\\"]}},\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Every Nullable Required Type' track call.
 * 
 *
 * @param {TrackMessage<EveryNullableRequiredType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function everyNullableRequiredType(
    message: TrackMessage<EveryNullableRequiredType>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Every Nullable Required Type',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Every_Nullable_Required_Type\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"required any\\":{\\"$id\\":\\"/properties/required%20any\\",\\"description\\":\\"Required any property\\"},\\"required array\\":{\\"$id\\":\\"/properties/required%20array\\",\\"description\\":\\"Required array property\\",\\"type\\":[\\"array\\",\\"null\\"]},\\"required array with properties\\":{\\"$id\\":\\"/properties/required%20array%20with%20properties\\",\\"description\\":\\"Required array with properties\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items\\",\\"properties\\":{\\"required any\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20any\\",\\"description\\":\\"Required any property\\"},\\"required array\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20array\\",\\"description\\":\\"Required array property\\",\\"type\\":[\\"array\\",\\"null\\"]},\\"required boolean\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20boolean\\",\\"description\\":\\"Required boolean property\\",\\"type\\":[\\"boolean\\",\\"null\\"]},\\"required int\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20int\\",\\"description\\":\\"Required integer property\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"required number\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20number\\",\\"description\\":\\"Required number property\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"required object\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20object\\",\\"description\\":\\"Required object property\\",\\"properties\\":{},\\"required\\":[],\\"type\\":[\\"object\\",\\"null\\"]},\\"required string\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20string\\",\\"description\\":\\"Required string property\\",\\"type\\":[\\"string\\",\\"null\\"]},\\"required string with regex\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20string%20with%20regex\\",\\"description\\":\\"Required string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":[\\"string\\",\\"null\\"]}},\\"required\\":[\\"required any\\",\\"required array\\",\\"required boolean\\",\\"required int\\",\\"required number\\",\\"required object\\",\\"required string\\",\\"required string with regex\\"],\\"type\\":[\\"object\\",\\"null\\"]},\\"type\\":[\\"array\\",\\"null\\"]},\\"required boolean\\":{\\"$id\\":\\"/properties/required%20boolean\\",\\"description\\":\\"Required boolean property\\",\\"type\\":[\\"boolean\\",\\"null\\"]},\\"required int\\":{\\"$id\\":\\"/properties/required%20int\\",\\"description\\":\\"Required integer property\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"required number\\":{\\"$id\\":\\"/properties/required%20number\\",\\"description\\":\\"Required number property\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"required object\\":{\\"$id\\":\\"/properties/required%20object\\",\\"description\\":\\"Required object property\\",\\"properties\\":{},\\"required\\":[],\\"type\\":[\\"object\\",\\"null\\"]},\\"required object with properties\\":{\\"$id\\":\\"/properties/required%20object%20with%20properties\\",\\"description\\":\\"Required object with properties\\",\\"properties\\":{\\"required any\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20any\\",\\"description\\":\\"Required any property\\"},\\"required array\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20array\\",\\"description\\":\\"Required array property\\",\\"type\\":[\\"array\\",\\"null\\"]},\\"required boolean\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20boolean\\",\\"description\\":\\"Required boolean property\\",\\"type\\":[\\"boolean\\",\\"null\\"]},\\"required int\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20int\\",\\"description\\":\\"Required integer property\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"required number\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20number\\",\\"description\\":\\"Required number property\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"required object\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20object\\",\\"description\\":\\"Required object property\\",\\"properties\\":{},\\"required\\":[],\\"type\\":[\\"object\\",\\"null\\"]},\\"required string\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20string\\",\\"description\\":\\"Required string property\\",\\"type\\":[\\"string\\",\\"null\\"]},\\"required string with regex\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20string%20with%20regex\\",\\"description\\":\\"Required string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":[\\"string\\",\\"null\\"]}},\\"required\\":[\\"required any\\",\\"required array\\",\\"required boolean\\",\\"required int\\",\\"required number\\",\\"required object\\",\\"required string\\",\\"required string with regex\\"],\\"type\\":[\\"object\\",\\"null\\"]},\\"required string\\":{\\"$id\\":\\"/properties/required%20string\\",\\"description\\":\\"Required string property\\",\\"type\\":[\\"string\\",\\"null\\"]},\\"required string with regex\\":{\\"$id\\":\\"/properties/required%20string%20with%20regex\\",\\"description\\":\\"Required string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":[\\"string\\",\\"null\\"]}},\\"required\\":[\\"required any\\",\\"required array\\",\\"required boolean\\",\\"required int\\",\\"required number\\",\\"required object\\",\\"required string\\",\\"required string with regex\\",\\"required object with properties\\",\\"required array with properties\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Every Optional Type' track call.
 * 
 *
 * @param {TrackMessage<EveryOptionalType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function everyOptionalType(
    message: TrackMessage<EveryOptionalType>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Every Optional Type',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Every_Optional_Type\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"optional any\\":{\\"$id\\":\\"/properties/optional%20any\\",\\"description\\":\\"Optional any property\\"},\\"optional array\\":{\\"$id\\":\\"/properties/optional%20array\\",\\"description\\":\\"Optional array property\\",\\"type\\":\\"array\\"},\\"optional array with properties\\":{\\"$id\\":\\"/properties/optional%20array%20with%20properties\\",\\"description\\":\\"Optional array with properties\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items\\",\\"properties\\":{\\"optional any\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20any\\",\\"description\\":\\"Optional any property\\"},\\"optional array\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20array\\",\\"description\\":\\"Optional array property\\",\\"type\\":\\"array\\"},\\"optional boolean\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20boolean\\",\\"description\\":\\"Optional boolean property\\",\\"type\\":\\"boolean\\"},\\"optional int\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20int\\",\\"description\\":\\"Optional integer property\\",\\"type\\":\\"integer\\"},\\"optional number\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20number\\",\\"description\\":\\"Optional number property\\",\\"type\\":\\"number\\"},\\"optional object\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20object\\",\\"description\\":\\"Optional object property\\",\\"key\\":\\"optional object\\",\\"properties\\":{},\\"type\\":\\"object\\"},\\"optional string\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20string\\",\\"description\\":\\"Optional string property\\",\\"type\\":\\"string\\"},\\"optional string with regex\\":{\\"$id\\":\\"/properties/properties/properties/optional%20array%20with%20properties/items/properties/optional%20string%20with%20regex\\",\\"description\\":\\"Optional string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":\\"string\\"}},\\"type\\":\\"object\\"},\\"type\\":\\"array\\"},\\"optional boolean\\":{\\"$id\\":\\"/properties/optional%20boolean\\",\\"description\\":\\"Optional boolean property\\",\\"type\\":\\"boolean\\"},\\"optional int\\":{\\"$id\\":\\"/properties/optional%20int\\",\\"description\\":\\"Optional integer property\\",\\"type\\":\\"integer\\"},\\"optional number\\":{\\"$id\\":\\"/properties/optional%20number\\",\\"description\\":\\"Optional number property\\",\\"type\\":\\"number\\"},\\"optional object\\":{\\"$id\\":\\"/properties/optional%20object\\",\\"description\\":\\"Optional object property\\",\\"key\\":\\"optional object\\",\\"properties\\":{},\\"type\\":\\"object\\"},\\"optional object with properties\\":{\\"$id\\":\\"/properties/optional%20object%20with%20properties\\",\\"description\\":\\"Optional object with properties\\",\\"properties\\":{\\"optional any\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20any\\",\\"description\\":\\"Optional any property\\"},\\"optional array\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20array\\",\\"description\\":\\"Optional array property\\",\\"type\\":\\"array\\"},\\"optional boolean\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20boolean\\",\\"description\\":\\"Optional boolean property\\",\\"type\\":\\"boolean\\"},\\"optional int\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20int\\",\\"description\\":\\"Optional integer property\\",\\"type\\":\\"integer\\"},\\"optional number\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20number\\",\\"description\\":\\"Optional number property\\",\\"type\\":\\"number\\"},\\"optional object\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20object\\",\\"description\\":\\"Optional object property\\",\\"key\\":\\"optional object\\",\\"properties\\":{},\\"type\\":\\"object\\"},\\"optional string\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20string\\",\\"description\\":\\"Optional string property\\",\\"type\\":\\"string\\"},\\"optional string with regex\\":{\\"$id\\":\\"/properties/properties/properties/optional%20object%20with%20properties/properties/optional%20string%20with%20regex\\",\\"description\\":\\"Optional string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":\\"string\\"}},\\"type\\":\\"object\\"},\\"optional string\\":{\\"$id\\":\\"/properties/optional%20string\\",\\"description\\":\\"Optional string property\\",\\"type\\":\\"string\\"},\\"optional string with regex\\":{\\"$id\\":\\"/properties/optional%20string%20with%20regex\\",\\"description\\":\\"Optional string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":\\"string\\"}},\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Every Required Type' track call.
 * 
 *
 * @param {TrackMessage<EveryRequiredType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function everyRequiredType(
    message: TrackMessage<EveryRequiredType>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Every Required Type',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Every_Required_Type\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"required any\\":{\\"$id\\":\\"/properties/required%20any\\",\\"description\\":\\"Required any property\\"},\\"required array\\":{\\"$id\\":\\"/properties/required%20array\\",\\"description\\":\\"Required array property\\",\\"type\\":\\"array\\"},\\"required array with properties\\":{\\"$id\\":\\"/properties/required%20array%20with%20properties\\",\\"description\\":\\"Required array with properties\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items\\",\\"properties\\":{\\"required any\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20any\\",\\"description\\":\\"Required any property\\"},\\"required array\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20array\\",\\"description\\":\\"Required array property\\",\\"type\\":\\"array\\"},\\"required boolean\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20boolean\\",\\"description\\":\\"Required boolean property\\",\\"type\\":\\"boolean\\"},\\"required int\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20int\\",\\"description\\":\\"Required integer property\\",\\"type\\":\\"integer\\"},\\"required number\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20number\\",\\"description\\":\\"Required number property\\",\\"type\\":\\"number\\"},\\"required object\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20object\\",\\"description\\":\\"Required object property\\",\\"key\\":\\"required object\\",\\"properties\\":{},\\"required\\":[],\\"type\\":\\"object\\"},\\"required string\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20string\\",\\"description\\":\\"Required string property\\",\\"type\\":\\"string\\"},\\"required string with regex\\":{\\"$id\\":\\"/properties/properties/properties/required%20array%20with%20properties/items/properties/required%20string%20with%20regex\\",\\"description\\":\\"Required string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"required any\\",\\"required array\\",\\"required boolean\\",\\"required int\\",\\"required number\\",\\"required object\\",\\"required string\\",\\"required string with regex\\"],\\"type\\":\\"object\\"},\\"type\\":\\"array\\"},\\"required boolean\\":{\\"$id\\":\\"/properties/required%20boolean\\",\\"description\\":\\"Required boolean property\\",\\"type\\":\\"boolean\\"},\\"required int\\":{\\"$id\\":\\"/properties/required%20int\\",\\"description\\":\\"Required integer property\\",\\"type\\":\\"integer\\"},\\"required number\\":{\\"$id\\":\\"/properties/required%20number\\",\\"description\\":\\"Required number property\\",\\"type\\":\\"number\\"},\\"required object\\":{\\"$id\\":\\"/properties/required%20object\\",\\"description\\":\\"Required object property\\",\\"key\\":\\"required object\\",\\"properties\\":{},\\"required\\":[],\\"type\\":\\"object\\"},\\"required object with properties\\":{\\"$id\\":\\"/properties/required%20object%20with%20properties\\",\\"description\\":\\"Required object with properties\\",\\"properties\\":{\\"required any\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20any\\",\\"description\\":\\"Required any property\\"},\\"required array\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20array\\",\\"description\\":\\"Required array property\\",\\"type\\":\\"array\\"},\\"required boolean\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20boolean\\",\\"description\\":\\"Required boolean property\\",\\"type\\":\\"boolean\\"},\\"required int\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20int\\",\\"description\\":\\"Required integer property\\",\\"type\\":\\"integer\\"},\\"required number\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20number\\",\\"description\\":\\"Required number property\\",\\"type\\":\\"number\\"},\\"required object\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20object\\",\\"description\\":\\"Required object property\\",\\"key\\":\\"required object\\",\\"properties\\":{},\\"required\\":[],\\"type\\":\\"object\\"},\\"required string\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20string\\",\\"description\\":\\"Required string property\\",\\"type\\":\\"string\\"},\\"required string with regex\\":{\\"$id\\":\\"/properties/properties/properties/required%20object%20with%20properties/properties/required%20string%20with%20regex\\",\\"description\\":\\"Required string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"required any\\",\\"required array\\",\\"required boolean\\",\\"required int\\",\\"required number\\",\\"required object\\",\\"required string\\",\\"required string with regex\\"],\\"type\\":\\"object\\"},\\"required string\\":{\\"$id\\":\\"/properties/required%20string\\",\\"description\\":\\"Required string property\\",\\"type\\":\\"string\\"},\\"required string with regex\\":{\\"$id\\":\\"/properties/required%20string%20with%20regex\\",\\"description\\":\\"Required string property with a regex conditional\\",\\"pattern\\":\\"Evil Morty|Lawyer Morty\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"required any\\",\\"required array\\",\\"required boolean\\",\\"required int\\",\\"required number\\",\\"required object\\",\\"required string\\",\\"required string with regex\\",\\"required object with properties\\",\\"required array with properties\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Large Numbers Event' track call.
 * 
 *
 * @param {TrackMessage<LargeNumbersEvent>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function largeNumbersEvent(
    message: TrackMessage<LargeNumbersEvent>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Large Numbers Event',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Large_Numbers_Event\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"large nullable optional integer\\":{\\"$id\\":\\"/properties/large%20nullable%20optional%20integer\\",\\"description\\":\\"\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"large nullable optional number\\":{\\"$id\\":\\"/properties/large%20nullable%20optional%20number\\",\\"description\\":\\"\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"large nullable required integer\\":{\\"$id\\":\\"/properties/large%20nullable%20required%20integer\\",\\"description\\":\\"\\",\\"type\\":[\\"integer\\",\\"null\\"]},\\"large nullable required number\\":{\\"$id\\":\\"/properties/large%20nullable%20required%20number\\",\\"description\\":\\"\\",\\"type\\":[\\"number\\",\\"null\\"]},\\"large optional integer\\":{\\"$id\\":\\"/properties/large%20optional%20integer\\",\\"description\\":\\"\\",\\"type\\":\\"integer\\"},\\"large optional number\\":{\\"$id\\":\\"/properties/large%20optional%20number\\",\\"description\\":\\"\\",\\"type\\":\\"number\\"},\\"large required integer\\":{\\"$id\\":\\"/properties/large%20required%20integer\\",\\"description\\":\\"\\",\\"type\\":\\"integer\\"},\\"large required number\\":{\\"$id\\":\\"/properties/large%20required%20number\\",\\"description\\":\\"\\",\\"type\\":\\"number\\"}},\\"required\\":[\\"large required integer\\",\\"large required number\\",\\"large nullable required integer\\",\\"large nullable required number\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Nested Arrays' track call.
 * 
 *
 * @param {TrackMessage<NestedArrays>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function nestedArrays(
    message: TrackMessage<NestedArrays>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Nested Arrays',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Nested_Arrays\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"universeCharacters\\":{\\"$id\\":\\"/properties/universeCharacters\\",\\"description\\":\\"All known characters from each universe.\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/universeCharacters/items\\",\\"description\\":\\"\\",\\"items\\":{\\"description\\":\\"\\",\\"id\\":\\"/properties/properties/properties/universeCharacters/items/items\\",\\"properties\\":{\\"name\\":{\\"description\\":\\"The character's name.\\",\\"id\\":\\"/properties/properties/properties/universeCharacters/items/items/properties/name\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"name\\"],\\"type\\":\\"object\\"},\\"type\\":\\"array\\"},\\"type\\":\\"array\\"}},\\"required\\":[\\"universeCharacters\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Nested Objects' track call.
 * 
 *
 * @param {TrackMessage<NestedObjects>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function nestedObjects(
    message: TrackMessage<NestedObjects>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Nested Objects',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Nested_Objects\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"garage\\":{\\"$id\\":\\"/properties/garage\\",\\"description\\":\\"\\",\\"properties\\":{\\"tunnel\\":{\\"$id\\":\\"/properties/properties/properties/garage/properties/tunnel\\",\\"description\\":\\"\\",\\"properties\\":{\\"subterranean lab\\":{\\"$id\\":\\"/properties/properties/properties/garage/properties/tunnel/properties/subterranean%20lab\\",\\"description\\":\\"\\",\\"properties\\":{\\"jerry's memories\\":{\\"$id\\":\\"/properties/properties/properties/garage/properties/tunnel/properties/subterranean%20lab/properties/jerry's%20memories\\",\\"description\\":\\"\\",\\"type\\":\\"array\\"},\\"morty's memories\\":{\\"$id\\":\\"/properties/properties/properties/garage/properties/tunnel/properties/subterranean%20lab/properties/morty's%20memories\\",\\"description\\":\\"\\",\\"type\\":\\"array\\"},\\"summer's contingency plan\\":{\\"$id\\":\\"/properties/properties/properties/garage/properties/tunnel/properties/subterranean%20lab/properties/summer's%20contingency%20plan\\",\\"description\\":\\"\\",\\"type\\":\\"string\\"}},\\"required\\":[],\\"type\\":\\"object\\"}},\\"required\\":[\\"subterranean lab\\"],\\"type\\":\\"object\\"}},\\"required\\":[\\"tunnel\\"],\\"type\\":\\"object\\"}},\\"required\\":[\\"garage\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Properties Collided' track call.
 * 
 *
 * @param {TrackMessage<PropertiesCollided>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function propertiesCollided(
    message: TrackMessage<PropertiesCollided>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Properties Collided',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Properties_Collided\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"Property Collided\\":{\\"$id\\":\\"/properties/Property%20Collided\\",\\"description\\":\\"\\",\\"type\\":\\"string\\"},\\"property_collided\\":{\\"$id\\":\\"/properties/property_collided\\",\\"description\\":\\"\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"property_collided\\",\\"Property Collided\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Property Object Name Collision #1' track call.
 * 
 *
 * @param {TrackMessage<PropertyObjectNameCollision1>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function propertyObjectNameCollision1(
    message: TrackMessage<PropertyObjectNameCollision1>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Property Object Name Collision #1',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Property_Object_Name_Collision_1\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"universe\\":{\\"$id\\":\\"/properties/universe\\",\\"description\\":\\"\\",\\"properties\\":{\\"name\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/name\\",\\"description\\":\\"The common name of this universe.\\",\\"type\\":\\"string\\"},\\"occupants\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/occupants\\",\\"description\\":\\"The most important occupants in this universe.\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/occupants/items\\",\\"description\\":\\"\\",\\"properties\\":{\\"name\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/occupants/items/properties/name\\",\\"description\\":\\"The name of this occupant.\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"name\\"],\\"type\\":\\"object\\"},\\"type\\":\\"array\\"}},\\"required\\":[\\"name\\",\\"occupants\\"],\\"type\\":\\"object\\"}},\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Property Object Name Collision #2' track call.
 * 
 *
 * @param {TrackMessage<PropertyObjectNameCollision2>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function propertyObjectNameCollision2(
    message: TrackMessage<PropertyObjectNameCollision2>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Property Object Name Collision #2',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Property_Object_Name_Collision_2\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"universe\\":{\\"$id\\":\\"/properties/universe\\",\\"description\\":\\"\\",\\"properties\\":{\\"name\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/name\\",\\"description\\":\\"The common name of this universe.\\",\\"type\\":\\"string\\"},\\"occupants\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/occupants\\",\\"description\\":\\"The most important occupants in this universe.\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/occupants/items\\",\\"description\\":\\"\\",\\"properties\\":{\\"name\\":{\\"$id\\":\\"/properties/properties/properties/universe/properties/occupants/items/properties/name\\",\\"description\\":\\"The name of this occupant.\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"name\\"],\\"type\\":\\"object\\"},\\"type\\":\\"array\\"}},\\"required\\":[\\"name\\",\\"occupants\\"],\\"type\\":\\"object\\"}},\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Property Sanitized' track call.
 * 
 *
 * @param {TrackMessage<PropertySanitized>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function propertySanitized(
    message: TrackMessage<PropertySanitized>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Property Sanitized',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Property_Sanitized\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"0000---terrible-property-name~!3\\":{\\"$id\\":\\"/properties/0000---terrible-property-name~!3\\",\\"description\\":\\"\\",\\"type\\":\\"string\\"}},\\"required\\":[\\"0000---terrible-property-name~!3\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Simple Array Types' track call.
 * 
 *
 * @param {TrackMessage<SimpleArrayTypes>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function simpleArrayTypes(
    message: TrackMessage<SimpleArrayTypes>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Simple Array Types',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Simple_Array_Types\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"any\\":{\\"$id\\":\\"/properties/any\\",\\"description\\":\\"\\",\\"items\\":{\\"description\\":\\"\\"},\\"type\\":\\"array\\"},\\"boolean\\":{\\"$id\\":\\"/properties/boolean\\",\\"description\\":\\"\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/boolean/items\\",\\"description\\":\\"\\",\\"type\\":\\"boolean\\"},\\"type\\":\\"array\\"},\\"integer\\":{\\"$id\\":\\"/properties/integer\\",\\"description\\":\\"\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/integer/items\\",\\"description\\":\\"\\",\\"type\\":\\"integer\\"},\\"type\\":\\"array\\"},\\"nullable\\":{\\"$id\\":\\"/properties/nullable\\",\\"description\\":\\"\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/nullable/items\\",\\"description\\":\\"\\",\\"type\\":[\\"string\\",\\"null\\"]},\\"type\\":\\"array\\"},\\"number\\":{\\"$id\\":\\"/properties/number\\",\\"description\\":\\"\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/number/items\\",\\"description\\":\\"\\",\\"type\\":\\"number\\"},\\"type\\":\\"array\\"},\\"object\\":{\\"$id\\":\\"/properties/object\\",\\"description\\":\\"\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/object/items\\",\\"description\\":\\"\\",\\"properties\\":{\\"name\\":{\\"$id\\":\\"/properties/properties/properties/object/items/properties/name\\",\\"description\\":\\"\\",\\"type\\":\\"string\\"}},\\"required\\":[],\\"type\\":\\"object\\"},\\"type\\":\\"array\\"},\\"string\\":{\\"$id\\":\\"/properties/string\\",\\"description\\":\\"\\",\\"items\\":{\\"$id\\":\\"/properties/properties/properties/string/items\\",\\"description\\":\\"\\",\\"type\\":\\"string\\"},\\"type\\":\\"array\\"}},\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Union Type' track call.
 * 
 *
 * @param {TrackMessage<UnionType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function unionType(
    message: TrackMessage<UnionType>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Union Type',
        properties: {
            ...message.properties,
        },
    });
    const schema = {\\"$id\\":\\"Union_Type\\",\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"properties\\":{\\"universe_name\\":{\\"$id\\":\\"/properties/universe_name\\",\\"description\\":\\"\\",\\"type\\":[\\"string\\",\\"null\\",\\"integer\\"]}},\\"required\\":[\\"universe_name\\"],\\"type\\":\\"object\\"};
    validateAgainstSchema(event, schema);

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}

const clientAPI = {
    /**
     * Updates the run-time configuration of this Typewriter client.
     * This function must be called with a configured analytics-node instance before firing
     * any analytics calls, or else a \`missingAnalyticsNodeError\` error will be thrown.
     *
     * @param {TypewriterOptions} options - the options to upsert
     *
     * @typedef {Object} TypewriterOptions
     * @property {Analytics} analytics - Underlying analytics instance where analytics
     * 		calls are forwarded on to.
     * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
     * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
     * 		it will throw errors if NODE_ENV=\\"test\\" so that tests will fail if a message does not match the spec. Otherwise, errors
     * 		will be logged to stderr.
     */
    setTypewriterOptions,

    /**
     * Fires a 'Custom Violation Handler' track call.
     * 
     * 
     * @param CustomViolationHandler props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    customViolationHandler,
    /**
     * Fires a 'Default Violation Handler' track call.
     * 
     * 
     * @param DefaultViolationHandler props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    defaultViolationHandler,
    /**
     * Fires a 'Enum Types' track call.
     * 
     * 
     * @param EnumTypes props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    enumTypes,
    /**
     * Fires a 'Every Nullable Optional Type' track call.
     * 
     * 
     * @param EveryNullableOptionalType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    everyNullableOptionalType,
    /**
     * Fires a 'Every Nullable Required Type' track call.
     * 
     * 
     * @param EveryNullableRequiredType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    everyNullableRequiredType,
    /**
     * Fires a 'Every Optional Type' track call.
     * 
     * 
     * @param EveryOptionalType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    everyOptionalType,
    /**
     * Fires a 'Every Required Type' track call.
     * 
     * 
     * @param EveryRequiredType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    everyRequiredType,
    /**
     * Fires a 'Large Numbers Event' track call.
     * 
     * 
     * @param LargeNumbersEvent props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    largeNumbersEvent,
    /**
     * Fires a 'Nested Arrays' track call.
     * 
     * 
     * @param NestedArrays props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    nestedArrays,
    /**
     * Fires a 'Nested Objects' track call.
     * 
     * 
     * @param NestedObjects props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    nestedObjects,
    /**
     * Fires a 'Properties Collided' track call.
     * 
     * 
     * @param PropertiesCollided props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    propertiesCollided,
    /**
     * Fires a 'Property Object Name Collision #1' track call.
     * 
     * 
     * @param PropertyObjectNameCollision1 props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    propertyObjectNameCollision1,
    /**
     * Fires a 'Property Object Name Collision #2' track call.
     * 
     * 
     * @param PropertyObjectNameCollision2 props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    propertyObjectNameCollision2,
    /**
     * Fires a 'Property Sanitized' track call.
     * 
     * 
     * @param PropertySanitized props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    propertySanitized,
    /**
     * Fires a 'Simple Array Types' track call.
     * 
     * 
     * @param SimpleArrayTypes props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    simpleArrayTypes,
    /**
     * Fires a 'Union Type' track call.
     * 
     * 
     * @param UnionType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    unionType,
};

export default new Proxy<typeof clientAPI>(clientAPI, {
    get(target, method) {
        if (typeof method === 'string' && target.hasOwnProperty(method)) {
            return target[method as keyof typeof clientAPI];
        }

        return () => {
            console.warn(\`  You made an analytics call (\${String(method)}) that can't be found. Either:
         a) Re-generate your typewriter client: \\\\\`npx typewriter\\\\\`
         b) Add it to your Tracking Plan: https://app.segment.com/segment-oscb/protocols/tracking-plans/rs_1zTHJU9fd5mt7cndWnd4PgJbMCE\`);
         const a = analytics()
         if (a) {
             a.track(
                 withTypewriterContext({
                     event: 'Unknown Analytics Call Fired',
                     properties: {
                         method,
                     },
                     userId: 'typewriter',
                 })
             )
         }
        };
    },
});

"
`;

exports[`build builds client Language: typescript, SDK:analytics-react-native 1`] = `
"// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

/**
 * This event is fired in order to trigger a custom violation handler. It should be called
 * with a JSON Schema violation.
 */
export interface CustomViolationHandler {
    \\"regex property\\": string;
}

/**
 * This event is fired in order to trigger the default violation handler. It should be
 * called with a JSON Schema violation.
 */
export interface DefaultViolationHandler {
    \\"regex property\\": string;
}

/**
 * Validates that client property sanitize enums.
 */
export interface EnumTypes {
    /**
     * A string property that only accepts a single enum value.
     */
    \\"string const\\"?: StringConst;
    /**
     * A string property that accepts multiple enum values.
     */
    \\"string enum\\"?: StringEnum;
}

/**
 * A string property that only accepts a single enum value.
 */
export enum StringConst {
    RickSanchez = \\"Rick Sanchez\\",
}

/**
 * A string property that accepts multiple enum values.
 */
export enum StringEnum {
    EvilMorty = \\"Evil Morty\\",
    LawyerMorty = \\"Lawyer Morty\\",
}

/**
 * Validates that clients handle all of the supported field types, as nullable optional
 * fields. If a field is null, it is expected to be NOT sent through.
 */
export interface EveryNullableOptionalType {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[] | null;
    /**
     * Optional array with properties
     */
    \\"optional array with properties\\"?: Array<null | EveryNullableOptionalTypeOptionalArrayWithProperty> | null;
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean | null;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number | null;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number | null;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any } | null;
    /**
     * Optional object with properties
     */
    \\"optional object with properties\\"?: null | EveryNullableOptionalTypeOptionalObjectWithProperties;
    /**
     * Optional string property
     */
    \\"optional string\\"?: null | string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: null | string;
}

export interface EveryNullableOptionalTypeOptionalArrayWithProperty {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[] | null;
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean | null;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number | null;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number | null;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any } | null;
    /**
     * Optional string property
     */
    \\"optional string\\"?: null | string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: null | string;
}

export interface EveryNullableOptionalTypeOptionalObjectWithProperties {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[] | null;
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean | null;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number | null;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number | null;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any } | null;
    /**
     * Optional string property
     */
    \\"optional string\\"?: null | string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: null | string;
}

/**
 * Validates that clients handle all of the supported field types, as nullable required
 * fields. If a field is null, it is expected to be sent through.
 */
export interface EveryNullableRequiredType {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[] | null;
    /**
     * Required array with properties
     */
    \\"required array with properties\\": Array<null | EveryNullableRequiredTypeRequiredArrayWithProperty> | null;
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean | null;
    /**
     * Required integer property
     */
    \\"required int\\": number | null;
    /**
     * Required number property
     */
    \\"required number\\": number | null;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any } | null;
    /**
     * Required object with properties
     */
    \\"required object with properties\\": null | EveryNullableRequiredTypeRequiredObjectWithProperties;
    /**
     * Required string property
     */
    \\"required string\\": null | string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": null | string;
}

export interface EveryNullableRequiredTypeRequiredArrayWithProperty {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[] | null;
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean | null;
    /**
     * Required integer property
     */
    \\"required int\\": number | null;
    /**
     * Required number property
     */
    \\"required number\\": number | null;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any } | null;
    /**
     * Required string property
     */
    \\"required string\\": null | string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": null | string;
}

export interface EveryNullableRequiredTypeRequiredObjectWithProperties {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[] | null;
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean | null;
    /**
     * Required integer property
     */
    \\"required int\\": number | null;
    /**
     * Required number property
     */
    \\"required number\\": number | null;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any } | null;
    /**
     * Required string property
     */
    \\"required string\\": null | string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": null | string;
}

/**
 * Validates that clients handle all of the supported field types, as optional fields.
 */
export interface EveryOptionalType {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[];
    /**
     * Optional array with properties
     */
    \\"optional array with properties\\"?: OptionalArrayWithPropertyElement[];
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any };
    /**
     * Optional object with properties
     */
    \\"optional object with properties\\"?: EveryOptionalTypeOptionalObjectWithProperties;
    /**
     * Optional string property
     */
    \\"optional string\\"?: string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: string;
}

export interface OptionalArrayWithPropertyElement {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[];
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any };
    /**
     * Optional string property
     */
    \\"optional string\\"?: string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: string;
}

/**
 * Optional object with properties
 */
export interface EveryOptionalTypeOptionalObjectWithProperties {
    /**
     * Optional any property
     */
    \\"optional any\\"?: any;
    /**
     * Optional array property
     */
    \\"optional array\\"?: any[];
    /**
     * Optional boolean property
     */
    \\"optional boolean\\"?: boolean;
    /**
     * Optional integer property
     */
    \\"optional int\\"?: number;
    /**
     * Optional number property
     */
    \\"optional number\\"?: number;
    /**
     * Optional object property
     */
    \\"optional object\\"?: { [key: string]: any };
    /**
     * Optional string property
     */
    \\"optional string\\"?: string;
    /**
     * Optional string property with a regex conditional
     */
    \\"optional string with regex\\"?: string;
}

/**
 * Validates that clients handle all of the supported field types, as required fields.
 */
export interface EveryRequiredType {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[];
    /**
     * Required array with properties
     */
    \\"required array with properties\\": RequiredArrayWithPropertyElement[];
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean;
    /**
     * Required integer property
     */
    \\"required int\\": number;
    /**
     * Required number property
     */
    \\"required number\\": number;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any };
    /**
     * Required object with properties
     */
    \\"required object with properties\\": EveryRequiredTypeRequiredObjectWithProperties;
    /**
     * Required string property
     */
    \\"required string\\": string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": string;
}

export interface RequiredArrayWithPropertyElement {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[];
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean;
    /**
     * Required integer property
     */
    \\"required int\\": number;
    /**
     * Required number property
     */
    \\"required number\\": number;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any };
    /**
     * Required string property
     */
    \\"required string\\": string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": string;
}

/**
 * Required object with properties
 */
export interface EveryRequiredTypeRequiredObjectWithProperties {
    /**
     * Required any property
     */
    \\"required any\\": any;
    /**
     * Required array property
     */
    \\"required array\\": any[];
    /**
     * Required boolean property
     */
    \\"required boolean\\": boolean;
    /**
     * Required integer property
     */
    \\"required int\\": number;
    /**
     * Required number property
     */
    \\"required number\\": number;
    /**
     * Required object property
     */
    \\"required object\\": { [key: string]: any };
    /**
     * Required string property
     */
    \\"required string\\": string;
    /**
     * Required string property with a regex conditional
     */
    \\"required string with regex\\": string;
}

/**
 * Validates that clients correctly serialize large numbers (integers and floats).
 */
export interface LargeNumbersEvent {
    \\"large nullable optional integer\\"?: number | null;
    \\"large nullable optional number\\"?:  number | null;
    \\"large nullable required integer\\":  number | null;
    \\"large nullable required number\\":   number | null;
    \\"large optional integer\\"?:          number;
    \\"large optional number\\"?:           number;
    \\"large required integer\\":           number;
    \\"large required number\\":            number;
}

/**
 * Validates that clients handle arrays-within-arrays.
 */
export interface NestedArrays {
    /**
     * All known characters from each universe.
     */
    universeCharacters: Array<UniverseCharacter[]>;
}

export interface UniverseCharacter {
    /**
     * The character's name.
     */
    name: string;
}

/**
 * Validates that clients handle objects-within-objects.
 */
export interface NestedObjects {
    garage: Garage;
}

export interface Garage {
    tunnel: Tunnel;
}

export interface Tunnel {
    \\"subterranean lab\\": SubterraneanLab;
}

export interface SubterraneanLab {
    \\"jerry's memories\\"?:          any[];
    \\"morty's memories\\"?:          any[];
    \\"summer's contingency plan\\"?: string;
}

/**
 * Validates that clients handle collisions in property names within a single event.
 */
export interface PropertiesCollided {
    \\"Property Collided\\": string;
    property_collided:   string;
}

/**
 * Validates that clients handle collisions in object names across multiple events.
 */
export interface PropertyObjectNameCollision1 {
    universe?: PropertyObjectNameCollision1_Universe;
}

export interface PropertyObjectNameCollision1_Universe {
    /**
     * The common name of this universe.
     */
    name: string;
    /**
     * The most important occupants in this universe.
     */
    occupants: PurpleOccupant[];
}

export interface PurpleOccupant {
    /**
     * The name of this occupant.
     */
    name: string;
}

/**
 * Validates that clients handle collisions in object names across multiple events.
 */
export interface PropertyObjectNameCollision2 {
    universe?: PropertyObjectNameCollision2_Universe;
}

export interface PropertyObjectNameCollision2_Universe {
    /**
     * The common name of this universe.
     */
    name: string;
    /**
     * The most important occupants in this universe.
     */
    occupants: FluffyOccupant[];
}

export interface FluffyOccupant {
    /**
     * The name of this occupant.
     */
    name: string;
}

/**
 * Validates that clients sanitize property names that contain invalid identifier characters.
 */
export interface PropertySanitized {
    \\"0000---terrible-property-name~!3\\": string;
}

/**
 * Validates that clients support fields with various types of arrays.
 */
export interface SimpleArrayTypes {
    any?:      any[];
    boolean?:  boolean[];
    integer?:  number[];
    nullable?: Array<null | string>;
    number?:   number[];
    object?:   Object[];
    string?:   string[];
}

export interface Object {
    name?: string;
}

/**
 * Validates that clients support fields with multiple (union) types.
 */
export interface UnionType {
    universe_name: number | null | string;
}

/**
 * Properties without IDs
 */
export interface NoIDType {
    /**
     * a property without an ID
     */
    no_id_prop: string;
}

import React, { createContext, useContext } from 'react';
import {
    createClient as createSegmentClient,
    Config as SegmentConfig,
    JsonMap,
} from '@segment/analytics-react-native';
import type { SegmentClient } from '@segment/analytics-react-native/lib/typescript/src/analytics';

export type TypewriterSegmentClient = SegmentClient & {
    customViolationHandler: (message: CustomViolationHandler) => void,
    defaultViolationHandler: (message: DefaultViolationHandler) => void,
    enumTypes: (message: EnumTypes) => void,
    everyNullableOptionalType: (message: EveryNullableOptionalType) => void,
    everyNullableRequiredType: (message: EveryNullableRequiredType) => void,
    everyOptionalType: (message: EveryOptionalType) => void,
    everyRequiredType: (message: EveryRequiredType) => void,
    largeNumbersEvent: (message: LargeNumbersEvent) => void,
    nestedArrays: (message: NestedArrays) => void,
    nestedObjects: (message: NestedObjects) => void,
    propertiesCollided: (message: PropertiesCollided) => void,
    propertyObjectNameCollision1: (message: PropertyObjectNameCollision1) => void,
    propertyObjectNameCollision2: (message: PropertyObjectNameCollision2) => void,
    propertySanitized: (message: PropertySanitized) => void,
    simpleArrayTypes: (message: SimpleArrayTypes) => void,
    unionType: (message: UnionType) => void,
    noIDType: (message: NoIDType) => void,
}

function extendSegmentClient(client: SegmentClient): TypewriterSegmentClient {
    const extendedClient = client as TypewriterSegmentClient;
    extendedClient.customViolationHandler = (message: CustomViolationHandler) => {
        client.track('Custom Violation Handler', message as unknown as JsonMap);
    };
    extendedClient.defaultViolationHandler = (message: DefaultViolationHandler) => {
        client.track('Default Violation Handler', message as unknown as JsonMap);
    };
    extendedClient.enumTypes = (message: EnumTypes) => {
        client.track('Enum Types', message as unknown as JsonMap);
    };
    extendedClient.everyNullableOptionalType = (message: EveryNullableOptionalType) => {
        client.track('Every Nullable Optional Type', message as unknown as JsonMap);
    };
    extendedClient.everyNullableRequiredType = (message: EveryNullableRequiredType) => {
        client.track('Every Nullable Required Type', message as unknown as JsonMap);
    };
    extendedClient.everyOptionalType = (message: EveryOptionalType) => {
        client.track('Every Optional Type', message as unknown as JsonMap);
    };
    extendedClient.everyRequiredType = (message: EveryRequiredType) => {
        client.track('Every Required Type', message as unknown as JsonMap);
    };
    extendedClient.largeNumbersEvent = (message: LargeNumbersEvent) => {
        client.track('Large Numbers Event', message as unknown as JsonMap);
    };
    extendedClient.nestedArrays = (message: NestedArrays) => {
        client.track('Nested Arrays', message as unknown as JsonMap);
    };
    extendedClient.nestedObjects = (message: NestedObjects) => {
        client.track('Nested Objects', message as unknown as JsonMap);
    };
    extendedClient.propertiesCollided = (message: PropertiesCollided) => {
        client.track('Properties Collided', message as unknown as JsonMap);
    };
    extendedClient.propertyObjectNameCollision1 = (message: PropertyObjectNameCollision1) => {
        client.track('Property Object Name Collision #1', message as unknown as JsonMap);
    };
    extendedClient.propertyObjectNameCollision2 = (message: PropertyObjectNameCollision2) => {
        client.track('Property Object Name Collision #2', message as unknown as JsonMap);
    };
    extendedClient.propertySanitized = (message: PropertySanitized) => {
        client.track('Property Sanitized', message as unknown as JsonMap);
    };
    extendedClient.simpleArrayTypes = (message: SimpleArrayTypes) => {
        client.track('Simple Array Types', message as unknown as JsonMap);
    };
    extendedClient.unionType = (message: UnionType) => {
        client.track('Union Type', message as unknown as JsonMap);
    };
    extendedClient.noIDType = (message: NoIDType) => {
        client.track('NoID type', message as unknown as JsonMap);
    };
    return extendedClient;
}

export const createClient = (config: SegmentConfig) => {
    const client = createSegmentClient(config);
    return extendSegmentClient(client);
};

const Context = createContext<ReturnType<typeof createClient> | null>(null);

export const AnalyticsProvider = ({
    client,
    children,
}: {
    client?: ReturnType<typeof createClient>;
    children?: any;
}) => {
    if (!client) {
        return null;
    }

    return <Context.Provider value={client}>{children}</Context.Provider>;
};

export const useAnalytics = () => {
    const client = useContext(Context);
    if (!client) {
        console.error(
            'Segment client not configured!',
            'To use the useAnalytics() hook, pass an initialized Segment client into the AnalyticsProvider',
        );

        // @ts-ignore
        return {};
    }
    return {
        ...client,
    };
};

"
`;
