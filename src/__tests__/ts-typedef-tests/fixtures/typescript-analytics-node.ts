// This client was automatically generated by Segment Typewriter. ** Do Not Edit **
// To update this file, run:
//   npx typewriter

/**
 * This event is fired in order to trigger a custom violation handler. It should be called
 * with a JSON Schema violation.
 */
export interface CustomViolationHandler {
    "regex property": string;
}

/**
 * This event is fired in order to trigger the default violation handler. It should be
 * called with a JSON Schema violation.
 */
export interface DefaultViolationHandler {
    "regex property": string;
}

/**
 * Validates that client property sanitize enums.
 */
export interface EnumTypes {
    /**
     * A string property that only accepts a single enum value.
     */
    "string const"?: StringConst;
    /**
     * A string property that accepts multiple enum values.
     */
    "string enum"?: StringEnum;
}

/**
 * A string property that only accepts a single enum value.
 */
export enum StringConst {
    RickSanchez = "Rick Sanchez",
}

/**
 * A string property that accepts multiple enum values.
 */
export enum StringEnum {
    EvilMorty = "Evil Morty",
    LawyerMorty = "Lawyer Morty",
}

/**
 * Validates that clients handle all of the supported field types, as nullable optional
 * fields. If a field is null, it is expected to be NOT sent through.
 */
export interface EveryNullableOptionalType {
    /**
     * Optional any property
     */
    "optional any"?: any;
    /**
     * Optional array property
     */
    "optional array"?: any[] | null;
    /**
     * Optional array with properties
     */
    "optional array with properties"?: Array<null | EveryNullableOptionalTypeOptionalArrayWithProperty> | null;
    /**
     * Optional boolean property
     */
    "optional boolean"?: boolean | null;
    /**
     * Optional integer property
     */
    "optional int"?: number | null;
    /**
     * Optional number property
     */
    "optional number"?: number | null;
    /**
     * Optional object property
     */
    "optional object"?: { [key: string]: any } | null;
    /**
     * Optional object with properties
     */
    "optional object with properties"?: null | EveryNullableOptionalTypeOptionalObjectWithProperties;
    /**
     * Optional string property
     */
    "optional string"?: null | string;
    /**
     * Optional string property with a regex conditional
     */
    "optional string with regex"?: null | string;
}

export interface EveryNullableOptionalTypeOptionalArrayWithProperty {
    /**
     * Optional any property
     */
    "optional any"?: any;
    /**
     * Optional array property
     */
    "optional array"?: any[] | null;
    /**
     * Optional boolean property
     */
    "optional boolean"?: boolean | null;
    /**
     * Optional integer property
     */
    "optional int"?: number | null;
    /**
     * Optional number property
     */
    "optional number"?: number | null;
    /**
     * Optional object property
     */
    "optional object"?: { [key: string]: any } | null;
    /**
     * Optional string property
     */
    "optional string"?: null | string;
    /**
     * Optional string property with a regex conditional
     */
    "optional string with regex"?: null | string;
}

export interface EveryNullableOptionalTypeOptionalObjectWithProperties {
    /**
     * Optional any property
     */
    "optional any"?: any;
    /**
     * Optional array property
     */
    "optional array"?: any[] | null;
    /**
     * Optional boolean property
     */
    "optional boolean"?: boolean | null;
    /**
     * Optional integer property
     */
    "optional int"?: number | null;
    /**
     * Optional number property
     */
    "optional number"?: number | null;
    /**
     * Optional object property
     */
    "optional object"?: { [key: string]: any } | null;
    /**
     * Optional string property
     */
    "optional string"?: null | string;
    /**
     * Optional string property with a regex conditional
     */
    "optional string with regex"?: null | string;
}

/**
 * Validates that clients handle all of the supported field types, as nullable required
 * fields. If a field is null, it is expected to be sent through.
 */
export interface EveryNullableRequiredType {
    /**
     * Required any property
     */
    "required any": any;
    /**
     * Required array property
     */
    "required array": any[] | null;
    /**
     * Required array with properties
     */
    "required array with properties": Array<null | EveryNullableRequiredTypeRequiredArrayWithProperty> | null;
    /**
     * Required boolean property
     */
    "required boolean": boolean | null;
    /**
     * Required integer property
     */
    "required int": number | null;
    /**
     * Required number property
     */
    "required number": number | null;
    /**
     * Required object property
     */
    "required object": { [key: string]: any } | null;
    /**
     * Required object with properties
     */
    "required object with properties": null | EveryNullableRequiredTypeRequiredObjectWithProperties;
    /**
     * Required string property
     */
    "required string": null | string;
    /**
     * Required string property with a regex conditional
     */
    "required string with regex": null | string;
}

export interface EveryNullableRequiredTypeRequiredArrayWithProperty {
    /**
     * Required any property
     */
    "required any": any;
    /**
     * Required array property
     */
    "required array": any[] | null;
    /**
     * Required boolean property
     */
    "required boolean": boolean | null;
    /**
     * Required integer property
     */
    "required int": number | null;
    /**
     * Required number property
     */
    "required number": number | null;
    /**
     * Required object property
     */
    "required object": { [key: string]: any } | null;
    /**
     * Required string property
     */
    "required string": null | string;
    /**
     * Required string property with a regex conditional
     */
    "required string with regex": null | string;
}

export interface EveryNullableRequiredTypeRequiredObjectWithProperties {
    /**
     * Required any property
     */
    "required any": any;
    /**
     * Required array property
     */
    "required array": any[] | null;
    /**
     * Required boolean property
     */
    "required boolean": boolean | null;
    /**
     * Required integer property
     */
    "required int": number | null;
    /**
     * Required number property
     */
    "required number": number | null;
    /**
     * Required object property
     */
    "required object": { [key: string]: any } | null;
    /**
     * Required string property
     */
    "required string": null | string;
    /**
     * Required string property with a regex conditional
     */
    "required string with regex": null | string;
}

/**
 * Validates that clients handle all of the supported field types, as optional fields.
 */
export interface EveryOptionalType {
    /**
     * Optional any property
     */
    "optional any"?: any;
    /**
     * Optional array property
     */
    "optional array"?: any[];
    /**
     * Optional array with properties
     */
    "optional array with properties"?: OptionalArrayWithPropertyElement[];
    /**
     * Optional boolean property
     */
    "optional boolean"?: boolean;
    /**
     * Optional integer property
     */
    "optional int"?: number;
    /**
     * Optional number property
     */
    "optional number"?: number;
    /**
     * Optional object property
     */
    "optional object"?: { [key: string]: any };
    /**
     * Optional object with properties
     */
    "optional object with properties"?: EveryOptionalTypeOptionalObjectWithProperties;
    /**
     * Optional string property
     */
    "optional string"?: string;
    /**
     * Optional string property with a regex conditional
     */
    "optional string with regex"?: string;
}

export interface OptionalArrayWithPropertyElement {
    /**
     * Optional any property
     */
    "optional any"?: any;
    /**
     * Optional array property
     */
    "optional array"?: any[];
    /**
     * Optional boolean property
     */
    "optional boolean"?: boolean;
    /**
     * Optional integer property
     */
    "optional int"?: number;
    /**
     * Optional number property
     */
    "optional number"?: number;
    /**
     * Optional object property
     */
    "optional object"?: { [key: string]: any };
    /**
     * Optional string property
     */
    "optional string"?: string;
    /**
     * Optional string property with a regex conditional
     */
    "optional string with regex"?: string;
}

/**
 * Optional object with properties
 */
export interface EveryOptionalTypeOptionalObjectWithProperties {
    /**
     * Optional any property
     */
    "optional any"?: any;
    /**
     * Optional array property
     */
    "optional array"?: any[];
    /**
     * Optional boolean property
     */
    "optional boolean"?: boolean;
    /**
     * Optional integer property
     */
    "optional int"?: number;
    /**
     * Optional number property
     */
    "optional number"?: number;
    /**
     * Optional object property
     */
    "optional object"?: { [key: string]: any };
    /**
     * Optional string property
     */
    "optional string"?: string;
    /**
     * Optional string property with a regex conditional
     */
    "optional string with regex"?: string;
}

/**
 * Validates that clients handle all of the supported field types, as required fields.
 */
export interface EveryRequiredType {
    /**
     * Required any property
     */
    "required any": any;
    /**
     * Required array property
     */
    "required array": any[];
    /**
     * Required array with properties
     */
    "required array with properties": RequiredArrayWithPropertyElement[];
    /**
     * Required boolean property
     */
    "required boolean": boolean;
    /**
     * Required integer property
     */
    "required int": number;
    /**
     * Required number property
     */
    "required number": number;
    /**
     * Required object property
     */
    "required object": { [key: string]: any };
    /**
     * Required object with properties
     */
    "required object with properties": EveryRequiredTypeRequiredObjectWithProperties;
    /**
     * Required string property
     */
    "required string": string;
    /**
     * Required string property with a regex conditional
     */
    "required string with regex": string;
}

export interface RequiredArrayWithPropertyElement {
    /**
     * Required any property
     */
    "required any": any;
    /**
     * Required array property
     */
    "required array": any[];
    /**
     * Required boolean property
     */
    "required boolean": boolean;
    /**
     * Required integer property
     */
    "required int": number;
    /**
     * Required number property
     */
    "required number": number;
    /**
     * Required object property
     */
    "required object": { [key: string]: any };
    /**
     * Required string property
     */
    "required string": string;
    /**
     * Required string property with a regex conditional
     */
    "required string with regex": string;
}

/**
 * Required object with properties
 */
export interface EveryRequiredTypeRequiredObjectWithProperties {
    /**
     * Required any property
     */
    "required any": any;
    /**
     * Required array property
     */
    "required array": any[];
    /**
     * Required boolean property
     */
    "required boolean": boolean;
    /**
     * Required integer property
     */
    "required int": number;
    /**
     * Required number property
     */
    "required number": number;
    /**
     * Required object property
     */
    "required object": { [key: string]: any };
    /**
     * Required string property
     */
    "required string": string;
    /**
     * Required string property with a regex conditional
     */
    "required string with regex": string;
}

/**
 * Validates that clients correctly serialize large numbers (integers and floats).
 */
export interface LargeNumbersEvent {
    "large nullable optional integer"?: number | null;
    "large nullable optional number"?:  number | null;
    "large nullable required integer":  number | null;
    "large nullable required number":   number | null;
    "large optional integer"?:          number;
    "large optional number"?:           number;
    "large required integer":           number;
    "large required number":            number;
}

/**
 * Validates that clients handle arrays-within-arrays.
 */
export interface NestedArrays {
    /**
     * All known characters from each universe.
     */
    universeCharacters: Array<UniverseCharacter[]>;
}

export interface UniverseCharacter {
    /**
     * The character's name.
     */
    name: string;
}

/**
 * Validates that clients handle objects-within-objects.
 */
export interface NestedObjects {
    garage: Garage;
}

export interface Garage {
    tunnel: Tunnel;
}

export interface Tunnel {
    "subterranean lab": SubterraneanLab;
}

export interface SubterraneanLab {
    "jerry's memories"?:          any[];
    "morty's memories"?:          any[];
    "summer's contingency plan"?: string;
}

/**
 * Validates that clients handle collisions in property names within a single event.
 */
export interface PropertiesCollided {
    "Property Collided": string;
    property_collided:   string;
}

/**
 * Validates that clients handle collisions in object names across multiple events.
 */
export interface PropertyObjectNameCollision1 {
    universe?: PropertyObjectNameCollision1_Universe;
}

export interface PropertyObjectNameCollision1_Universe {
    /**
     * The common name of this universe.
     */
    name: string;
    /**
     * The most important occupants in this universe.
     */
    occupants: PurpleOccupant[];
}

export interface PurpleOccupant {
    /**
     * The name of this occupant.
     */
    name: string;
}

/**
 * Validates that clients handle collisions in object names across multiple events.
 */
export interface PropertyObjectNameCollision2 {
    universe?: PropertyObjectNameCollision2_Universe;
}

export interface PropertyObjectNameCollision2_Universe {
    /**
     * The common name of this universe.
     */
    name: string;
    /**
     * The most important occupants in this universe.
     */
    occupants: FluffyOccupant[];
}

export interface FluffyOccupant {
    /**
     * The name of this occupant.
     */
    name: string;
}

/**
 * Validates that clients sanitize property names that contain invalid identifier characters.
 */
export interface PropertySanitized {
    "0000---terrible-property-name~!3": string;
}

/**
 * Validates that clients support fields with various types of arrays.
 */
export interface SimpleArrayTypes {
    any?:      any[];
    boolean?:  boolean[];
    integer?:  number[];
    nullable?: Array<null | string>;
    number?:   number[];
    object?:   Object[];
    string?:   string[];
}

export interface Object {
    name?: string;
}

/**
 * Validates that clients support fields with multiple (union) types.
 */
export interface UnionType {
    universe_name: number | null | string;
}

/**
 * Properties without IDs
 */
export interface NoIDType {
    /**
     * a property without an ID
     */
    no_id_prop: string;
}

import AnalyticsNode from 'analytics-node'

/**
* At least one of userId or anonymousId must be included in any identify call.
*/
type Identity = { userId: string | number } | { anonymousId: string | number };

/**
 * TrackMessage represents a message payload for an analytics `.track()` call.
 * See: https://segment.com/docs/spec/track/
 */
export type TrackMessage<PropertiesType> = Options & Record<string, any> & Identity & {
    /** A dictionary of properties for the event. */
    properties?: PropertiesType
    /**
    * A Javascript date object representing when the track took place.
    * If the track just happened, leave it out and we’ll use the server’s
    * time. If you’re importing data from the past make sure you to send
    * a timestamp.
    */
    timestamp?: Date
    /** 
    * MessageId which can be optionally set to override the default one generated by the library.
    * This is useful when you want to deduplicate messages.
    */
    messageId?: string
}

/** The callback exposed by analytics-node. */
export type Callback = (err: Error) => void

/** A dictionary of options. For example, enable or disable specific destinations for the call. */
export interface Options {
    /**
     * Selectivly filter destinations. By default all destinations are enabled.
     * https://segment.com/docs/sources/website/analytics.js/#selecting-destinations
     */
    integrations?: {
        [key: string]: boolean | { [key: string]: any };
    };
    /**
     * A dictionary of extra context to attach to the call.
     * https://segment.com/docs/spec/common/#context
     */
    context?: Context;
}

/**
 * Context is a dictionary of extra information that provides useful context about a datapoint.
 * @see {@link https://segment.com/docs/spec/common/#context}
 */
export interface Context extends Record<string, any> {
    active?: boolean;
    app?: {
        name?: string;
        version?: string;
        build?: string;
    };
    campaign?: {
        name?: string;
        source?: string;
        medium?: string;
        term?: string;
        content?: string;
    };
    device?: {
        id?: string;
        manufacturer?: string;
        model?: string;
        name?: string;
        type?: string;
        version?: string;
    };
    ip?: string;
    locale?: string;
    location?: {
        city?: string;
        country?: string;
        latitude?: string;
        longitude?: string;
        region?: string;
        speed?: string;
    };
    network?: {
        bluetooth?: string;
        carrier?: string;
        cellular?: string;
        wifi?: string;
    };
    os?: {
        name?: string;
        version?: string;
    };
    page?: {
        hash?: string;
        path?: string;
        referrer?: string;
        search?: string;
        title?: string;
        url?: string;
    };
    referrer?: {
        type?: string;
        name?: string;
        url?: string;
        link?: string;
    };
    screen?: {
        density?: string;
        height?: string;
        width?: string;
    };
    timezone?: string;
    groupId?: string;
    traits?: Record<string, any>;
    userAgent?: string;
}

export type ViolationHandler = (
    message: TrackMessage<Record<string, any>>,
    violations: any[]
) => void

/**
 * The default handler that is fired if none is supplied with setTypewriterOptions.
 * If NODE_ENV="test", this handler will throw an error. Otherwise, it will log
 * a warning message to the console.
 */
 export const defaultValidationErrorHandler: ViolationHandler = (
    message,
    violations
) => {
    const msg = JSON.stringify(
        {
            type: 'Typewriter JSON Schema Validation Error',
            description:
                `You made an analytics call (${message.event}) using Typewriter that doesn't match the ` +
                'Tracking Plan spec.',
            errors: violations,
        },
        undefined,
        2
    )

    if (process.env.NODE_ENV === 'test') {
        throw new Error(msg)
    }
    console.warn(msg)
}


const missingAnalyticsNodeError = new Error(`You must set an analytics-node instance:

>	const SegmentAnalytics = require('analytics-node')
>	const { setTypewriterOptions } = require('./analytics')
>
>	const analytics = new SegmentAnalytics('SEGMENT_WRITE_KEY')
>	setTypewriterOptions({
>		analytics: analytics,
>	})

For more information on analytics-node, see: https://segment.com/docs/sources/server/node/quickstart/
`)

let analytics: () => AnalyticsNode | undefined = () => {
    throw missingAnalyticsNodeError
}

/** Options to customize the runtime behavior of a Typewriter client. */
export interface TypewriterOptions {
    /**
     * Underlying analytics instance where analytics calls are forwarded on to.
     */
    analytics: AnalyticsNode
    /**
     * Handler fired when if an event does not match its spec. This handler
     * does not fire in production mode, because it requires inlining the full
     * JSON Schema spec for each event in your Tracking Plan.
     *
     * By default, it will throw errors if NODE_ENV = "test" so that tests will fail
     * if a message does not match the spec. Otherwise, errors will be logged to stderr.
     */
    onViolation?: ViolationHandler
}

/**
 * Updates the run-time configuration of this Typewriter client.
 * This function must be called with a configured analytics-node instance before firing
 * any analytics calls, or else a `missingAnalyticsNodeError` error will be thrown.
 *
 * @param {TypewriterOptions} options - the options to upsert
 *
 * @typedef {Object} TypewriterOptions
 * @property {AnalyticsNode} analytics - Underlying analytics instance where analytics
 * 		calls are forwarded on to.
 * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
 * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
 * 		it will throw errors if NODE_ENV="test" so that tests will fail if a message does not match the spec. Otherwise, errors
 * 		will be logged to stderr.
 */
export function setTypewriterOptions(options: TypewriterOptions) {
    analytics = options.analytics ? () => options.analytics : analytics
}


/**
 * Helper to attach metadata on Typewriter to outbound requests.
 * This is used for attribution and debugging by the Segment team.
 */
function withTypewriterContext<P, T extends TrackMessage<P>>(
    message: T
): T {
    return {
        ...message,
        context: {
            ...(message.context || {}),
            typewriter: {
                language: 'typescript',
                
            },
        },
    }
}


/**
 * Fires a 'Custom Violation Handler' track call.
 * This event is fired in order to trigger a custom violation handler. It should be called with a JSON Schema violation.
 *
 * @param {TrackMessage<CustomViolationHandler>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function customViolationHandler(
    message: TrackMessage<CustomViolationHandler>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Custom Violation Handler',
        properties: {
            ...message.properties,
        },
    });

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Default Violation Handler' track call.
 * This event is fired in order to trigger the default violation handler. It should be called with a JSON Schema violation.
 *
 * @param {TrackMessage<DefaultViolationHandler>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function defaultViolationHandler(
    message: TrackMessage<DefaultViolationHandler>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Default Violation Handler',
        properties: {
            ...message.properties,
        },
    });

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Enum Types' track call.
 * Validates that client property sanitize enums.
 *
 * @param {TrackMessage<EnumTypes>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function enumTypes(
    message: TrackMessage<EnumTypes>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Enum Types',
        properties: {
            ...message.properties,
        },
    });

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Every Nullable Optional Type' track call.
 * Validates that clients handle all of the supported field types, as nullable optional fields. If a field is null, it is expected to be NOT sent through.
 *
 * @param {TrackMessage<EveryNullableOptionalType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function everyNullableOptionalType(
    message: TrackMessage<EveryNullableOptionalType>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Every Nullable Optional Type',
        properties: {
            ...message.properties,
        },
    });

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Every Nullable Required Type' track call.
 * Validates that clients handle all of the supported field types, as nullable required fields. If a field is null, it is expected to be sent through.
 *
 * @param {TrackMessage<EveryNullableRequiredType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function everyNullableRequiredType(
    message: TrackMessage<EveryNullableRequiredType>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Every Nullable Required Type',
        properties: {
            ...message.properties,
        },
    });

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Every Optional Type' track call.
 * Validates that clients handle all of the supported field types, as optional fields.
 *
 * @param {TrackMessage<EveryOptionalType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function everyOptionalType(
    message: TrackMessage<EveryOptionalType>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Every Optional Type',
        properties: {
            ...message.properties,
        },
    });

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Every Required Type' track call.
 * Validates that clients handle all of the supported field types, as required fields.
 *
 * @param {TrackMessage<EveryRequiredType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function everyRequiredType(
    message: TrackMessage<EveryRequiredType>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Every Required Type',
        properties: {
            ...message.properties,
        },
    });

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Large Numbers Event' track call.
 * Validates that clients correctly serialize large numbers (integers and floats).
 *
 * @param {TrackMessage<LargeNumbersEvent>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function largeNumbersEvent(
    message: TrackMessage<LargeNumbersEvent>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Large Numbers Event',
        properties: {
            ...message.properties,
        },
    });

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Nested Arrays' track call.
 * Validates that clients handle arrays-within-arrays.
 *
 * @param {TrackMessage<NestedArrays>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function nestedArrays(
    message: TrackMessage<NestedArrays>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Nested Arrays',
        properties: {
            ...message.properties,
        },
    });

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Nested Objects' track call.
 * Validates that clients handle objects-within-objects.
 *
 * @param {TrackMessage<NestedObjects>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function nestedObjects(
    message: TrackMessage<NestedObjects>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Nested Objects',
        properties: {
            ...message.properties,
        },
    });

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Properties Collided' track call.
 * Validates that clients handle collisions in property names within a single event.
 *
 * @param {TrackMessage<PropertiesCollided>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function propertiesCollided(
    message: TrackMessage<PropertiesCollided>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Properties Collided',
        properties: {
            ...message.properties,
        },
    });

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Property Object Name Collision #1' track call.
 * Validates that clients handle collisions in object names across multiple events.
 *
 * @param {TrackMessage<PropertyObjectNameCollision1>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function propertyObjectNameCollision1(
    message: TrackMessage<PropertyObjectNameCollision1>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Property Object Name Collision #1',
        properties: {
            ...message.properties,
        },
    });

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Property Object Name Collision #2' track call.
 * Validates that clients handle collisions in object names across multiple events.
 *
 * @param {TrackMessage<PropertyObjectNameCollision2>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function propertyObjectNameCollision2(
    message: TrackMessage<PropertyObjectNameCollision2>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Property Object Name Collision #2',
        properties: {
            ...message.properties,
        },
    });

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Property Sanitized' track call.
 * Validates that clients sanitize property names that contain invalid identifier characters.
 *
 * @param {TrackMessage<PropertySanitized>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function propertySanitized(
    message: TrackMessage<PropertySanitized>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Property Sanitized',
        properties: {
            ...message.properties,
        },
    });

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Simple Array Types' track call.
 * Validates that clients support fields with various types of arrays.
 *
 * @param {TrackMessage<SimpleArrayTypes>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function simpleArrayTypes(
    message: TrackMessage<SimpleArrayTypes>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Simple Array Types',
        properties: {
            ...message.properties,
        },
    });

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'Union Type' track call.
 * Validates that clients support fields with multiple (union) types.
 *
 * @param {TrackMessage<UnionType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function unionType(
    message: TrackMessage<UnionType>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'Union Type',
        properties: {
            ...message.properties,
        },
    });

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}
/**
 * Fires a 'NoID type' track call.
 * Properties without IDs
 *
 * @param {TrackMessage<NoIDType>} message - The analytics properties that will be sent to Segment.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
 export function noIDType(
    message: TrackMessage<NoIDType>,
    callback?: Callback
): void {
    const event = withTypewriterContext({
        ...message,
        event: 'NoID type',
        properties: {
            ...message.properties,
        },
    });

    const a = analytics()
    if (a) {
        a.track(event,callback);
    } else {
        throw missingAnalyticsNodeError
    }
}

const clientAPI = {
    /**
     * Updates the run-time configuration of this Typewriter client.
     * This function must be called with a configured analytics-node instance before firing
     * any analytics calls, or else a `missingAnalyticsNodeError` error will be thrown.
     *
     * @param {TypewriterOptions} options - the options to upsert
     *
     * @typedef {Object} TypewriterOptions
     * @property {AnalyticsNode} analytics - Underlying analytics instance where analytics
     * 		calls are forwarded on to.
     * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
     * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
     * 		it will throw errors if NODE_ENV="test" so that tests will fail if a message does not match the spec. Otherwise, errors
     * 		will be logged to stderr.
     */
    setTypewriterOptions,

    /**
     * Fires a 'Custom Violation Handler' track call.
     * This event is fired in order to trigger a custom violation handler. It should be called with a JSON Schema violation.
     * 
     * @param CustomViolationHandler props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    customViolationHandler,
    /**
     * Fires a 'Default Violation Handler' track call.
     * This event is fired in order to trigger the default violation handler. It should be called with a JSON Schema violation.
     * 
     * @param DefaultViolationHandler props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    defaultViolationHandler,
    /**
     * Fires a 'Enum Types' track call.
     * Validates that client property sanitize enums.
     * 
     * @param EnumTypes props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    enumTypes,
    /**
     * Fires a 'Every Nullable Optional Type' track call.
     * Validates that clients handle all of the supported field types, as nullable optional fields. If a field is null, it is expected to be NOT sent through.
     * 
     * @param EveryNullableOptionalType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    everyNullableOptionalType,
    /**
     * Fires a 'Every Nullable Required Type' track call.
     * Validates that clients handle all of the supported field types, as nullable required fields. If a field is null, it is expected to be sent through.
     * 
     * @param EveryNullableRequiredType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    everyNullableRequiredType,
    /**
     * Fires a 'Every Optional Type' track call.
     * Validates that clients handle all of the supported field types, as optional fields.
     * 
     * @param EveryOptionalType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    everyOptionalType,
    /**
     * Fires a 'Every Required Type' track call.
     * Validates that clients handle all of the supported field types, as required fields.
     * 
     * @param EveryRequiredType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    everyRequiredType,
    /**
     * Fires a 'Large Numbers Event' track call.
     * Validates that clients correctly serialize large numbers (integers and floats).
     * 
     * @param LargeNumbersEvent props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    largeNumbersEvent,
    /**
     * Fires a 'Nested Arrays' track call.
     * Validates that clients handle arrays-within-arrays.
     * 
     * @param NestedArrays props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    nestedArrays,
    /**
     * Fires a 'Nested Objects' track call.
     * Validates that clients handle objects-within-objects.
     * 
     * @param NestedObjects props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    nestedObjects,
    /**
     * Fires a 'Properties Collided' track call.
     * Validates that clients handle collisions in property names within a single event.
     * 
     * @param PropertiesCollided props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    propertiesCollided,
    /**
     * Fires a 'Property Object Name Collision #1' track call.
     * Validates that clients handle collisions in object names across multiple events.
     * 
     * @param PropertyObjectNameCollision1 props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    propertyObjectNameCollision1,
    /**
     * Fires a 'Property Object Name Collision #2' track call.
     * Validates that clients handle collisions in object names across multiple events.
     * 
     * @param PropertyObjectNameCollision2 props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    propertyObjectNameCollision2,
    /**
     * Fires a 'Property Sanitized' track call.
     * Validates that clients sanitize property names that contain invalid identifier characters.
     * 
     * @param PropertySanitized props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    propertySanitized,
    /**
     * Fires a 'Simple Array Types' track call.
     * Validates that clients support fields with various types of arrays.
     * 
     * @param SimpleArrayTypes props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    simpleArrayTypes,
    /**
     * Fires a 'Union Type' track call.
     * Validates that clients support fields with multiple (union) types.
     * 
     * @param UnionType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    unionType,
    /**
     * Fires a 'NoID type' track call.
     * Properties without IDs
     * 
     * @param NoIDType props - The analytics properties that will be sent to Segment.
     * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
     * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
     * 	call is fired.
     */
    noIDType,
};

export default new Proxy<typeof clientAPI>(clientAPI, {
    get(target, method) {
        if (typeof method === 'string' && target.hasOwnProperty(method)) {
            return target[method as keyof typeof clientAPI];
        }

        return () => {
            console.warn(`⚠️  You made an analytics call (${String(method)}) that can't be found. Either:
         a) Re-generate your typewriter client: \`npx typewriter\`
         b) Add it to your Tracking Plan: https://app.segment.com/segment-oscb/protocols/tracking-plans/rs_1zTHJU9fd5mt7cndWnd4PgJbMCE`);
         const a = analytics()
         if (a) {
             a.track(
                 withTypewriterContext({
                     event: 'Unknown Analytics Call Fired',
                     properties: {
                         method,
                     },
                     userId: 'typewriter',
                 })
             )
         }
        };
    },
});

