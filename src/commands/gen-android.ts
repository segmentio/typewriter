import {
  quicktypeMultiFile,
  JavaRenderer,
  JavaTargetLanguage,
  RenderContext,
  ClassType,
  Name,
  TargetLanguage,
  Sourcelike,
  ObjectType
} from 'quicktype-core'

import { modifySource, SerializedRenderResult } from 'quicktype-core/dist/Source'
import { OptionValues, BooleanOption, StringOption } from 'quicktype-core/dist/RendererOptions'
import { javaOptions } from 'quicktype-core/dist/language/Java'

import {
  getTypedTrackHandler,
  TrackedEvent,
  builder as defaultBuilder,
  Params as DefaultParams
} from '../lib/cli'
import * as fs from 'fs'
import * as util from 'util'
import { map, camelCase, upperFirst } from 'lodash'
import { AcronymStyleOptions } from 'quicktype-core/dist/support/Acronyms'
import { getRawName } from '../lib/naming'
import { processEventsForQuickType } from '../lib/rules'

const writeFile = util.promisify(fs.writeFile)

export const command = 'gen-android'
export const desc = 'Generate a strongly typed analytics-android client'
export const builder = {
  ...defaultBuilder,
  package: {
    type: 'string',
    required: true,
    description: 'Used as the package name in generated classes'
  },
  trackingPlan: {
    type: 'string',
    required: false,
    description: 'Used to name the exported Analytics class'
  },
  language: {
    type: 'string',
    required: false,
    default: 'java',
    choices: ['java'],
    description: 'Which Android language bindings to generate'
  }
}
export type Params = DefaultParams & {
  package: string
  trackingPlan: string
  language: string
}

declare type analyticsJavaOptions = typeof javaOptions & {
  justTypes: BooleanOption
  trackingPlan: StringOption
}

class AnalyticsJavaTargetLanguage extends JavaTargetLanguage {
  public packageName: string
  public trackingPlan: string

  constructor(packageName: string, trackingPlan: string) {
    super()
    this.packageName = packageName
    this.trackingPlan = trackingPlan
  }

  protected makeRenderer(renderContext: RenderContext, _: { [name: string]: any }): JavaRenderer {
    return new AnalyticsJavaWrapperRenderer(this, renderContext, {
      justTypes: true,
      packageName: this.packageName,
      trackingPlan: this.trackingPlan,
      acronymStyle: AcronymStyleOptions.Pascal,
      useList: true
    })
  }
  protected get defaultIndentation(): string {
    return '    '
  }

  get supportsOptionalClassProperties(): boolean {
    return true
  }
}

class AnalyticsJavaWrapperRenderer extends JavaRenderer {
  constructor(
    targetLanguage: TargetLanguage,
    renderContext: RenderContext,
    protected readonly options: OptionValues<analyticsJavaOptions>
  ) {
    super(targetLanguage, renderContext, options)
  }

  protected emitAutogeneratedFileWarning() {
    this.emitCommentLines(['This code is auto-generated by Segment Typewriter. Do not edit.'])
  }

  protected emitPackageAndImports(imports: string[]): void {
    this.emitAutogeneratedFileWarning()
    super.emitPackageAndImports(imports)
  }

  protected emitBuilderSetters(c: ClassType, className: Name): void {
    this.forEachClassProperty(c, 'leading-and-interposing', (name, jsonName, p) => {
      this.emitDescriptionBlock([
        ...(this.descriptionForClassProperty(c, jsonName) || []),
        p.isOptional
          ? [
              'This property is optional and not required to generate a valid ',
              className,
              ' object'
            ]
          : ['This property is required to generate a valid ', className, ' object']
      ])
      const type = this.javaType(true, p.type)
      this.emitBlock(['public Builder ', name, '(final @NonNull ', type, ' ', name, ')'], () => {
        this.emitLine(['properties.putValue("', jsonName, '", ', name, ');'])
        this.emitLine('return this;')
      })
    })
  }

  protected emitRuntimeValidation(c: ClassType, className: Name): void {
    this.forEachClassProperty(c, 'none', (name, jsonName, p) => {
      if (!p.isOptional) {
        this.emitBlock(['if (properties.get("', jsonName, '") == null)'], () => {
          this.emitLine([
            'throw new IllegalArgumentException("',
            className,
            ' missing required property: ',
            name,
            '");'
          ])
        })
        this.ensureBlankLine()
      }
    })
  }

  protected emitClassBuilderDefinition(c: ClassType, className: Name): void {
    this.emitDescriptionBlock([['Builder for {@link ', className, '}']])
    this.emitBlock(['public static class Builder'], () => {
      this.emitLine('private Properties properties;')
      this.ensureBlankLine()

      this.emitDescriptionBlock([['Builder for {@link ', className, '}']])
      this.emitBlock('public Builder()', () => {
        this.emitLine('properties = new Properties();')
      })
      this.ensureBlankLine()

      this.emitBuilderSetters(c, className)
      this.ensureBlankLine()

      const requiredProperties: Sourcelike[] = []
      this.forEachClassProperty(c, 'none', (name, __, p) => {
        if (!p.isOptional) {
          requiredProperties.push([' - ', name])
        }
      })
      if (requiredProperties.length > 0) {
        requiredProperties.unshift(
          'Performs runtime validation on the following required properties:'
        )
      }
      this.emitDescriptionBlock([
        ['Build an instance of {@link ', className, '}'],
        ...requiredProperties
      ])
      this.emitBlock(['public ', className, ' build()'], () => {
        this.emitRuntimeValidation(c, className)
        this.emitLine(['return new ', className, '(properties);'])
      })
    })
  }

  protected emitPropertiesGetterSetter(className: Name): void {
    this.emitLine('private Properties properties;')
    this.ensureBlankLine()
    this.emitBlock(['private ', className, '(Properties properties)'], () => {
      this.emitLine('this.properties = properties;')
    })
    this.ensureBlankLine()
    this.emitBlock(['protected Properties toProperties()'], () => {
      this.emitLine('return properties;')
    })
  }

  protected emitClassDefinition(c: ClassType, className: Name): void {
    this.emitFileHeader(className, ['android.support.annotation.NonNull'])
    // TODO: Emit class description, once we support top-level event descriptions in JSON Schema
    // this.emitDescription(this.descriptionForType(c));
    this.emitClassAttributes(c, className)
    this.emitBlock(['public final class ', className], () => {
      this.emitPropertiesGetterSetter(className)
      this.ensureBlankLine()
      this.emitClassBuilderDefinition(c, className)
    })
    this.finishFile()
  }

  protected emitAnalyticsEventWrapper(
    name: Name,
    hasProperties: boolean,
    withOptions: boolean
  ): void {
    // TODO: Emit a function description, once we support top-level event descriptions in JSON Schema
    const description: Sourcelike = [
      ['@see <a href="https://segment.com/docs/spec/track/">Track Documentation</a>']
    ]
    if (hasProperties) {
      description.unshift([
        '@param props {@link ',
        name,
        '} to add extra information to this call.'
      ])
    }
    this.emitDescriptionBlock(description)

    const camelCaseName = modifySource(camelCase, name)
    this.emitBlock(
      [
        'public void ',
        camelCaseName,
        '(',
        ...(hasProperties ? ['final @Nullable ', name, ' props'] : []),
        hasProperties && withOptions ? ', ' : '',
        withOptions ? 'final @Nullable Options options' : '',
        ')'
      ],
      () => {
        this.emitLine([
          'this.analytics.track("',
          getRawName(name),
          '", ',
          hasProperties ? 'props.toProperties()' : 'new Properties()',
          withOptions ? ', options' : '',
          ');'
        ])
      }
    )
  }

  protected emitAnalyticsWrapper(): void {
    const className = upperFirst(camelCase(`${this.options.trackingPlan || ''}Analytics`))
    this.emitFileHeader(className, [
      'com.segment.analytics.Analytics',
      'com.segment.analytics.Options',
      'android.content.Context',
      'android.support.annotation.NonNull',
      'android.support.annotation.Nullable'
    ])
    this.emitBlock(['public class ', className], () => {
      this.emitLine('private Analytics analytics;')
      this.ensureBlankLine()

      this.emitDescriptionBlock([
        [
          'Initializes a new ',
          className,
          ' client wrapping the provided Segment Analytics client.'
        ],
        '@param analytics {@link Analytics} configured Segment analytics instance',
        '@see <a href="https://segment.com/docs/sources/mobile/android/#getting-started">Android Getting Started</a>'
      ])
      this.emitBlock(['public ', className, '(final @NonNull Analytics analytics)'], () => {
        this.emitLine('this.analytics = analytics;')
      })
      this.ensureBlankLine()

      this.forEachTopLevel('leading-and-interposing', (t, name) => {
        if (t instanceof ObjectType) {
          const hasProperties = t.getProperties().size > 0
          this.emitAnalyticsEventWrapper(name, hasProperties, false)
          this.ensureBlankLine()
          this.emitAnalyticsEventWrapper(name, hasProperties, true)
        }
      })
    })
  }

  protected emitSourceStructure(): void {
    super.emitSourceStructure()
    this.emitAnalyticsWrapper()
  }
}

export async function genJava(
  events: TrackedEvent[],
  { package: packageName, trackingPlan }: Params
) {
  return quicktypeMultiFile({
    lang: new AnalyticsJavaTargetLanguage(packageName, trackingPlan),
    inputData: processEventsForQuickType(events)
  })
}

export const handler = getTypedTrackHandler(async (params: Params, { events }) => {
  let files: ReadonlyMap<string, SerializedRenderResult>

  if (params.language === 'java') {
    files = await genJava(events, params)
  } else {
    throw new Error(`Invalid language: ${params.language}`)
  }

  // Handle filename naming collisions. Note that many filesystems are case-insensitive,
  // so CheckIn.java === Checkin.java
  // This is a temporary solution, until an upstream PR can be made to QuickType.
  // See: https://quicktype.slack.com/archives/C68E91E8J/p1551486779009600
  const seenFilenames: Set<string> = new Set()

  return Promise.all(
    map([...files.keys()], (fileName: string) => {
      if (seenFilenames.has(fileName.toLowerCase())) {
        console.warn(
          `Multiple events in your Tracking Plan map to the same filename (${fileName}). Consider removing or changing one of these events. If this is a blocker, please open an issue: https://github.com/segmentio/typewriter/issues/new`
        )
      }
      seenFilenames.add(fileName.toLowerCase())

      return writeFile(`${params.outputPath}/${fileName}`, files.get(fileName)!.lines.join('\n'))
    })
  )
})
